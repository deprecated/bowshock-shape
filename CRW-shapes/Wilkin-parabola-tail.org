#+OPTIONS: ^:{}

FIT QUADRICS TO WILKIN SHELL SHAPE

* DONE Fit to the head

In equation (18) of Canto et al. 1996 we have the explicit form 
of the Bow shock shape

$$R(\theta) = R_0\csc\theta\sqrt{3(1-\theta\cot\theta)}$$

Already have proved that:

\begin{align}
\tilde{R}_{90} &= \sqrt{3} \\
\tilde{R}_c &= \frac{5}{3} \\
T_c &= \frac{1}{3}
\end{align} 

So, the fit to the head must be an ellipsoid

* DONE Fit to the tail

Since R(\theta) exists for  -\pi < \theta < \pi,  R has not an hyperbolic behavior in the wings, so we must try
the parabolic behavior. The methods I've thought about are the following:

** DONE "Two points" method

The idea is that if we have at least 3 points which belong to the Wilkin bowshock we may obtain the
parameters of a parabola, whose parametric equations are the following:


\begin{align}
x &= -\frac{1}{2}\tilde{R}_c t^2 + x_0 \\
y &= \tilde{R}_c t
\end{align}

This equations have the constriction that the maximum of the parabola should be at the x axis, so the 
needed points to know are reduced to 2.

\begin{align}
x_1 &= -\frac{1}{2}\tilde{R}_c t_1^2 + x_0 \\
y_1 &= \tilde{R}_c t_1
\end{align}

\begin{align}
x_2 &= -\frac{1}{2}\tilde{R}_c t_2^2 + x_0 \\
y_2 &= \tilde{R}_c t_2
\end{align}

Where:

\begin{align}
x_1 = R_1\cos\theta_1 \\
x_2 = R_2\cos\theta_2 \\
y_1 = R_1\sin\theta_1 \\
y_2 = R_2\sin\theta_2 
\end{align}

$\theta_1$ and \theta_2 are particular angles which belong to the tail, and $R_1 = R(\theta_1)$, $R_2 = R(\theta_2)$

Substracting $x_2$ from $x_1$ we get the following:

\begin{align}
x_1 - x_2 &= - \frac{1}{2\tilde{R_c}}\left(y_1^2 - y_2^2\right) \\
\implies \tilde{R}_c &=  -\frac{1}{2} \frac{y_1^2 - y_2^2}{x_1-x_2}
\end{align}

In the same way, doing the sum we get the following:

\begin{align}
x_0 = \frac{x_1 + x_2}{2} + \frac{1}{4\tilde{R}_c}\left(y_1^2 + y_2^2\right)
\end{align}

** DONE "Gradient method" 
\begin{align*}
x &= -\frac{1}{2}\tilde{R}_c t^2 + x_0 \\
y &= \tilde{R}_c t \\
\implies -\frac{dx}{dy} &= t
\end{align*}

By the other hand:
\begin{align*}
t &= \frac{y}{\tilde{R}_c}
\implies -\frac{dx}{dy} &= \frac{y}{\tilde{R}_c} 
\end{align*}
With this, is possible to find $\tilde{R}_c$ by doing a linear fit to $-dx/dy$ of Wilkin solution at a certain range of 
$y$, while $x_0$ may be found giving a point which belongs to $R(\theta)$.
** DONE Motivation for the parabolic fit methods
   + Tried to emulate existing fitting methods for the bowshock shapes 
     checking ./two-quadric-th90-vs-i.py and ./conic_parameters.py and found the following into the *HeadTail* Class:

>
>        elif method == 'match R90 and gradient':
>            # New 30 Sep 2016 - fit tail to y, dy/dx @ 90 deg, instead
>            # of to head conic
>            self.x0_t = self.R90*self.m90 / self.tau_t**2
>            self.a_t = np.sqrt(self.x0_t**2 - (self.R90/self.tau_t)**2)
>            self.x_m = 0.0      # for completeness, but we don't use it
>

   + Next: Adapted the method to the parabola case: the gradient of a parabola must be a linear function. I developed
     two different methods to obtain the slope: 

       - Obtain the slope with two points which belongs to the Wilkin solution --> "Two points method"
       - Fit a linear function to the gradient --> "Gradient Method"

   - [ ]  Next step: Rewrite fitting methods as a python class and implement the results

** TODO Non parabolic methods

Since the Wilkin solution for the two winds interacting bow shock seems to be more complicated than a simple parabola we must try 
approximations that doesn't assume the tail behavior is parabolic and do a straightforward projection as section 3.

For the tail we may do the following approximation for the Wilkin solution:

\begin{align}
R(\theta) \simeq \sqrt{-3*\theta\csc^2\cot\theta}
\end{align}

*** DONE Taylor series tail method

We make a change of variable $\phi = \pi - \theta$, so we get the following:

\begin{align}
R(\phi) \simeq \sqrt{3*(\pi-\phi)\csc^2\phi\cot\phi}
\end{align}

And then, approximate the tail shape with Taylor Series until Nth order.
Using mathematica as exploratory approximation, I found out that the result is a serie of powers of the
square root of phi.

*** DONE Polynomial fit method

Another approximation is doing a polynomial fit via least squares to $R(\phi)$ until Nth order. Maybe this is
a more easy and useful approximation. Is worth to try.

*** DONE Non parabolic Gradient method

Similar to parabolic gradient method, but instead of fitting dx/dy we'll fit dy/dx to a line.

** DONE Test the "Two points" method
#+NAME: Wilkin-Parabola-Fit-2points
#+BEGIN_SRC python :eval no :tangle ./2-points-parabola-fit.py
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
def wilkin_tail_params(t1,t2):
    def pointR(t):
        return np.sqrt(3*(1-t/np.tan(t))/np.sin(t)**2)
    x1 = pointR(t1)*np.cos(t1)
    x2 = pointR(t2)*np.cos(t2)
    y1 = pointR(t1)*np.sin(t1)
    y2 = pointR(t2)*np.sin(t2)
    Rc = -0.5*(y1**2-y2**2)/(x1-x2)
    x0 = 0.5*(x1+x2) + 0.25*(y1**2+y2**2)/Rc
    return Rc,x0

#def R(T):
#    if t == 0:
theta1 = np.radians(110)
theta2 = np.radians(150)
Rcp,x0p = wilkin_tail_params(theta1,theta2)
theta = np.linspace(0,np.pi,500,endpoint=False)
R = np.sqrt(3*(1-theta/np.tan(theta))/np.sin(theta)**2)
x = R*np.cos(theta)
y = R*np.sin(theta)

# ################## t parameter for parabola ####################
Q2 = 1
Q1 = 2/np.tan(theta)
Q0 = -2*x0p/Rcp
tp = (-Q1 + np.sqrt(Q1**2 - 4*Q2*Q0))/(2*Q2)
##################################################################

xp = -0.5*Rcp*tp**2 + x0p
yp = Rcp*tp
R90 = np.sqrt(3.)
Rc = 5./3
Tc = 2*Rc - R90**2
a = Rc/Tc
b = Rc/np.sqrt(Tc)

################ t parameter for ellipse ########################
C2 = a**2 + b**2/np.tan(theta)**2
C1 = 2*b*(a-1)/np.tan(theta)
C0 = 1-2*a
sin_te = (-C1 + np.sqrt(C1**2 - 4*C2*C0))/(2*C2)
cos_te = np.sqrt(1. - sin_te**2)
################################################################# 

xe = a*cos_te + 1-a
ye = b*sin_te
f = plt.figure()
ax1 = f.add_subplot(2,1,1,adjustable="box",aspect=1)
ax1.plot(x,y,"k-",lw=2,alpha=0.5)
ax1.plot(xp,yp)
ax1.plot(xe,ye)
ax1.set_xlim(-50,1)
#plt.gca().set_aspect("equal","box")
plt.ylim(0,20)
# Plot residuals

R_par = np.sqrt(xp**2 + yp**2)
Re = np.sqrt(xe**2 + ye**2)
epsilon = np.abs(R - R_par)/R
epsilone = np.abs(R - Re)/R
ax2 = f.add_subplot(2,1,2,adjustable="box",aspect=100)
#ax2.plot(np.degrees(theta),np.degrees(theta_par))
#ax2.plot(np.degrees(theta),R_par)
#ax2.plot(np.degrees(theta),R2,"k-")
#ax2.plot(np.degrees(theta),Re)
ax2.plot(np.degrees(theta),epsilon)
ax2.plot(np.degrees(theta),epsilone)
#ax2.set_xlim(0,160)
ax2.set_ylim(-0.1,1)
f.set_size_inches(6,6)
f.savefig("2-points-par-test.pdf") 
#+END_SRC

DIAGNOSTIC:
The parabola fit is only good in the region \theta_l < \theta < \theta_h,
where \theta_l is the point with lower \theta and \theta_h the point with 
higher \theta. And becomes less accurate if \theta_l and \theta_h are very
separated.

#+BEGIN_SRC sh :results verbatim
python 2-points-parabola-fit.py
#+END_SRC

#+RESULTS:

** DONE Test the "Gradient method"
#+NAME: Wilkin-Parabola-Fit-gradient
#+BEGIN_SRC python :eval no :tangle ./gradient-parabola-fit.py
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def R_point(t):
    """
    Evaluate R at a singular value for theta
    """
    return np.sqrt(3*(1-t/np.tan(t))/np.sin(t)**2)

def par_fit(D,y,y1,y2):
    """
    Do linear fit for dx/dy in the [y1,y2] range
    """
    mask = (y1 < y) & (y < y2) 
    fit = np.polyfit(y[mask],D[mask],1)
    m = fit[0]
    yref = fit[1]
    return m, yref 
theta = np.linspace(0,np.pi,400,endpoint=False)
R = np.sqrt(3*(1-theta/np.tan(theta))/np.sin(theta)**2)


############### Plot gradient and linear fit ####################
x = R*np.cos(theta)
y = R*np.sin(theta)
dxdy = np.diff(x)/np.diff(y)
th_min = 90
th_max = 110
y_min = R_point(np.radians(th_min))*np.sin(np.radians(th_min)) 
y_max = R_point(np.radians(th_max))*np.sin(np.radians(th_max))
mfit, y_ref = par_fit(dxdy, y[:-1], y_min, y_max)
dxdy_line = mfit*y[:-1] + y_ref
f = plt.figure()
#ax1 = f.add_subplot(3, 1, 1, adjustable="box", aspect=1)
ax1 = f.add_subplot(3, 1, 1, adjustable="box", aspect=0.1)
ax1.plot(y[:-1], dxdy, label="Wilkin")
ax1.plot(y[:-1], dxdy_line, label="Linear fit")
ax1.legend()
ax1.set_xlabel(r"$y$")
ax1.set_ylabel(r"$\frac{dx}{dy}$")
#################################################################

################## Plot parabola and ellipse ####################
Rcp = -1./mfit
y1 = y_max
x1 = y1/np.tan(np.radians(th_min))
x0p = x1 + 0.5*y1**2/Rcp
# ################## t parameter for parabola ####################
Q2 = 1
Q1 = 2/np.tan(theta)
Q0 = -2*x0p/Rcp
tp = (-Q1 + np.sqrt(Q1**2 - 4*Q2*Q0))/(2*Q2)
xp = -0.5*Rcp*tp**2 + x0p
yp = Rcp*tp
##################################################################

################ t parameter for ellipse ########################
R90 = np.sqrt(3.)
Rce = 5./3
Tc = 2*Rce - R90**2
a = Rce/Tc
b = Rce/np.sqrt(Tc)
C2 = a**2 + b**2/np.tan(theta)**2
C1 = 2*b*(a-1)/np.tan(theta)
C0 = 1-2*a
sin_te = (-C1 + np.sqrt(C1**2 - 4*C2*C0))/(2*C2)
cos_te = np.sqrt(1. - sin_te**2)
xe = a*cos_te + (1-a)
ye = b*sin_te
################################################################# 
ax2 = f.add_subplot(3, 1, 2, adjustable="box", aspect=1)
ax2.plot(x, y, "k-", lw=2, alpha=0.7, label="Wilkin")
ax2.plot(xp, yp, label="Parabola fit")
ax2.plot(xe, ye, label="Elliptic head")
ax2.legend()
ax2.set_xlabel(r"$x$")
ax2.set_ylabel(r"$y$")  
ax2.set_xlim(-100,1)
ax2.set_ylim(0,20) 
#################################################################

##################### Plot residuals ############################
R_par = np.sqrt(xp**2 + yp**2)
Re = np.sqrt(xe**2 + ye**2)
epsilon = np.abs(R - R_par)/R
epsilone = np.abs(R - Re)/R
ax3 = f.add_subplot(3, 1, 3, adjustable="box", aspect=50)
ax3.plot(np.degrees(theta), epsilon, label="Parabolic Tail")
ax3.plot(np.degrees(theta), epsilone, label="Elliptic Head")
ax3.set_ylim(-0.1,1) 
ax3.set_xlabel(r"$\theta$ (deg)")
ax3.set_ylabel(r"$\epsilon$")
ax3.fill_between(np.degrees(theta), 0, 0.1, alpha=0.5)
#################################################################
f.savefig("gradient-par-test.pdf")
print("Rc = {}, x0 = {}".format(Rcp, x0p))
############## Compare gradient and two points method ###########
def wilkin_tail_params(t1,t2):
    def pointR(t):
        return np.sqrt(3*(1-t/np.tan(t))/np.sin(t)**2)
    x1 = pointR(t1)*np.cos(t1)
    x2 = pointR(t2)*np.cos(t2)
    y1 = pointR(t1)*np.sin(t1)
    y2 = pointR(t2)*np.sin(t2)
    Rc = -0.5*(y1**2-y2**2)/(x1-x2)
    x0 = 0.5*(x1+x2) + 0.25*(y1**2+y2**2)/Rc
    return Rc,x0

TpRc,Tpx0 = wilkin_tail_params(np.radians(th_min),np.radians(th_max)) 

Q2 = 1
Q1 = 2/np.tan(theta)
Q0 = -2*Tpx0/TpRc
Tpt = (-Q1 + np.sqrt(Q1**2 - 4*Q2*Q0))/(2*Q2)
Tpx = -0.5*TpRc*tp**2 + Tpx0
Tpy = TpRc*tp
TpR = np.sqrt(Tpx**2 + Tpy**2)
Tpepsilon = np.abs(TpR - R)/R
plt.clf()
plt.plot(np.degrees(theta), epsilon, label="Gradient method residuals")
plt.plot(np.degrees(theta), Tpepsilon, label="2 points method residuals", lw=4, alpha=0.7)
plt.legend()
plt.xlabel(r"$\theta$ (deg)")
plt.ylabel(r"$\epsilon$")
plt.savefig("residuals-comparison.pdf")
#################################################################
#+END_SRC
Diagnostic: This method seem to have similar results as the Two points method.
Need a direct comparison to check if both methods are equivalent.

#+BEGIN_SRC sh
python gradient-parabola-fit.py
#+END_SRC

#+RESULTS:

[[file:gradient-par-test.pdf]]
** DONE Compare both parabolic methods
- [X] Enhance Gradient method program

Diagnostic: Gradient method seems to have less residuals than the two points method
** DONE Test Polynomial fit method
#+NAME: Polynomial Method
#+BEGIN_SRC python :eval no :tangle ./poly_fit_tail.py
  import numpy as np
  import matplotlib.pyplot as plt
  import seaborn as sns

  ##################### Create theta and R arrays #########################

  theta = np.linspace(0, np.pi, 400, endpoint=False)
  phi = np.pi - theta
  R = np.sqrt(3*(1 - theta/np.tan(theta))/np.sin(theta)**2)
  R_app = np.sqrt(3*(np.pi - phi)*np.cos(phi)/np.sin(phi)**3)

  ############### Test 1: Plot real vs approximate solution ###############

  plt.plot(np.degrees(theta), R, 'k-', alpha=0.8, lw=4, label='Exact solution')
  plt.plot(np.degrees(theta), R_app, label='approximate solution')
  plt.legend()
  plt.savefig("poly_fit_tail.pdf")

  #########################################################################
  # Diagnostic: No difference for theta > 90                              #
  #########################################################################

  ############# Fit a polynomial function to R_app (the tail) #############
  m = np.isfinite(R_app)
  p2 = np.polyfit(phi[m], R_app[m], 2)
  p3 = np.polyfit(phi[m], R_app[m], 3)
  p4 = np.polyfit(phi[m], R_app[m], 4) 
  R_poly_2 = p2[0]*phi**2 + p2[1]*phi + p2[2]
  R_poly_3 = p3[0]*phi**3 + p3[1]*phi**2 + p3[2]*phi + p3[3]
  R_poly_4 = p4[0]*phi**4 + p4[1]*phi**3 + p4[2]*phi**2 + p4[3]*phi + p4[4]

  ############# Test 2: Plot R_app vs polynomial fit ######################

  plt.clf()
  plt.plot(phi, R_app, "k-", lw=4, alpha=0.6, label="Approximate Solution")
  plt.plot(phi, R_poly_2, label="Quadratic Polynomial fit")
  plt.plot(phi, R_poly_3, label="Cubic Polynomial fit")
  plt.plot(phi, R_poly_4, label="Quartic Polynomial fit")
  plt.legend()
  plt.savefig("poly_fit_tail_2.pdf")
#+END_SRC
Diagnostic: Maybe I need a very high order polynomial to have a good
approximation.
** TODO Test Non parabolic Gradient method

#+BEGIN_SRC python :eval no :tangle ./non-parabolic-gradient-test.py
  import numpy as np
  import matplotlib.pyplot as plt
  import seaborn as sns

  theta = np.linspace(np.radians(100), np.radians(150), 400, endpoint=False)
  R = np.sqrt(3*(1 - theta/np.tan(theta))/np.sin(theta)**2)


  ############### Plot gradient and linear fit ####################
  x = R*np.cos(theta)
  y = R*np.sin(theta)
  dydx = np.diff(y)/np.diff(x)
  #y_min = R_point(np.radians(110))*np.sin(np.radians(110)) 
  #y_max = R_point(np.radians(150))*np.sin(np.radians(150))
  #mfit, y_ref = par_fit(dxdy,y[:-1],y_min,y_max)
  #dxdy_line = mfit*y[:-1] + y_ref
  f = plt.figure()
  ax1 = f.add_subplot(1, 1, 1, adjustable="box", aspect=10)
  ax1.plot(x[:-1], dydx, label="Wilkin")
  #ax1.plot(x[:-1], dydx_line, label="Linear fit")
  ax1.legend()
  ax1.set_xlabel(r"$x$")
  ax1.set_ylabel(r"$\frac{dy}{dx}$")
  #################################################################
  f.savefig("non-parabolic-test.pdf")
#+END_SRC
* TODO Projection onto the plane of sky of Wilkin fits

  + The Wilkin solution for the bowshock shape in the isotropic/parallel
    wind interaction may be approximated by two conics:
    - The head is approximated by an ellipsoid with $\tan\theta_c = 1/3$
    - The tail is approximated by a paraboloid with $\tilde{R}_c \simeq 0.865$
      and $x_0 \simeq 2.946$. These parameters were obtined by a linear fit near
      90 degrees on the original Wilkin solution (check section /Fit to the tail/).
      
  + Both fits combined are below 10% of error until 150 degrees. Given that, the 
    maximum inclination where this approximation is reliable is about i = 72 deg.
    The transition between the head fit and the tail fit is about at 125 degrees.
    R'_90 can be measured reliably with the head fit for i < 55 deg. After that, 
    the tail fit must be used. R'_c can be measured reliably with the head fit 
    for i < 70 deg. After that, the tail fit must be used.

** TODO Implementation

#+BEGIN_SRC python :eval no :tangle ./Wilkin-projection.py
  import numpy as np
  import matplotlib.pyplot as plt
  import seaborn as sns

  ############### Projected characteristic radii functions ###############

  def f(i, Tc):
      """
      Part of equations (44), (45) and (47)
      """
      return np.sqrt(1 + Tc*np.tan(np.radians(i)))

  def R0_proj(Rc, Tc, i):
      """
      Projected Radius at the Symmetry Axis
      """
      return 1 + Rc*(f(i, Tc) - 1)/Tc 

  def elliptic_proj(Rc, Tc, i):
      """
      Projection of the ellipsoidal head. Equations (45) and (47)
      """
      Rc_p = Rc/(np.cos(np.radians(i))**2*f(i, Tc)*R0_proj(Rc, Tc, i))
      R90_p = np.sqrt(2*Rc*f(i, Tc) - Tc*R0_proj(Rc, Tc, i))/(np.cos(np.radians(i))*f(i, Tc)*np.sqrt(R0_proj(Rc, Tc, i)))
      return Rc_p, R90_p

  def parabolic_proj(Rc, i):
      """
      Projection of parabolic fit to the tail. Equation (A10)
      """
      Rc_p = Rc/(np.cos(np.radians(i))**2 + 0.5*Rc*np.sin(np.radians(i))**2)
      R90_p = np.sqrt(2*Rc_p)
      return Rc_p, R90_p

  ################ Non projected characteristic radii ####################

  Rc = 5./3
  R90 = np.sqrt(3.)

  ################ Conic parameters (Head and tail) ######################

  Tch = 2*Rc - R90**2
  Rct = 0.865
  x0t = 2.94611

  ###################### Set inclination array ###########################

  inc = np.linspace(0, 72)
  inc_cut_1 = 55
  inc_cut_2 = 70
  ######################## Loop over inclination #########################
  sns.set_style("white")
  for i in inc:
      Rcph, R90ph = elliptic_proj(Rc, Tch, i)
      Rcpt, R90pt = parabolic_proj(Rct, i)

      if i < inc_cut_1:
          plt.plot(Rcph, R90ph, "bo")
      elif i < inc_cut_2:
          plt.plot(Rcph, R90pt, "go")
      else:
          plt.plot(Rcpt, R90pt, "ro")

  Rc_grid = np.linspace(0, 10, 2000)
  R90_grid = np.sqrt(2*Rc_grid)
  R90_grid_s = np.sqrt(2*Rc_grid - 1.0)
  R90_grid_s[~np.isfinite(R90_grid_s)] = 0.0
  plt.fill_between(Rc_grid, 0, R90_grid_s, color="k", alpha=0.1)
  plt.fill_between(Rc_grid, R90_grid_s, R90_grid, color="k", alpha=0.3)
  plt.xlabel(r"$\tilde{R}'_c$")
  plt.ylabel(r"$\tilde{R}'_{90}$")
  plt.xlim(0, 4)
  plt.ylim(0, 4)
  plt.savefig("Wilkin_projected.pdf")
#+END_SRC

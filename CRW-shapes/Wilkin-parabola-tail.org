#+OPTIONS: ^:{}

FIT QUADRICS TO WILKIN SHELL SHAPE

* DONE Fit to the head

In equation (18) of Canto et al. 1996 we have the explicit form 
of the Bow shock shape

$$R(\theta) = R_0\csc\theta\sqrt{3(1-\theta\cot\theta)}$$

Already have proved that:

\begin{align}
\tilde{R}_{90} &= \sqrt{3} \\
\tilde{R}_c &= \frac{5}{3} \\
T_c &= \frac{1}{3}
\end{align} 

So, the fit to the head must be an ellipsoid

* TODO Fit to the tail

Since R(\theta) exists for  -\pi < \theta < \pi,  R has not an hyperbolic behavior in the wings, so we must try
the parabolic behavior. The methods I've thought about are the following:

** DONE "Two points" method

The idea is that if we have at least 3 points which belong to the Wilkin bowshock we may obtain the
parameters of a parabola, whose parametric equations are the following:


\begin{align}
x &= -\frac{1}{2}\tilde{R}_c t^2 + x_0 \\
y &= \tilde{R}_c t
\end{align}

This equations have the constriction that the maximum of the parabola should be at the x axis, so the 
needed points to know are reduced to 2.

\begin{align}
x_1 &= -\frac{1}{2}\tilde{R}_c t_1^2 + x_0 \\
y_1 &= \tilde{R}_c t_1
\end{align}

\begin{align}
x_2 &= -\frac{1}{2}\tilde{R}_c t_2^2 + x_0 \\
y_2 &= \tilde{R}_c t_2
\end{align}

Where:

\begin{align}
x_1 = R_1\cos\theta_1 \\
x_2 = R_2\cos\theta_2 \\
y_1 = R_1\sin\theta_1 \\
y_2 = R_2\sin\theta_2 
\end{align}

$\theta_1$ and \theta_2 are particular angles which belong to the tail, and $R_1 = R(\theta_1)$, $R_2 = R(\theta_2)$

Substracting $x_2$ from $x_1$ we get the following:

\begin{align}
x_1 - x_2 &= - \frac{1}{2\tilde{R_c}}\left(y_1^2 - y_2^2\right) \\
\implies \tilde{R}_c &=  -\frac{1}{2} \frac{y_1^2 - y_2^2}{x_1-x_2}
\end{align}

In the same way, doing the sum we get the following:

\begin{align}
x_0 = \frac{x_1 + x_2}{2} + \frac{1}{4\tilde{R}_c}\left(y_1^2 + y_2^2\right)
\end{align}

** DONE "Gradient method" 
\begin{align*}
x &= -\frac{1}{2}\tilde{R}_c t^2 + x_0 \\
y &= \tilde{R}_c t \\
\implies -\frac{dx}{dy} &= t
\end{align*}

By the other hand:
\begin{align*}
t &= \frac{y}{\tilde{R}_c}
\implies -\frac{dx}{dy} &= \frac{y}{\tilde{R}_c} 
\end{align*}
With this, is possible to find $\tilde{R}_c$ by doing a linear fit to $-dx/dy$ of Wilkin solution at a certain range of 
$y$, while $x_0$ may be found giving a point which belongs to $R(\theta)$.
** TODO Non parabolic methods
Since the Wilkin solution for the two winds interacting bow shock seems to be more complicated than a simple parabola we must try 
approximations that doesn't assume the tail behavior is parabolic and do a straightforward projection as section 3.
*** TODO Taylor series tail method
*** TODO Non parabolic Gradient method
*** TODO Polynomial fit method 
** DONE Test the "Two points" method
#+NAME: Wilkin-Parabola-Fit-2points
#+BEGIN_SRC python :eval no :tangle ./2-points-parabola-fit.py
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
def wilkin_tail_params(t1,t2):
    def pointR(t):
        return np.sqrt(3*(1-t/np.tan(t))/np.sin(t)**2)
    x1 = pointR(t1)*np.cos(t1)
    x2 = pointR(t2)*np.cos(t2)
    y1 = pointR(t1)*np.sin(t1)
    y2 = pointR(t2)*np.sin(t2)
    Rc = -0.5*(y1**2-y2**2)/(x1-x2)
    x0 = 0.5*(x1+x2) + 0.25*(y1**2+y2**2)/Rc
    return Rc,x0

#def R(T):
#    if t == 0:
theta1 = np.radians(110)
theta2 = np.radians(150)
Rcp,x0p = wilkin_tail_params(theta1,theta2)
theta = np.linspace(0,np.pi,500,endpoint=False)
R = np.sqrt(3*(1-theta/np.tan(theta))/np.sin(theta)**2)
x = R*np.cos(theta)
y = R*np.sin(theta)

# ################## t parameter for parabola ####################
Q2 = 1
Q1 = 2/np.tan(theta)
Q0 = -2*x0p/Rcp
tp = (-Q1 + np.sqrt(Q1**2 - 4*Q2*Q0))/(2*Q2)
##################################################################

xp = -0.5*Rcp*tp**2 + x0p
yp = Rcp*tp
R90 = np.sqrt(3.)
Rc = 5./3
Tc = 2*Rc - R90**2
a = Rc/Tc
b = Rc/np.sqrt(Tc)

################ t parameter for ellipse ########################
C2 = a**2 + b**2/np.tan(theta)**2
C1 = 2*b*(a-1)/np.tan(theta)
C0 = 1-2*a
sin_te = (-C1 + np.sqrt(C1**2 - 4*C2*C0))/(2*C2)
cos_te = np.sqrt(1. - sin_te**2)
################################################################# 

xe = a*cos_te + 1-a
ye = b*sin_te
f = plt.figure()
ax1 = f.add_subplot(2,1,1,adjustable="box",aspect=1)
ax1.plot(x,y,"k-",lw=2,alpha=0.5)
ax1.plot(xp,yp)
ax1.plot(xe,ye)
ax1.set_xlim(-50,1)
#plt.gca().set_aspect("equal","box")
plt.ylim(0,20)
# Plot residuals

R_par = np.sqrt(xp**2 + yp**2)
Re = np.sqrt(xe**2 + ye**2)
epsilon = np.abs(R - R_par)/R
epsilone = np.abs(R - Re)/R
ax2 = f.add_subplot(2,1,2,adjustable="box",aspect=100)
#ax2.plot(np.degrees(theta),np.degrees(theta_par))
#ax2.plot(np.degrees(theta),R_par)
#ax2.plot(np.degrees(theta),R2,"k-")
#ax2.plot(np.degrees(theta),Re)
ax2.plot(np.degrees(theta),epsilon)
ax2.plot(np.degrees(theta),epsilone)
#ax2.set_xlim(0,160)
ax2.set_ylim(-0.1,1)
f.set_size_inches(6,6)
f.savefig("2-points-par-test.pdf") 
#+END_SRC

DIAGNOSTIC:
The parabola fit is only good in the region \theta_l < \theta < \theta_h,
where \theta_l is the point with lower \theta and \theta_h the point with 
higher \theta. And becomes less accurate if \theta_l and \theta_h are very
separated.

#+BEGIN_SRC sh :results verbatim
python 2-points-parabola-fit.py
#+END_SRC

#+RESULTS:

** DONE Test the "Gradient method"
#+NAME: Wilkin-Parabola-Fit-gradient
#+BEGIN_SRC python :eval no :tangle ./gradient-parabola-fit.py
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

def R_point(t):
    """
    Evaluate R at a singular value for theta
    """
    return np.sqrt(3*(1-t/np.tan(t))/np.sin(t)**2)

def par_fit(D,y,y1,y2):
    """
    Do linear fit for dx/dy in the [y1,y2] range
    """
    mask = (y1 < y) & (y < y2) 
    fit = np.polyfit(y[mask],D[mask],1)
    m = fit[0]
    yref = fit[1]
    return m, yref 
theta = np.linspace(0,np.pi,400,endpoint=False)
R = np.sqrt(3*(1-theta/np.tan(theta))/np.sin(theta)**2)


############### Plot gradient and linear fit ####################
x = R*np.cos(theta)
y = R*np.sin(theta)
dxdy = np.diff(x)/np.diff(y)
y_min = R_point(np.radians(90))*np.sin(np.radians(90)) 
y_max = R_point(np.radians(150))*np.sin(np.radians(150))
mfit, y_ref = par_fit(dxdy,y[:-1],y_min,y_max)
dxdy_line = mfit*y[:-1] + y_ref
f = plt.figure()
#ax1 = f.add_subplot(3, 1, 1, adjustable="box", aspect=1)
ax1 = f.add_subplot(3, 1, 1, adjustable="box", aspect=0.1)
ax1.plot(y[:-1], dxdy, label="Wilkin")
ax1.plot(y[:-1], dxdy_line, label="Linear fit")
ax1.legend()
ax1.set_xlabel(r"$y$")
ax1.set_ylabel(r"$\frac{dx}{dy}$")
#################################################################

################## Plot parabola and ellipse ####################
Rcp = -1./mfit
y1 = y_max
x1 = y1/np.tan(np.radians(150))
x0p = x1 + 0.5*y1**2/Rcp
# ################## t parameter for parabola ####################
Q2 = 1
Q1 = 2/np.tan(theta)
Q0 = -2*x0p/Rcp
tp = (-Q1 + np.sqrt(Q1**2 - 4*Q2*Q0))/(2*Q2)
xp = -0.5*Rcp*tp**2 + x0p
yp = Rcp*tp
##################################################################

################ t parameter for ellipse ########################
R90 = np.sqrt(3.)
Rce = 5./3
Tc = 2*Rce - R90**2
a = Rce/Tc
b = Rce/np.sqrt(Tc)
C2 = a**2 + b**2/np.tan(theta)**2
C1 = 2*b*(a-1)/np.tan(theta)
C0 = 1-2*a
sin_te = (-C1 + np.sqrt(C1**2 - 4*C2*C0))/(2*C2)
cos_te = np.sqrt(1. - sin_te**2)
xe = a*cos_te + (1-a)
ye = b*sin_te
################################################################# 
ax2 = f.add_subplot(3, 1, 2, adjustable="box", aspect=1)
ax2.plot(x, y, "k-", lw=2, alpha=0.7, label="Wilkin")
ax2.plot(xp, yp, label="Parabola fit")
ax2.plot(xe, ye, label="Elliptic head")
ax2.legend()
ax2.set_xlabel(r"$x$")
ax2.set_ylabel(r"$y$")  
ax2.set_xlim(-100,1)
ax2.set_ylim(0,20)
#################################################################

##################### Plot residuals ############################
R_par = np.sqrt(xp**2 + yp**2)
Re = np.sqrt(xe**2 + ye**2)
epsilon = np.abs(R - R_par)/R
epsilone = np.abs(R - Re)/R
ax3 = f.add_subplot(3, 1, 3, adjustable="box", aspect=50)
ax3.plot(np.degrees(theta), epsilon, label="Parabolic Tail")
ax3.plot(np.degrees(theta), epsilone, label="Elliptic Head")
ax3.set_ylim(-0.1,1) 
ax3.set_xlabel(r"$\theta$ (deg)")
ax3.set_ylabel(r"$\epsilon$")
#################################################################
f.savefig("gradient-par-test.pdf")
#+END_SRC
Diagnostic: This method seem to have similar results as the Two points method.
Need a direct comparison to check if both methods are equivalent.

#+BEGIN_SRC sh
python gradient-parabola-fit.py
#+END_SRC

#+RESULTS:

[[file:gradient-par-test.pdf]]
** TODO Compare both parabolic methods
#+NAME: Compare-parabolic-fits
#+BEGIN_SRC python :eval no :tangle ./compare-parabolic-fits.py

#+END_SRC

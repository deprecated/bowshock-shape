
* Config
#+BEGIN_SRC emacs-lisp
(add-hook 'org-babel-after-execute-hook 'org-display-inline-images 'append)
#+END_SRC

#+RESULTS:
| org-display-inline-images |
* Set up plotting style
:PROPERTIES:
:ID:       29F006B9-1FDD-465B-B1C0-F8C488E21E92
:END:
#+BEGIN_SRC ipython :session ratio
  %matplotlib inline
  import matplotlib.pyplot as plt
  import numpy as np
  import seaborn as sns
  sns.set(context='notebook',
          style='darkgrid', 
          palette='bright',
          font_scale=1.5,
          color_codes=True)
  %config InlineBackend.figure_format = 'svg'
  black_style ={
   'text.color': '.85',
   'axes.edgecolor': '#3f3f3f',
   'axes.facecolor': '#504040',
   'axes.labelcolor': '.85',
   'figure.facecolor': '#3f3f3f',
   'grid.color': 'gray',
   'xtick.color': '.85',
   'ytick.color': '.85',
   
  }
  sns.set_style(rc=black_style)
#+END_SRC

#+RESULTS:
* Define the hyperbola model for the ratio \theta_1/\theta

#+BEGIN_SRC ipython :session ratio
import theta_ratio_fit 
from astropy.modeling.fitting import LevMarLSQFitter
#+END_SRC

#+RESULTS:


+ Run the following each time we edit the code in the =theta_ratio_fit= module.
+ Remember that =reload= needs to come from =importlib= in Python 3
#+BEGIN_SRC ipython :session ratio
  from importlib import reload
  reload(theta_ratio_fit)
#+END_SRC

#+RESULTS:
: <module 'theta_ratio_fit' from '/Users/will/Work/Bowshocks/Jorge/bowshock-shape/CRW-shapes/theta_ratio_fit.py'>


Since we used the =@custom_model= decorator on =hyperbola_ratio=, we only use the keyword arguments when setting up the model
#+BEGIN_SRC ipython :session ratio :exports both
  model = theta_ratio_fit.hyperbola_ratio(a=14.5, x0=15.0, tau=0.3, D=30.0)
  model
#+END_SRC

#+RESULTS:
: <hyperbola_ratio(a=14.5, x0=15.0, tau=0.3, D=30.0)>

That results in a callable =model(x)= as a function of the positional arguments (in this case, only =x=)

Find the asymptotic angle 
#+BEGIN_SRC ipython :session ratio :exports both
th_inf = np.pi - np.arctan(model.tau.value)
np.degrees(th_inf)
#+END_SRC

#+RESULTS:
: 163.30075576600638

* Plot the model for a fixed set of parameters
#+BEGIN_SRC ipython :session ratio :file figs/fig-ax.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  theta = np.linspace(0.0, th_inf, 100)
  ax.plot(np.degrees(theta), model(theta), c='c')
  ax.set(
      xlim=[0.0, 180.0], ylim=[0.0, None],
      xlabel=r'$\theta$', ylabel=r'$\theta_1/\theta$', 
      title=repr(model),
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-ax.svg]]


* Fit the model to the CRW shape
The exact solution
#+BEGIN_SRC ipython :session ratio
import equation6
BETA = 0.01
NTHETA = 100
shell = equation6.Shell(innertype='isotropic', beta=BETA)
theta = np.linspace(0.0, shell.th_infty, NTHETA)
R, theta1 = shell.radius(theta, full=True)
ratio = theta1/theta
#+END_SRC

#+RESULTS:

And the bad fit we did before, just to get the head really. 
+ Note that we interpolate onto the same =theta= grid as above
#+BEGIN_SRC ipython :session ratio
  from scipy.interpolate import interp1d
  import conic_parameters
  ht = conic_parameters.HeadTail(BETA, xi=None, xmin=0.0,
                                 method='match head to tail')
  x_head = ht.x_head(ht.t_h)
  y_head = ht.y_head(ht.t_h)
  theta_head = np.arctan2(y_head, x_head)
  theta1_head = np.arctan2(y_head, ht.D - x_head)
  ratio_head_func = interp1d(theta_head, theta1_head/theta_head)
  ratio_head = ratio_head_func(theta)
#+END_SRC

#+RESULTS:

Look at the star-star separation and the opening angle
#+BEGIN_SRC ipython :session ratio :exports both
ht.D, shell.th_infty
#+END_SRC

#+RESULTS:
| 11.0 | 2.697341127696881 |

And look at the position and scale of tail hyperbola from the matching fit
#+BEGIN_SRC ipython :session ratio :exports both
  [
      ['x_0', 'a', 'theta'],
      None,
      [f'{_:.4f}' for _ in [ht.x0_t, ht.a_t, np.pi - ht.theta_t]],
  ]
#+END_SRC

#+RESULTS:
|     x_0 |      a |  theta |
|--------+--------+--------|
| 8.1412 | 7.0685 | 2.6973 |

Also may be useful to use the /equation (26)/ approximation for the shape:
#+BEGIN_SRC ipython :session ratio
  def eq26(th, beta):
      """Equation (26) from CRW96 - approximate form for theta_1"""
      th1 = np.sqrt(7.5*(-1 + np.sqrt(1 + 0.8*beta*(1 - th/np.tan(th)))))
      return th1

  def ratio_eq26(th, beta):
      return eq26(th, beta)/th

#+END_SRC

#+RESULTS:

Set up a model using the matching parameters
#+BEGIN_SRC ipython :session ratio :exports both
  model = theta_ratio_fit.hyperbola_ratio(ht.a_t, x0=ht.x0_t,
                                          tau=np.tan(ht.theta_t), 
                                          D=ht.D)
  model
#+END_SRC

#+RESULTS:
: <hyperbola_ratio(a=7.06849525987864, x0=8.141161671279598, tau=0.47598478502008823, D=11.0)>

#+BEGIN_SRC ipython :session ratio
XI = None
#+END_SRC

#+RESULTS:

Compare them before doing the fitting
+ Note that we have had to drop the last point when plotting the model ratio since it goes funny at the asymptote
#+BEGIN_SRC ipython :session ratio :file figs/fig-prefit.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  ax.plot(np.degrees(theta[:-1]), model(theta[:-1]), c='c')
  ax.plot(np.degrees(theta), ratio, c='y')
  ax.plot(np.degrees(theta), ratio_head, c='w', ls=':')
  params_string = rf'CRW, $\beta = {BETA:.4f}$'
  ax.set(
      xlim=[0.0, 180.0], ylim=[0.0, None],
      xlabel=r'$\theta$', ylabel=r'$\theta_1/\theta$', 
      title=r'Before fit: ' + params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-prefit.svg]]

Freeze the =tau= and =D= parameters since they are external constraints
#+BEGIN_SRC ipython :session ratio
model.tau.fixed = True
model.D.fixed = True
#+END_SRC

#+RESULTS:


Now do the actual fitting

#+BEGIN_SRC ipython :session ratio :exports both
fit = LevMarLSQFitter()
mask = (np.degrees(theta) > 100.0) & (np.degrees(theta) < 150.0)
best_model = fit(model, theta[mask], ratio[mask])
best_model
#+END_SRC

#+RESULTS:
: <hyperbola_ratio(a=6.2041861893325505, x0=7.4797566889624285, tau=0.47598478502008823, D=11.0)>

#+BEGIN_SRC ipython :session ratio :file figs/fig-postfit.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  ax.plot(np.degrees(theta[:-1]), best_model(theta[:-1]), c='c')
  ax.plot(np.degrees(theta[:-1]), model(theta[:-1]), c='g', lw=1.0, ls='--')
  ax.plot(np.degrees(theta), ratio, c='y')
  ax.plot(np.degrees(theta), ratio_head, c='w', ls=':')
  ax.set(
      xlim=[0.0, 180.0], ylim=[None, None],
      xlabel=r'$\theta$', ylabel=r'$\theta_1/\theta$', 
      title=r'After fit: ' + params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-postfit.svg]]

/New [2017-02-01 Wed]/ - plot the residuals

#+BEGIN_SRC ipython :session ratio :file figs/fig-resid.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  resid_head = (ratio_head - ratio)/ratio
  resid_tail = (best_model(theta) - ratio)/ratio
  ax.plot(np.degrees(theta[:-1]), resid_tail[:-1],
          c='c', label='Tail fit')
  ax.plot(np.degrees(theta), resid_head,
          c='y', label='Head fit')
  ax.legend(fontsize='x-small')
  ax.set(
      xlim=[0.0, 180.0], ylim=[-0.03, 0.03],
      xlabel=r'$\theta$, degrees', ylabel=r'$\Delta \theta_1 / \theta_{1}$', 
      title=r'Fit residuals: ' + params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-resid.svg]]



Finally, we map it all back to real space, just to see how good the fit is. 

Update the tail hyperbola in the =HeadTail= instance
#+BEGIN_SRC ipython :session ratio
ht.a_t = best_model.a.value
ht.x0_t = best_model.x0.value
#+END_SRC

#+RESULTS:

And calculate cartesian arrays for the shapes
#+BEGIN_SRC ipython :session ratio
x_tail = ht.x_tail(ht.t_t)
y_tail = ht.y_tail(ht.t_t)

x_shell = R*np.cos(theta)/shell.R0
y_shell = R*np.sin(theta)/shell.R0
#+END_SRC

#+RESULTS:

#+BEGIN_SRC ipython :session ratio :file figs/fig-xy.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[4, 4])
  ax.plot(x_shell, y_shell, c='y', lw=2)
  ax.plot(x_tail, y_tail, ls='--', c='c')
  ax.plot(x_head, y_head, ls=':', c='w')
  ax.set(
      xlim=[-5.0, 2.0], ylim=[0.0, 7.0], aspect='equal',
      xlabel=r'$x/r_{0}$', ylabel=r'$y/r_{0}$',
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-xy.svg]]

* Now try the anisotropic case
+ The most difficult one was with k=0 (xi=1), where we don't seem to have the fits working very well
  + On the other hand, they did seem to work fine when we did it on the fine grid
+ With xi=0.8 and below it seems to be fine

#+BEGIN_SRC ipython :session ratio :results silent
XI = 0.1
BETA = 0.0001
shell = equation6.Shell(innertype='anisotropic', beta=BETA, xi=XI)
theta = np.linspace(0.0, shell.th_infty, NTHETA)
R, theta1 = shell.radius(theta, full=True)
ratio = theta1/theta
#+END_SRC

#+BEGIN_SRC ipython :session ratio :exports both
  ht = conic_parameters.HeadTail(BETA, xi=XI, xmin=0.0,
                                 method='match head to tail')
  x_head = ht.x_head(ht.t_h)
  y_head = ht.y_head(ht.t_h)
  theta_head = np.arctan2(y_head, x_head)
  theta1_head = np.arctan2(y_head, ht.D - x_head)
  ratio_head_func = interp1d(theta_head, theta1_head/theta_head)
  ratio_head = ratio_head_func(theta)

  ht.D, shell.th_infty
#+END_SRC

#+RESULTS:
| 101.0 | 3.1205098308389796 |

Set up the model again
#+BEGIN_SRC ipython :session ratio :exports both
  model = theta_ratio_fit.hyperbola_ratio(ht.a_t, x0=ht.x0_t,
                                          tau=np.tan(ht.theta_t), 
                                          D=ht.D)
  model
#+END_SRC

#+RESULTS:
: <hyperbola_ratio(a=nan, x0=-0.06896331929207974, tau=0.02108594697498954, D=101.0)>


#+BEGIN_SRC ipython :session ratio :file figs/fig-prefit-xi1.0.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  ax.plot(np.degrees(theta[:-1]), model(theta[:-1]), c='c')
  ax.plot(np.degrees(theta), ratio, c='y')
  ax.plot(np.degrees(theta), ratio_head, c='w', ls=':')
  params_string = r'$\xi = {:.1f}$; $\beta = {:.4f}$'.format(XI, BETA)
  ax.set(
      xlim=[0.0, 180.0], ylim=[0.0, None],
      xlabel=r'$\theta$', ylabel=r'$\theta_1/\theta$', 
      title=r'Before fit: ' + params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-prefit-xi1.0.svg]]

And do the fitting again
#+BEGIN_SRC ipython :session ratio :exports both
  model.tau.fixed = True
  model.D.fixed = True
  mask = (np.degrees(theta) > 110.0) & (np.degrees(theta) < 160.0)
  # mask = (np.degrees(theta) > 100.0) & (theta < shell.th_infty)
  best_model = fit(model, theta[mask], ratio[mask])
  # print(fit.fit_info)
  best_model
#+END_SRC

#+RESULTS:
: <hyperbola_ratio(a=nan, x0=-0.06896331929207974, tau=0.02108594697498954, D=101.0)>

#+BEGIN_SRC ipython :session ratio :file figs/fig-postfit-xi1.0.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  ax.plot(np.degrees(theta[:-1]), best_model(theta[:-1]), c='c')
  ax.plot(np.degrees(theta[:-1]), model(theta[:-1]), c='g', lw=1.0, ls='--')
  ax.plot(np.degrees(theta), ratio, c='y')
  ax.plot(np.degrees(theta), ratio_head, c='w', ls=':')
  ax.set(
      xlim=[0.0, 180.0], ylim=[None, None],
      xlabel=r'$\theta$', ylabel=r'$\theta_1/\theta$', 
      title=r'After fit: ' + params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-postfit-xi1.0.svg]]


Look at the residuals again
#+BEGIN_SRC ipython :session ratio :file figs/fig-resid-xi.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  resid_head = (ratio_head - ratio)/ratio
  resid_tail = (best_model(theta) - ratio)/ratio
  m = resid_head**2 < resid_tail**2
  ax.plot(np.degrees(theta[~m][:-1]), resid_tail[~m][:-1], c='c', label='Tail fit')
  ax.plot(np.degrees(theta[:-1]), resid_tail[:-1], c='c', lw=1, ls=':', label=None)
  ax.plot(np.degrees(theta[m]), resid_head[m], c='y', label='Head fit')
  ax.plot(np.degrees(theta), resid_head, c='y', lw=1, ls=':', label=None)
  ax.axvline(np.degrees(shell.th_infty), lw=0.5, c='w', ls='--')
  ax.legend(fontsize='x-small', frameon=True)
  ax.set(
      xlim=[0.0, 180.0], ylim=[-0.10, 0.10],
      xticks=[0, 30, 60, 90, 120, 150],
      xlabel=r'$\theta$, degrees', ylabel=r'$\Delta \theta_1 / \theta_{1}$', 
      title=r'Fit residuals: ' + params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-resid-xi.svg]]


And in physical space
#+BEGIN_SRC ipython :session ratio :file figs/fig-xy-xi1.0.svg :exports both
  ht.a_t = best_model.a.value
  ht.x0_t = best_model.x0.value
  x_tail = ht.x_tail(ht.t_t)
  y_tail = ht.y_tail(ht.t_t)
  x_shell = R*np.cos(theta)/shell.R0
  y_shell = R*np.sin(theta)/shell.R0

  fig, ax = plt.subplots(1, 1, figsize=[4, 4])
  ax.plot(x_shell, y_shell, c='y', lw=2)
  ax.plot(x_tail, y_tail, ls='--', c='c')
  ax.plot(x_head, y_head, ls=':', c='w')
  ax.set(
      xlim=[-5.0, 2.0], ylim=[0.0, 7.0], aspect='equal',
      xlabel=r'$x/r_{0}$', ylabel=r'$y/r_{0}$',
      title=params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-xy-xi1.0.svg]]

** Use the multi-level analytic fits
#+BEGIN_SRC ipython :session ratio :exports both
  import tail_analytic_mod

  BETA = 0.000001
  XI = 0.1

  if XI is None:
      shell = equation6.Shell(innertype='isotropic', beta=BETA)
      params_string = rf'CRW; $\beta = {BETA:.4f}$'
  else:
      shell = equation6.Shell(innertype='anisotropic', beta=BETA, xi=XI)
      params_string = rf'$\xi = {XI:.1f}$; $\beta = {BETA:.4f}$'

  ht = conic_parameters.HeadTail(BETA, xi=XI, xmin=0.0, method='analytic fit')
  x_head = ht.x_head(ht.t_h)
  y_head = ht.y_head(ht.t_h)
  theta_head = np.arctan2(y_head, x_head)
  theta1_head = np.arctan2(y_head, ht.D - x_head)

  theta = np.linspace(0.0, min(shell.th_infty, theta_head.max()),  NTHETA)
  R, theta1 = shell.radius(theta, full=True)
  ratio = theta1/theta

  ratio_head_func = interp1d(theta_head, theta1_head/theta_head)
  ratio_head = ratio_head_func(theta)
  model = theta_ratio_fit.hyperbola_ratio(ht.a_t, x0=ht.x0_t,
                                          tau=np.tan(ht.theta_t), 
                                          D=ht.D)
  model
#+END_SRC

#+RESULTS:
: <hyperbola_ratio(a=2365.4104251674953, x0=2368.411747732272, tau=0.004460395337086435, D=1000.9999999999999)>

#+BEGIN_SRC ipython :session ratio :file figs/fig-resid-analytic.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[5, 3])
  resid_head = (ratio_head - ratio)/ratio
  resid_tail = (model(theta) - ratio)/ratio
  m = (theta < 0.2) | (resid_head**2 < resid_tail**2)
  thm = np.min(theta[~m])
  m[theta > thm] = False
  ax.plot(np.degrees(theta[~m][:-1]), resid_tail[~m][:-1], c='c', label='Tail fit')
  ax.plot(np.degrees(theta[:-1]), resid_tail[:-1], c='c', lw=1, ls=':', label=None)
  ax.plot(np.degrees(theta[m]), resid_head[m], c='y', label='Head fit')
  ax.plot(np.degrees(theta), resid_head, c='y', lw=1, ls=':', label=None)
  ax.axvline(np.degrees(shell.th_infty), lw=0.5, c='w', ls='--')
  ax.legend(fontsize='x-small', frameon=True)
  ax.set(
      xlim=[0.0, 180.0], ylim=[-0.1, 0.1],
      xticks=[0, 30, 60, 90, 120, 150, 180],
      xlabel=r'$\theta$, degrees', ylabel=r'$\Delta \theta_1 / \theta_{1}$', 
      title=r'Analytic residuals: ' + params_string,
  )
#+END_SRC

#+RESULTS:
[[file:figs/fig-resid-analytic.svg]]

+ Everything is fine, except for low \beta, where we have large residuals for \theta > 160\deg
  + This is not surprising since that is the range that it was fit over
  + If we fit the range all the way up to \theta_\infty then the physical space fit looks bad for \theta around 90 \to 150, so it is best to keep things as they are
  + For anyone really interested in the far field, just knowing \theta_\infty should be good enough



** Test of quiver for showing anisotropic wind
#+BEGIN_SRC ipython :session ratio :file figs/fig-quiver.svg :exports both
  fig, ax = plt.subplots(1, 1, figsize=[4, 4])
  th = np.arange(12)*np.pi/6
  x = np.zeros_like(th)
  y = np.zeros_like(th)
  vel = np.cos(th)
  u = vel*np.cos(th)
  v = vel*np.sin(th)
  ax.quiver()
  ax.set(xlim=[-5, 2], ylim=[0, 7])
#+END_SRC
** Conclusion
:PROPERTIES:
:ID:       7629AD2E-734D-45AC-8860-24A434DA603F
:END:
The fits work pretty well, so long as we are careful about the theta range that we use. 

* Projected two-quadric shapes on diagnostic graph
+ This is placing the models calculated in [[id:CFCCAE1D-FB80-4BB8-B3D9-4D3B12D7531D][{1/1} Joining the head and tail conics]] on the types of graphs calculated in [[id:2D6B6135-5090-4504-A31C-E1B9D717FAF0][New graphs for section 4.1]]
+ The complication is that \(R_{90}{}'\) will come from the tail fit if \(\theta_{90} > 110^{\circ}\)
** Tc vs Rc for generalized CRW
#+BEGIN_SRC python :eval no :tangle two-quadric-Tc-vs-Rc.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('white')
  fig, ax = plt.subplots(figsize=(5, 5))
  fig2, ax2 = plt.subplots(figsize=(5, 5))

  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)


  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.1, 0.03, 0.01, 0.001, 0.0001, 0.00001]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  dashes_solid = []
  dashes_dashed = [3, 2]
  dashes_dotted = [1, 2]
  dashes_dot_dashed = [1, 2, 4, 2]
  dashes_triple_dot_dashed = [1, 2, 1, 2, 1, 2, 4, 2]
  dashes_styles = [dashes_solid, dashes_dashed, dashes_dotted,
                   dashes_dot_dashed, dashes_triple_dot_dashed,
                   dashes_solid, dashes_solid]

  cols = sns.color_palette('magma', n_colors=nxi)


  for beta, dashes in list(zip(BETA_LIST, dashes_styles))[::-1]:
      for xi, col in list(zip(XI_LIST, cols))[::-1]:

          # Fit to head and analytic fit to fit to tail
          ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')

          # Parameters for head conic
          T_h = ht.sig_h*ht.tau_h**2
          tilde_Rc_h = ht.A_h
          R0_h = 1.0
          R90_h = ht.R90

          # Parameters for tail conic
          T_t = -ht.tau_t**2
          R0_t = ht.x0_t - ht.a_t
          # Equation E from notes
          tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
          R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
          T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

          # Projected head quantities as functions of inc
          f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
          tilde_Rc_h_prime = tilde_Rc_h / (
              np.cos(inc)**2 * f_h * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
              )
          )
          T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
          R0_h_prime = R0_h * np.cos(inc) * (
              1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
          )
          R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)

          # Projected tail quantities as functions of inc
          f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
          # Equation B from notes
          T_t_prime = T_t / f_t**2 / np.cos(inc)**2
          # Equation D from notes
          R0_t_prime = R0_t * np.cos(inc) * (
              1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
          )
          # Equation C from notes
          tilde_Rc_t_prime = tilde_Rc_t / (
              np.cos(inc)**2 * f_t * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
              )
          )
          # Equation A from notes
          R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

          # Finally, the combined discriminant (equation F from notes)
          T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

          # if Rc == 1.0:
          #     label = fr'$\xi = {xi:.1f}$'
          # else:
          #     label = None
          xilabel = 'CRW' if xi is None else fr'$\xi = {xi:.1f}$'
          betalabel = fr'$\beta = {beta:.5f}$'
          label = f'{xilabel} {betalabel}'

          # Find minimum difference between head and tail values of R90
          dR = np.abs(R90_h_prime - R90_t_prime)
          mm = np.isfinite(dR)
          i0 = np.argmin(dR[mm])


          # Masks for high and low inclinations (overlapping range)
          mlo = inc_deg <= inc_deg[i0]
          mhi = inc_deg >= inc_deg[i0]
          # Ensure that LOS is not inside the tail cone
          mhi = mhi & (inc < 0.5*np.pi - ht.theta_t)
          # Plot the head discriminant for low inclinations
          ax.plot(tilde_Rc_h_prime[mlo], T_h_prime[mlo],
                  c=col, label=label, lw=2, alpha=0.4)
          # Put a dot at the i=0 case
          ax.plot([tilde_Rc_h], [T_h], 'o', c=col)
          # Plot the combined discriminant for high inclinations
          ax.plot(tilde_Rc_h_prime[mhi], T_combine_prime[mhi],
                  c=col, label=None, lw=0.8, alpha=1.0)
          #ax.plot([tilde_Rc_h], [T_combine], '.', c=col)

          ax2.plot(inc_deg, R90_h_prime/R0_h_prime,
                   c=col, dashes=dashes, label=label, lw=2, alpha=0.4)
          ax2.plot(inc_deg, R90_t_prime/R0_h_prime,
                   c=col, dashes=dashes, label=None, lw=0.8, alpha=1.0)
          ax2.plot([inc_deg[i0]], [R90_t_prime[i0]/R0_h_prime[i0]], 'o', c=col)


  #ax.legend(ncol=1, fontsize='xx-small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 4.1],
      ylim=[-8.0, 1.1],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected conic discriminant: $T_c{}'$",
  )        


  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

  ax2.legend(ncol=3, fontsize='xx-small', frameon=True)
  ax2.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 90.0],
      ylim=[0.0, 6.0],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Inclination angle, degrees",
      ylabel=r"Projected perpendicular radius: $R_{90}'$",
  )        

  fig2.tight_layout()
  fig2.savefig(plotfile.replace('Tc-vs-Rc', 'R90-vs-i'))
#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-Tc-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:two-quadric-Tc-vs-Rc.pdf]]

#+BEGIN_SRC sh :results silent
open two-quadric-R90-vs-i.pdf
#+END_SRC
** R90 vs Rc for generalized CRW
+ Same but doing R90 vs Rc
#+BEGIN_SRC python :eval no :tangle two-quadric-R90-vs-Rc.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  try: 
      xiset = sys.argv[1]
      plotfile = sys.argv[0].replace('.py', f'-{xiset}.pdf')
      assert xiset in 'ab'
      istart = -2 if xiset == 'a' else -1
  except:
      sys.exit(f"Usage: {sys.argv[0]} a|b")

  sns.set_style('white')
  fig, ax = plt.subplots(figsize=(5, 5))


  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)


  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.2, 0.1, 0.05, 0.02, 0.005, 1e-6]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  cols = sns.color_palette('magma', n_colors=nxi)
  annot_pars_list = [left_annotate_pars]*2 + [right_annotate_pars]*2 
  for beta in BETA_LIST[::-1]:
      for xi, col, annot_pars in list(zip(XI_LIST, cols, annot_pars_list))[istart::-2]:

          # Fit to head and analytic fit to fit to tail
          ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')

          # Parameters for head conic
          T_h = ht.sig_h*ht.tau_h**2
          tilde_Rc_h = ht.A_h
          R0_h = 1.0
          R90_h = ht.R90

          # Parameters for tail conic
          T_t = -ht.tau_t**2
          R0_t = ht.x0_t - ht.a_t
          # Equation E from notes
          tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
          R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
          T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

          # Projected head quantities as functions of inc
          f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
          tilde_Rc_h_prime = tilde_Rc_h / (
              np.cos(inc)**2 * f_h * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
              )
          )
          T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
          R0_h_prime = R0_h * np.cos(inc) * (
              1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
          )
          R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)

          # Projected tail quantities as functions of inc
          f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
          # Equation B from notes
          T_t_prime = T_t / f_t**2 / np.cos(inc)**2
          # Equation D from notes
          R0_t_prime = R0_t * np.cos(inc) * (
              1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
          )
          # Equation C from notes
          tilde_Rc_t_prime = tilde_Rc_t / (
              np.cos(inc)**2 * f_t * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
              )
          )
          # Equation A from notes
          R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

          # Finally, the combined discriminant (equation F from notes)
          T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

          # if Rc == 1.0:
          #     label = fr'$\xi = {xi:.1f}$'
          # else:
          #     label = None
          if beta == BETA_LIST[0]:
              label = 'CRW' if xi is None else fr'$\xi = {xi:.1f}$'
          else:
              label = None

          # Find minimum difference between head and tail values of R90
          dR = np.abs(R90_h_prime - R90_t_prime)
          mm = np.isfinite(dR)
          i0 = np.argmin(dR[mm])
          i30 = np.argmin(np.abs(inc_deg - 30.0))


          # Masks for high and low inclinations (overlapping range)
          overlap_deg = 0.0
          mlo = inc_deg <= inc_deg[i0] + overlap_deg
          mhi = inc_deg >= inc_deg[i0] - overlap_deg
          # mlo = inc_deg <= 40.0
          # mhi = inc_deg >= 30.0

          # Ensure that LOS is not inside the tail cone
          mhi = mhi & (inc < 0.5*np.pi - ht.theta_t)
          # Plot the head discriminant for low inclinations
          ax.plot(tilde_Rc_h_prime[mlo], R90_h_prime[mlo]/R0_h_prime[mlo],
                  c=col, label=None, lw=1.6, alpha=0.7)
          # Put a dot at the i=0 case
          ax.plot([tilde_Rc_h], [R90_h/R0_h], '.', c=col, alpha=1.0)
          # Plot the combined discriminant for high inclinations
          ax.plot(tilde_Rc_h_prime[mhi], R90_t_prime[mhi]/R0_h_prime[mhi],
                  c=col, label=label, lw=0.8, alpha=1.0)
          # Label the dot with the cross-over inclination
          ax.annotate(rf'$\beta = \mathrm{{{beta:g}}}$, $i^*\!\!\! = {inc_deg[i0]:.0f}^\circ$',
                      xy=(tilde_Rc_h, R90_h/R0_h),
                      textcoords='offset points',
                      fontsize='x-small', color=col, **annot_pars)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)

  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        

  sns.despine()
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-R90-vs-Rc.py a
#+END_SRC

#+RESULTS:
[[file:two-quadric-R90-vs-Rc-a.pdf]]

#+BEGIN_SRC sh :results file
python two-quadric-R90-vs-Rc.py b
#+END_SRC

#+RESULTS:
[[file:two-quadric-R90-vs-Rc-b.pdf]]

** DONE th90 versus inclination for generalized CRW
CLOSED: [2017-02-22 Wed 11:35]
#+BEGIN_SRC python :eval no :tangle two-quadric-th90-vs-i.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('white')
  fig, (axx, ax) = plt.subplots(2, 1, sharex=True, figsize=(5, 5))



  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)


  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.2, 0.1, 0.05, 0.02, 0.005, 1e-6]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  dashes_solid = []
  dashes_dashed = [3, 2]
  dashes_dotted = [1, 2]
  dashes_dot_dashed = [1, 2, 4, 2]
  dashes_triple_dot_dashed = [1, 2, 1, 2, 1, 2, 4, 2]
  dashes_triple_dot_spaced = [1, 2, 1, 2, 1, 6]
  dashes_styles = [dashes_solid, dashes_dashed, dashes_dotted,
                   dashes_dot_dashed, dashes_triple_dot_dashed,
                   dashes_triple_dot_spaced]

  cols = sns.color_palette('magma', n_colors=nxi)

  ax.axhspan(100.0, 110.0, facecolor='k', alpha=0.1)

  for beta, dashes in list(zip(BETA_LIST, dashes_styles))[::-1]:
      for xi, col in list(zip(XI_LIST, cols))[-4::-1]:

          # Fit to head and analytic fit to fit to tail
          ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')

          # Parameters for head conic
          T_h = ht.sig_h*ht.tau_h**2
          tilde_Rc_h = ht.A_h
          R0_h = 1.0
          R90_h = ht.R90

          # Parameters for tail conic
          T_t = -ht.tau_t**2
          R0_t = ht.x0_t - ht.a_t
          # Equation E from notes
          tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
          R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
          T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

          # Projected head quantities as functions of inc
          f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
          tilde_Rc_h_prime = tilde_Rc_h / (
              np.cos(inc)**2 * f_h * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
              )
          )
          T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
          R0_h_prime = R0_h * np.cos(inc) * (
              1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
          )
          R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)

          t2i = np.tan(inc)**2
          tan_th90 = -np.sqrt(t2i*(2.0 + T_h*t2i) + (2.0 - T_h/tilde_Rc_h)/tilde_Rc_h)/t2i
          th90_h = 180.0 + np.degrees(np.arctan(tan_th90))


          # Projected tail quantities as functions of inc
          f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
          # Equation B from notes
          T_t_prime = T_t / f_t**2 / np.cos(inc)**2
          # Equation D from notes
          R0_t_prime = R0_t * np.cos(inc) * (
              1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
          )
          # Equation C from notes
          tilde_Rc_t_prime = tilde_Rc_t / (
              np.cos(inc)**2 * f_t * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
              )
          )
          # Equation A from notes
          R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

          # Finally, the combined discriminant (equation F from notes)
          T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

          tan_th90 = -np.sqrt(t2i*(2.0 + T_t*t2i) + (2.0 - T_t/tilde_Rc_t)/tilde_Rc_t)/t2i
          th90_t = 180.0 + np.degrees(np.arctan(tan_th90))

          # if Rc == 1.0:
          #     label = fr'$\xi = {xi:.1f}$'
          # else:
          #     label = None
          if beta == BETA_LIST[0]:
              xilabel = 'CRW' if xi is None else fr'$\xi = {xi:.1f}$'
          else:
              label = None

          # Find minimum difference between head and tail values of R90
          dR = np.abs(R90_h_prime - R90_t_prime)
          mm = np.isfinite(dR)
          i0 = np.argmin(dR[mm])


          # Masks for high and low inclinations (overlapping range)
          mlo = inc_deg <= inc_deg[i0]
          mhi = inc_deg >= inc_deg[i0]
          # Ensure that LOS is not inside the tail cone
          mhi = mhi & (inc < 0.5*np.pi - ht.theta_t)


          ax.plot(inc_deg[mlo], th90_h[mlo],
                  c=col, label=None, lw=1.5, dashes=dashes, alpha=0.8)
          ax.plot(inc_deg[mhi], th90_t[mhi],
                  c=col, label=label, lw=0.7, dashes=dashes, alpha=0.8)

          axx.plot(inc_deg[mlo], R90_h_prime[mlo],
                   c=col, label=None, lw=1.5, dashes=dashes, alpha=0.8)
          axx.plot(inc_deg[mhi], R90_t_prime[mhi],
                   c=col, label=label, lw=0.7, dashes=dashes, alpha=0.8)
          axx.plot([inc_deg[i0]], [R90_t_prime[i0]], '.', c=col, label=None) 

  ax.legend(ncol=1, fontsize='xx-small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 90.0],
      ylim=[80.0, 180.0],
  #    ylim=[-3.0, 1.1],
      xlabel=r'Inclination, degrees',
      ylabel=r"Body-frame polar angle of perpendicular projected axis: $\theta_{90}$, degrees",
      xticks=[15, 30, 45, 60, 75, 90],
  )        
  axx.set(
      yscale='log',
      xscale='linear',
      ylim=[1.0, 100.0],
      ylabel=r"Projected perpendicular radius, $R'_{90}$",
  )        

  sns.despine()
  #fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-th90-vs-i.py
#+END_SRC

#+RESULTS:
[[file:two-quadric-th90-vs-i.pdf]]

+ Plotting the tail version gives nonsense, not sure why
+ But the head value behaves nicely - goes past 100--110 degrees by i = 30--40
+ There is a slight dependence on parameters
  + i = 30 will work for most cases
  + But i = 40 is better for low beta
  + So we will try both

** DONE Snapshots of R90-Rc plane for projected generalized CRW at different inclinations
CLOSED: [2017-02-22 Wed 18:58]

+ To get this to work, we need a better way of deciding whether to use the head or the tail fit
+ [X] So we need to sort out the theta_90 calculation first
  + Done above - suggests cross-over at i = 30-40
+ Plan is to show the head in solid dots and tail in hollow dots
+ [2017-03-31 Fri] Tweak graph
  + As we did [[id:FA0B6F2B-DC73-4350-893D-A6710B41424E][here]] for the quadric case, we are going to use symbol size to illustrate R_0'/R_0
  + [X] Run modified program and copy over fig file

#+BEGIN_SRC python :eval no :tangle two-quadric-R90-Rc-snapshots.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('white')
  fig, axes = plt.subplots(3, 3, figsize=(9, 9), sharex=True, sharey=True)

  incs_deg = 10.0*np.arange(9)

  nbeta = 30
  #betas = np.logspace(-5.0, -0.5, nbeta)
  betas = np.linspace(0.003, 0.5, nbeta)**2
  XI_LIST = [None, 1.0, 0.8, 0.4]
  nxi = len(XI_LIST)

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 


  cols = sns.color_palette('magma', n_colors=nxi)
  for ax, inc_deg in zip(axes.flat, incs_deg):
      ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
      ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
      ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
      ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
      ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
      ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)
      for xi, col in list(zip(XI_LIST, cols)):
          for beta in betas:
              # Fit to head and analytic fit to fit to tail
              ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')
              # Parameters for head conic
              T_h = ht.sig_h*ht.tau_h**2
              tilde_Rc_h = ht.A_h
              R0_h = 1.0
              R90_h = ht.R90

              # Parameters for tail conic
              T_t = -ht.tau_t**2
              R0_t = ht.x0_t - ht.a_t
              # Equation E from notes
              tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
              R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
              T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

              inc = np.radians(inc_deg)

              # Projected head quantities as functions of inc
              f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
              tilde_Rc_h_prime = tilde_Rc_h / (
                  np.cos(inc)**2 * f_h * (
                      1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
                  )
              )
              T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
              R0_h_prime = R0_h * np.cos(inc) * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
              )
              R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)


              # Projected tail quantities as functions of inc
              f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
              # Equation B from notes
              T_t_prime = T_t / f_t**2 / np.cos(inc)**2
              # Equation D from notes
              R0_t_prime = R0_t * np.cos(inc) * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
              )
              # Equation C from notes
              tilde_Rc_t_prime = tilde_Rc_t / (
                  np.cos(inc)**2 * f_t * (
                      1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
                  )
              )
              # Equation A from notes
              R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

              # Finally, the combined discriminant (equation F from notes)
              T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

              if inc_deg < 30.0:
                  # Plot the head for low inclinations
                  y = R90_h_prime/R0_h_prime
              else:
                  # Plot the tail for high inclinations
                  y = R90_t_prime/R0_h_prime
              ax.scatter([tilde_Rc_h_prime], [y],
			 c=col, edgecolors='none',
			 marker='o', s=25*R0_h_prime/R0_h, alpha=0.4)

              ax.text(3.0, 0.5, rf'$i = {inc_deg:.0f}^\circ$',
                      bbox={'facecolor': 'w', 'alpha': 0.8, 'edgecolor': 'none'})


  axes[-1, 0].set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
      xlabel=r"$\widetilde{R}_{c}{}'$",
      ylabel=r"$\widetilde{R}_{90}{}'$",
  )        
  

  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-R90-Rc-snapshots.py
#+END_SRC

#+RESULTS:
[[file:two-quadric-R90-Rc-snapshots.pdf]]


* Copying figs to paper dir
#+BEGIN_SRC sh :results verbatim
date
cp -av two-quadric-*.pdf ../papers/Paper1/figs
#+END_SRC

#+RESULTS:
: Thu Sep 28 10:59:17 CDT 2017
: two-quadric-R90-Rc-snapshots.pdf -> ../papers/Paper1/figs/two-quadric-R90-Rc-snapshots.pdf
: two-quadric-R90-vs-Rc-a.pdf -> ../papers/Paper1/figs/two-quadric-R90-vs-Rc-a.pdf
: two-quadric-R90-vs-Rc-b.pdf -> ../papers/Paper1/figs/two-quadric-R90-vs-Rc-b.pdf
: two-quadric-R90-vs-Rc.pdf -> ../papers/Paper1/figs/two-quadric-R90-vs-Rc.pdf
: two-quadric-R90-vs-i.pdf -> ../papers/Paper1/figs/two-quadric-R90-vs-i.pdf
: two-quadric-Tc-vs-Rc.pdf -> ../papers/Paper1/figs/two-quadric-Tc-vs-Rc.pdf
: two-quadric-th90-vs-i.pdf -> ../papers/Paper1/figs/two-quadric-th90-vs-i.pdf

* Projected two-quadric shapes on diagnostic graph
+ This is placing the models calculated in [[id:CFCCAE1D-FB80-4BB8-B3D9-4D3B12D7531D][{1/1} Joining the head and tail conics]] on the types of graphs calculated in [[id:2D6B6135-5090-4504-A31C-E1B9D717FAF0][New graphs for section 4.1]]
+ The complication is that \(R_{90}{}'\) will come from the tail fit if \(\theta_{90} > 110^{\circ}\)
** Tc vs Rc for generalized CRW
#+BEGIN_SRC python :eval no :tangle two-quadric-Tc-vs-Rc.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('white')
  fig, ax = plt.subplots(figsize=(5, 5))
  fig2, ax2 = plt.subplots(figsize=(5, 5))

  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)


  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.1, 0.03, 0.01, 0.001, 0.0001, 0.00001]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  dashes_solid = []
  dashes_dashed = [3, 2]
  dashes_dotted = [1, 2]
  dashes_dot_dashed = [1, 2, 4, 2]
  dashes_triple_dot_dashed = [1, 2, 1, 2, 1, 2, 4, 2]
  dashes_styles = [dashes_solid, dashes_dashed, dashes_dotted,
                   dashes_dot_dashed, dashes_triple_dot_dashed,
                   dashes_solid, dashes_solid]

  cols = sns.color_palette('magma', n_colors=nxi)


  for beta, dashes in list(zip(BETA_LIST, dashes_styles))[::-1]:
      for xi, col in list(zip(XI_LIST, cols))[::-1]:

          # Fit to head and analytic fit to fit to tail
          ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')

          # Parameters for head conic
          T_h = ht.sig_h*ht.tau_h**2
          tilde_Rc_h = ht.A_h
          R0_h = 1.0
          R90_h = ht.R90

          # Parameters for tail conic
          T_t = -ht.tau_t**2
          R0_t = ht.x0_t - ht.a_t
          # Equation E from notes
          tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
          R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
          T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

          # Projected head quantities as functions of inc
          f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
          tilde_Rc_h_prime = tilde_Rc_h / (
              np.cos(inc)**2 * f_h * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
              )
          )
          T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
          R0_h_prime = R0_h * np.cos(inc) * (
              1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
          )
          R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)

          # Projected tail quantities as functions of inc
          f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
          # Equation B from notes
          T_t_prime = T_t / f_t**2 / np.cos(inc)**2
          # Equation D from notes
          R0_t_prime = R0_t * np.cos(inc) * (
              1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
          )
          # Equation C from notes
          tilde_Rc_t_prime = tilde_Rc_t / (
              np.cos(inc)**2 * f_t * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
              )
          )
          # Equation A from notes
          R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

          # Finally, the combined discriminant (equation F from notes)
          T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

          # if Rc == 1.0:
          #     label = fr'$\xi = {xi:.1f}$'
          # else:
          #     label = None
          xilabel = 'CRW' if xi is None else fr'$\xi = {xi:.1f}$'
          betalabel = fr'$\beta = {beta:.5f}$'
          label = f'{xilabel} {betalabel}'

          # Find minimum difference between head and tail values of R90
          dR = np.abs(R90_h_prime - R90_t_prime)
          mm = np.isfinite(dR)
          i0 = np.argmin(dR[mm])


          # Masks for high and low inclinations (overlapping range)
          mlo = inc_deg <= inc_deg[i0]
          mhi = inc_deg >= inc_deg[i0]
          # Ensure that LOS is not inside the tail cone
          mhi = mhi & (inc < 0.5*np.pi - ht.theta_t)
          # Plot the head discriminant for low inclinations
          ax.plot(tilde_Rc_h_prime[mlo], T_h_prime[mlo],
                  c=col, label=label, lw=2, alpha=0.4)
          # Put a dot at the i=0 case
          ax.plot([tilde_Rc_h], [T_h], 'o', c=col)
          # Plot the combined discriminant for high inclinations
          ax.plot(tilde_Rc_h_prime[mhi], T_combine_prime[mhi],
                  c=col, label=None, lw=0.8, alpha=1.0)
          #ax.plot([tilde_Rc_h], [T_combine], '.', c=col)

          ax2.plot(inc_deg, R90_h_prime/R0_h_prime,
                   c=col, dashes=dashes, label=label, lw=2, alpha=0.4)
          ax2.plot(inc_deg, R90_t_prime/R0_h_prime,
                   c=col, dashes=dashes, label=None, lw=0.8, alpha=1.0)
          ax2.plot([inc_deg[i0]], [R90_t_prime[i0]/R0_h_prime[i0]], 'o', c=col)


  #ax.legend(ncol=1, fontsize='xx-small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 4.1],
      ylim=[-8.0, 1.1],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected conic discriminant: $T_c{}'$",
  )        


  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

  ax2.legend(ncol=3, fontsize='xx-small', frameon=True)
  ax2.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 90.0],
      ylim=[0.0, 6.0],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Inclination angle, degrees",
      ylabel=r"Projected perpendicular radius: $R_{90}'$",
  )        

  fig2.tight_layout()
  fig2.savefig(plotfile.replace('Tc-vs-Rc', 'R90-vs-i'))
#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-Tc-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:two-quadric-Tc-vs-Rc.pdf]]

#+BEGIN_SRC sh :results silent
open two-quadric-R90-vs-i.pdf
#+END_SRC
** R90 vs Rc for generalized CRW
+ Same but doing R90 vs Rc
#+BEGIN_SRC python :eval no :tangle two-quadric-R90-vs-Rc.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('white')
  fig, ax = plt.subplots(figsize=(5, 5))



  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 
  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, alpha=0.2)
  ax.plot([0.0, 10.0], [0.0, 10.0], ':', c='k')

  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)


  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.2, 0.1, 0.05, 0.02, 0.01, 0.001, 0.0001, 0.00001]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  cols = sns.color_palette('magma', n_colors=nxi)
  for beta in BETA_LIST[::-1]:
      for xi, col in list(zip(XI_LIST, cols))[::-1]:

          # Fit to head and analytic fit to fit to tail
          ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')

          # Parameters for head conic
          T_h = ht.sig_h*ht.tau_h**2
          tilde_Rc_h = ht.A_h
          R0_h = 1.0
          R90_h = ht.R90

          # Parameters for tail conic
          T_t = -ht.tau_t**2
          R0_t = ht.x0_t - ht.a_t
          # Equation E from notes
          tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
          R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
          T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

          # Projected head quantities as functions of inc
          f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
          tilde_Rc_h_prime = tilde_Rc_h / (
              np.cos(inc)**2 * f_h * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
              )
          )
          T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
          R0_h_prime = R0_h * np.cos(inc) * (
              1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
          )
          R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)

          # Projected tail quantities as functions of inc
          f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
          # Equation B from notes
          T_t_prime = T_t / f_t**2 / np.cos(inc)**2
          # Equation D from notes
          R0_t_prime = R0_t * np.cos(inc) * (
              1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
          )
          # Equation C from notes
          tilde_Rc_t_prime = tilde_Rc_t / (
              np.cos(inc)**2 * f_t * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
              )
          )
          # Equation A from notes
          R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

          # Finally, the combined discriminant (equation F from notes)
          T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

          # if Rc == 1.0:
          #     label = fr'$\xi = {xi:.1f}$'
          # else:
          #     label = None
          if beta == BETA_LIST[0]:
              label = 'CRW' if xi is None else fr'$\xi = {xi:.1f}$'
          else:
              label = None

          # Find minimum difference between head and tail values of R90
          dR = np.abs(R90_h_prime - R90_t_prime)
          mm = np.isfinite(dR)
          i0 = np.argmin(dR[mm])


          # Masks for high and low inclinations (overlapping range)
          mlo = inc_deg <= inc_deg[i0]
          mhi = inc_deg >= inc_deg[i0]
          # Ensure that LOS is not inside the tail cone
          mhi = mhi & (inc < 0.5*np.pi - ht.theta_t)
          # Plot the head discriminant for low inclinations
          ax.plot(tilde_Rc_h_prime[mlo], R90_h_prime[mlo]/R0_h_prime[mlo],
                  c=col, label=None, lw=2, alpha=0.4)
          # Put a dot at the i=0 case
          ax.plot([tilde_Rc_h], [R90_h/R0_h], 'o', c=col, alpha=0.6)
          # Plot the combined discriminant for high inclinations
          ax.plot(tilde_Rc_h_prime[mhi], R90_t_prime[mhi]/R0_h_prime[mhi],
                  c=col, label=label, lw=0.8, alpha=1.0)
          #ax.plot([tilde_Rc_h], [T_combine], '.', c=col)

  ax.legend(ncol=1, fontsize='xx-small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        


  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-R90-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:two-quadric-R90-vs-Rc.pdf]]
** DONE th90 versus inclination for generalized CRW
CLOSED: [2017-02-22 Wed 11:35]
#+BEGIN_SRC python :eval no :tangle two-quadric-th90-vs-i.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('white')
  fig, ax = plt.subplots(figsize=(5, 5))



  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)


  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.2, 0.1, 0.05, 0.02, 0.01, 0.001, 0.0001, 0.00001]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  dashes_solid = []
  dashes_dashed = [3, 2]
  dashes_dotted = [1, 2]
  dashes_dot_dashed = [1, 2, 4, 2]
  dashes_triple_dot_dashed = [1, 2, 1, 2, 1, 2, 4, 2]
  dashes_styles = [dashes_solid, dashes_dashed, dashes_dotted,
                   dashes_dot_dashed, dashes_triple_dot_dashed,
                   dashes_solid, dashes_solid]

  cols = sns.color_palette('magma', n_colors=nxi)


  for beta, dashes in list(zip(BETA_LIST, dashes_styles))[::-1]:
      for xi, col in list(zip(XI_LIST, cols))[::-1]:

          # Fit to head and analytic fit to fit to tail
          ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')

          # Parameters for head conic
          T_h = ht.sig_h*ht.tau_h**2
          tilde_Rc_h = ht.A_h
          R0_h = 1.0
          R90_h = ht.R90

          # Parameters for tail conic
          T_t = -ht.tau_t**2
          R0_t = ht.x0_t - ht.a_t
          # Equation E from notes
          tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
          R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
          T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

          # Projected head quantities as functions of inc
          f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
          tilde_Rc_h_prime = tilde_Rc_h / (
              np.cos(inc)**2 * f_h * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
              )
          )
          T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
          R0_h_prime = R0_h * np.cos(inc) * (
              1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
          )
          R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)

          t2i = np.tan(inc)**2
          tan_th90 = -np.sqrt(t2i*(2.0 + T_h*t2i) + (2.0 - T_h/tilde_Rc_h)/tilde_Rc_h)/t2i
          th90_h = 180.0 + np.degrees(np.arctan(tan_th90))


          # Projected tail quantities as functions of inc
          f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
          # Equation B from notes
          T_t_prime = T_t / f_t**2 / np.cos(inc)**2
          # Equation D from notes
          R0_t_prime = R0_t * np.cos(inc) * (
              1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
          )
          # Equation C from notes
          tilde_Rc_t_prime = tilde_Rc_t / (
              np.cos(inc)**2 * f_t * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
              )
          )
          # Equation A from notes
          R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

          # Finally, the combined discriminant (equation F from notes)
          T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

          tan_th90 = -np.sqrt(t2i*(2.0 + T_t*t2i) + (2.0 - T_t/tilde_Rc_t)/tilde_Rc_t)/t2i
          th90_t = 180.0 + np.degrees(np.arctan(tan_th90))

          # if Rc == 1.0:
          #     label = fr'$\xi = {xi:.1f}$'
          # else:
          #     label = None
          if beta == BETA_LIST[0]:
              label = 'CRW' if xi is None else fr'$\xi = {xi:.1f}$'
          else:
              label = None

          # Find minimum difference between head and tail values of R90
          dR = np.abs(R90_h_prime - R90_t_prime)
          mm = np.isfinite(dR)
          i0 = np.argmin(dR[mm])


          # Masks for high and low inclinations (overlapping range)
          mlo = inc_deg <= inc_deg[i0]
          mhi = inc_deg >= inc_deg[i0]
          # Ensure that LOS is not inside the tail cone
          mhi = mhi & (inc < 0.5*np.pi - ht.theta_t)


          ax.plot(inc_deg, th90_h, c=col, label=label, lw=2, dashes=dashes, alpha=0.4)
          # ax.plot(inc_deg, th90_t, c=col, label=label, lw=0.5, dashes=dashes, alpha=0.8)

  ax.legend(ncol=1, fontsize='xx-small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 90.0],
      ylim=[80.0, 160.0],
  #    ylim=[-3.0, 1.1],
      xlabel=r'Inclination, degrees',
      ylabel=r"Body-frame polar angle of perpendicular projected axis: $\theta_{90}$, degrees",
      xticks=[15, 30, 45, 60, 75, 90],
  )        


  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-th90-vs-i.py
#+END_SRC

#+RESULTS:
[[file:two-quadric-th90-vs-i.pdf]]

+ Plotting the tail version gives nonsense, not sure why
+ But the head value behaves nicely - goes past 100--110 degrees by i = 30--40
+ There is a slight dependence on parameters
  + i = 30 will work for most cases
  + But i = 40 is better for low beta
  + So we will try both

** TODO Snapshots of R90-Rc plane for projected generalized CRW at different inclinations

+ To get this to work, we need a better way of deciding whether to use the head or the tail fit
+ [X] So we need to sort out the theta_90 calculation first
  + Done above - suggests cross-over at i = 30-40 

#+BEGIN_SRC python :eval no :tangle two-quadric-R90-Rc-snapshots.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import conic_parameters

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('white')
  fig, axes = plt.subplots(3, 3, figsize=(9, 9), sharex=True, sharey=True)

  incs_deg = 10.0*np.arange(9)

  nbeta = 30
  betas = np.logspace(-5.0, -0.5, nbeta)
  XI_LIST = [None, 1.0, 0.8, 0.4]
  nxi = len(XI_LIST)

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 
  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, alpha=0.2)
  ax.plot([0.0, 10.0], [0.0, 10.0], ':', c='k')


  cols = sns.color_palette('magma', n_colors=nxi)
  for ax, inc_deg in zip(axes.flat, incs_deg):
      for xi, col in list(zip(XI_LIST, cols))[::-1]:
          for beta in betas:
              # Fit to head and analytic fit to fit to tail
              ht = conic_parameters.HeadTail(beta, xi=xi, xmin=0.0, method='analytic fit')
              # Parameters for head conic
              T_h = ht.sig_h*ht.tau_h**2
              tilde_Rc_h = ht.A_h
              R0_h = 1.0
              R90_h = ht.R90

              # Parameters for tail conic
              T_t = -ht.tau_t**2
              R0_t = ht.x0_t - ht.a_t
              # Equation E from notes
              tilde_Rc_t = np.abs(T_t)*ht.a_t/R0_t
              R90_t = R0_t * np.sqrt(2*tilde_Rc_t - T_t)
              T_combine = 2*tilde_Rc_h - (R90_t / R0_h)**2

              # Projected head quantities as functions of inc
              f_h = np.sqrt(1.0 + T_h * np.tan(inc)**2)
              tilde_Rc_h_prime = tilde_Rc_h / (
                  np.cos(inc)**2 * f_h * (
                      1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0) 
                  )
              )
              T_h_prime = T_h / (np.cos(inc)**2 * f_h**2)
              R0_h_prime = R0_h * np.cos(inc) * (
                  1.0 + (tilde_Rc_h / T_h) * (f_h - 1.0)
              )
              R90_h_prime = R0_h_prime * np.sqrt(2*tilde_Rc_h_prime - T_h_prime)

              inc = np.radians(inc_deg)

              # Projected tail quantities as functions of inc
              f_t = np.sqrt(1.0 + T_t * np.tan(inc)**2)
              # Equation B from notes
              T_t_prime = T_t / f_t**2 / np.cos(inc)**2
              # Equation D from notes
              R0_t_prime = R0_t * np.cos(inc) * (
                  1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0)
              )
              # Equation C from notes
              tilde_Rc_t_prime = tilde_Rc_t / (
                  np.cos(inc)**2 * f_t * (
                      1.0 + (tilde_Rc_t / T_t) * (f_t - 1.0) 
                  )
              )
              # Equation A from notes
              R90_t_prime = R0_t_prime * np.sqrt(2*tilde_Rc_t_prime - T_t_prime)

              # Finally, the combined discriminant (equation F from notes)
              T_combine_prime = 2*tilde_Rc_h_prime - (R90_t_prime / R0_h_prime)**2

              # if Rc == 1.0:
              #     label = fr'$\xi = {xi:.1f}$'
              # else:
              #     label = None
              if beta == BETA_LIST[0]:
                  label = 'CRW' if xi is None else fr'$\xi = {xi:.1f}$'
              else:
                  label = None

              # Find minimum difference between head and tail values of R90
              dR = np.abs(R90_h_prime - R90_t_prime)
              mm = np.isfinite(dR)
              i0 = np.argmin(dR[mm])


              # Masks for high and low inclinations (overlapping range)
              mlo = inc_deg <= inc_deg[i0]
              mhi = inc_deg >= inc_deg[i0]
              # Ensure that LOS is not inside the tail cone
              mhi = mhi & (inc < 0.5*np.pi - ht.theta_t)
              # Plot the head discriminant for low inclinations
              ax.plot(tilde_Rc_h_prime[mlo], R90_h_prime[mlo]/R0_h_prime[mlo],
                      c=col, label=None, lw=2, alpha=0.4)
              # Put a dot at the i=0 case
              ax.plot([tilde_Rc_h], [R90_h/R0_h], 'o', c=col, alpha=0.6)
              # Plot the combined discriminant for high inclinations
              ax.plot(tilde_Rc_h_prime[mhi], R90_t_prime[mhi]/R0_h_prime[mhi],
                      c=col, label=label, lw=0.8, alpha=1.0)
              #ax.plot([tilde_Rc_h], [T_combine], '.', c=col)

  ax.legend(ncol=1, fontsize='xx-small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        


  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python two-quadric-R90-Rc-snapshots.py
#+END_SRC

#+RESULTS:


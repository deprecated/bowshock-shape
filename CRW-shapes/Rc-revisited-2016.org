* Revisiting the radius of curvature for the generalized CRW models
+ [2016-06-11 Sat] We find that the anisotropic models have smaller R_c than our analytic formula
  + The first calculations of this are in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/papers/Paper1/oblate_analysis.ipynb]]
  + We calculated radius of curvature directly from finite differences
  + Another approach would be to fit the first few terms of a Taylor expansion:
    + \(R(\theta) = R_{0} \left( 1 + \alpha \theta^{2} + \mathcal{O}(\theta^{4}) \right)\)
  + Then the radius of curvature is
    + \(A \equiv R_{c}/R_{0} = (1 - 2\alpha)^{-1}\)
** Find R_c from fitting Taylor series

+ We could fit a polynomial in \(\theta^2\) to \(R(\theta)/R_{0}\) 
  + Where \(\alpha\) is given by the linear (in \(\theta^2\)) term
  + This is allowing the constant term to be different from 1
+ Or, we can put \(\hat\alpha(\theta) = ((R(\theta)/R_{0}) - 1)/\theta^{2}\) and then fit a polynomial in \(\theta^{2}\) to \(\hat\alpha(\theta)\)
  + Then \(\alpha\) is given by the constant term in the fit
  + This has the advantage of pinning radius to \(R_{0}\) on the axis
*** Test out the mechanism for fixed \beta, \xi

+ This seems to work perfectly
  + So long as we don't try and go to too large a value of theta in the fit

#+BEGIN_SRC python :return table
import numpy as np
import equation6

beta = 1.0
xi = 0.1
dtheta = 0.01
N = 10
NP = 2
theta = dtheta*np.arange(N)
thsq = theta**2
shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
R = shell.radius(theta)
R0 = np.sqrt(beta)/(1 + np.sqrt(beta))

ahat = (R/R0 - 1) / thsq
m = np.isfinite(ahat)
c = np.polyfit(thsq[2:], ahat[2:], NP)
p = np.poly1d(c)
residfrac = (p(thsq) - ahat)/ahat

table = [ ['theta', 'R/R0', '(R/R0 - 1) / theta^2', 'Fit', 'Resid frac'], None]


for row in zip(theta, R/R0, ahat, p(thsq), residfrac):
    table.append(['{:.10f}'.format(x) for x in row])

table.append(None)
table.append(['{:.10f}'.format(x) for x in reversed(c)])


#+END_SRC

#+RESULTS:
|         theta |          R/R0 | (R/R0 - 1) / theta^2 |           Fit |    Resid frac |
|---------------+---------------+----------------------+---------------+---------------|
|  0.0000000000 |  1.0000000000 |                  nan | -0.1750000221 |           nan |
|  0.0100000000 |  0.9999824995 |        -0.1750050347 | -0.1750050546 |  0.0000001139 |
|  0.0200000000 |  0.9999299920 |        -0.1750200711 | -0.1750200816 |  0.0000000600 |
|  0.0300000000 |  0.9998424596 |        -0.1750448911 | -0.1750448912 |  0.0000000008 |
|  0.0400000000 |  0.9997198734 |        -0.1750791388 | -0.1750791306 | -0.0000000467 |
|  0.0500000000 |  0.9995621942 |        -0.1751223158 | -0.1751223057 | -0.0000000577 |
|  0.0600000000 |  0.9993693744 |        -0.1751737852 | -0.1751737812 | -0.0000000227 |
|  0.0700000000 |  0.9991413594 |        -0.1752327734 | -0.1752327807 |  0.0000000419 |
|  0.0800000000 |  0.9988780904 |        -0.1752983736 | -0.1752983867 |  0.0000000748 |
|  0.0900000000 |  0.9985795067 |        -0.1753695491 | -0.1753695403 | -0.0000000503 |
|---------------+---------------+----------------------+---------------+---------------|
| -0.1750000221 | -0.0503839209 |         0.5881965600 |               |               |


For very small \beta it seems to be better to not use the first two points in the fit 
*** Find \alpha on a grid of \beta, \xi


#+BEGIN_SRC python :eval no :tangle alpha-vs-beta-xi.py
  import numpy as np
  import equation6
  from astropy.table import Table, Column

  def find_alpha(beta, xi, dtheta=0.01, ntheta=10, npoly=2):
      """Find the coefficient of theta**2 in the Taylor expansion of R(theta)"""
      theta = dtheta*np.arange(ntheta)
      thsq = theta**2
      shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
      R = shell.radius(theta)
      R0 = np.sqrt(beta)/(1 + np.sqrt(beta))
      ahat = (R/R0 - 1) / thsq
      c = np.polyfit(thsq[2:], ahat[2:], npoly)
      return c[-1]



  if __name__ == '__main__':

      xi_range = np.linspace(0.1, 1.0, 10)
      beta_range = np.linspace(0.001, 1.0, 300)

      tab = Table()
      tab.add_column(Column(name='beta', data=beta_range, format='{:.6f}'))
      for xi in xi_range:
          # print(xi)
          tab.add_column(Column(name='xi = {:.1f}'.format(xi),
                                data=[find_alpha(beta, xi) for beta in beta_range],
                                format='{:.6f}'))

      tabfilename = 'alpha-vs-beta-xi.tab'
      tab.write(tabfilename, format='ascii.tab')
      print(tabfilename)
#+END_SRC

#+BEGIN_SRC sh :results file
python alpha-vs-beta-xi.py
#+END_SRC

#+RESULTS:
[[file:alpha-vs-beta-xi.tab]]
*** New analytic solution for \alpha
+ According to my new attempt at the small angle expansion we have
  + \[\alpha = \frac{c}{1 + \beta^{1/2}} + \frac16 (1 + 2\beta^{1/2})\]
  + \[c = \frac{1}{30} \left(1 - \beta - \frac94 k\right)\]
+ This is now fully verified against the numerical solution

#+BEGIN_SRC python :eval no :tangle alpha_analytic.py
  import numpy as np

  def alpha_from_c_beta(c, beta):
      sb = np.sqrt(beta)
      return c/(1.0 + sb) + (1.0 + 2.0*sb)/6.0


  def c_from_beta_k(beta, k):
      return (1.0 - beta - 9.0*k/4.0)/30.0


  def k_from_xi(xi):
      return 2.0/xi - 2.0


  def alpha_from_beta_xi(beta, xi):
      return alpha_from_c_beta(c_from_beta_k(beta, k_from_xi(xi)), beta)

#+END_SRC
*** Plot \alpha as function of \beta for each \xi
+ This comparees the numerical solution for the radius of curvature (line) with the analytical formula (symbols)
+ To get them to agree, we have had to fiddle the analyic result
  + Next job is to verify this
#+BEGIN_SRC python :return plotfile :results file
  from matplotlib import pyplot as plt
  from astropy.table import Table
  import seaborn as sns
  from alpha_analytic import alpha_from_beta_xi as alpha

  plotfile = 'alpha-vs-beta-xi.pdf'
  tab = Table.read('alpha-vs-beta-xi.tab', format='ascii.tab')
  sns.set_palette('magma', 10)
  fig, ax = plt.subplots(1, 1)
  xcol = tab.colnames[0]
  for ycol in tab.colnames[1:]:
      line, = ax.plot(tab[xcol], tab[ycol], label=r'$\{}$'.format(ycol))
      xi = float(ycol.split('=')[-1])
      ax.plot(tab[xcol], alpha(tab[xcol], xi), 'o', markevery=20,
              color=line.get_color(), label='')
  ax.legend(ncol=2, fontsize='x-small', loc='lower right')
  ax.set_xlabel(r'$\beta$')
  ax.set_ylabel(r'$\alpha$')
  ax.set_xlim(-0.03, 1.03)
  fig.set_size_inches(3, 6)
  fig.tight_layout()
  fig.savefig(plotfile)
  fig.savefig(plotfile.replace('.pdf', '.png'), dpi=50)
#+END_SRC

#+RESULTS:
[[file:alpha-vs-beta-xi.pdf]]


Here is the image inline:

[[file:alpha-vs-beta-xi.png]]

* Utility functions for A, B, and \theta_c

#+BEGIN_SRC python :eval no :tangle conic_parameters.py
  import numpy as np
  from alpha_analytic import alpha_from_beta_xi as gamma

  def A(beta, xi):
      return 1.0/(1.0 - 2.0*gamma(beta, xi))


  def th1_90_method1(beta, xi):
      x = 3*beta*xi
      return np.sqrt(x/(1 + x/5))


  def th1_90_method2(beta, xi):
      return np.sqrt(2.5*(np.sqrt(1.0 + 12*xi*beta/5.0) - 1.0))


  def B(beta,xi=1.0, th1_90=th1_90_method1):
      """
      Returns R_90 normalized with R_0
      """
      numerator = (1+np.sqrt(beta))*th1_90(beta, xi)
      denominator = (1.-xi*beta)*np.sqrt(beta)
      return numerator/denominator


  def B(beta, xi):
      numerator = np.sqrt(3*xi)*(1+np.sqrt(beta))
      denominator = (1.-xi*beta)*np.sqrt(1.+0.2*xi*beta)
      return numerator/denominator


  def theta_c(beta,xi=1.0):
      """
      theta_c defines the excentricity of a given conic
      """
      arg = 2*A(beta,xi) - B(beta, xi)**2
      return np.sign(arg)*np.arctan(np.sqrt(np.abs(arg)))
#+END_SRC

* Comparing the conic fits with the numerical solutions
#+BEGIN_SRC python :eval no :tangle crw-conic-compare.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import equation6
  import conic_parameters
  sys.path.append('../conic-projection')
  from conproj_utils import Conic


  def R_from_theta(theta, beta, xi):
      shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
      R = shell.radius(theta)
      R0 = np.sqrt(beta)/(1 + np.sqrt(beta))
      return R/R0


  xigrid = [1.0, 0.8, 0.4, 0.1]
  nxi = len(xigrid)
  betagrid = [0.001, 0.01, 0.1]
  nbeta = len(betagrid)

  ntheta = 100
  theta = np.linspace(0.0, np.pi, ntheta)

  figfilename = sys.argv[0].replace('.py', '.pdf')
  fig, axes = plt.subplots(nxi, nbeta, sharex=True, sharey=True)

  for j, xi in enumerate(xigrid):
      for i, beta in enumerate(betagrid):
          ax = axes[j, i]

          # Geberalized CRW solution
          R_crw = R_from_theta(theta, beta, xi)
          x_crw = R_crw*np.cos(theta)
          y_crw = R_crw*np.sin(theta)

          # Matched conic parameters
          A = conic_parameters.A(beta, xi)
          th_conic = np.degrees(conic_parameters.theta_c(beta, xi))
          c = Conic(A=A, th_conic=th_conic)
          t = c.make_t_array()
          x_con = c.x(t)
          y_con = c.y(t)

          # Compare the two curves
          ax.plot(x_crw, y_crw)
          ax.plot(x_con, y_con, '--')
          ax.plot(0.0, 0.0, 'o', color='k')
          ax.axhline(ls=':')
          ax.axvline(ls=':')
          ax.text(1.5, 2.5, r'$\beta = {:.3f}$ '.format(beta), ha='right')
          ax.text(1.5, 2.0, r'$\xi = {:.1f}$ '.format(xi), ha='right')

  axes[-1, 0].set_xlim(-1.5, 1.5)
  axes[-1, 0].set_ylim(-0.1, 3.0)
  axes[-1, 0].set_xlabel(r'$x / r_{0}$')
  axes[-1, 0].set_ylabel(r'$y / r_{0}$')

  fig.set_size_inches(9, 12)
  fig.tight_layout()
  fig.savefig(figfilename)
  print(figfilename)

#+END_SRC

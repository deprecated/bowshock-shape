* Revisiting the radius of curvature for the generalized CRW models
+ [2016-06-11 Sat] We find that the anisotropic models have smaller R_c than our analytic formula
  + The first calculations of this are in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/papers/Paper1/oblate_analysis.ipynb]]
  + We calculated radius of curvature directly from finite differences
  + Another approach would be to fit the first few terms of a Taylor expansion:
    + \(R(\theta) = R_{0} \left( 1 + \alpha \theta^{2} + \mathcal{O}(\theta^{4}) \right)\)
  + Then the radius of curvature is
    + \(A \equiv R_{c}/R_{0} = (1 - 2\alpha)^{-1}\)
** Find R_c from fitting Taylor series

+ We could fit a polynomial in \(\theta^2\) to \(R(\theta)/R_{0}\) 
  + Where \(\alpha\) is given by the linear (in \(\theta^2\)) term
  + This is allowing the constant term to be different from 1
+ Or, we can put \(\hat\alpha(\theta) = ((R(\theta)/R_{0}) - 1)/\theta^{2}\) and then fit a polynomial in \(\theta^{2}\) to \(\hat\alpha(\theta)\)
  + Then \(\alpha\) is given by the constant term in the fit
  + This has the advantage of pinning radius to \(R_{0}\) on the axis
*** Test out the mechanism for fixed \beta, \xi

+ This seems to work perfectly
  + So long as we don't try and go to too large a value of theta in the fit

#+BEGIN_SRC python :return table
import numpy as np
import equation6

beta = 1.0
xi = 0.1
dtheta = 0.01
N = 10
NP = 2
theta = dtheta*np.arange(N)
thsq = theta**2
shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
R = shell.radius(theta)
R0 = np.sqrt(beta)/(1 + np.sqrt(beta))

ahat = (R/R0 - 1) / thsq
m = np.isfinite(ahat)
c = np.polyfit(thsq[2:], ahat[2:], NP)
p = np.poly1d(c)
residfrac = (p(thsq) - ahat)/ahat

table = [ ['theta', 'R/R0', '(R/R0 - 1) / theta^2', 'Fit', 'Resid frac'], None]


for row in zip(theta, R/R0, ahat, p(thsq), residfrac):
    table.append(['{:.10f}'.format(x) for x in row])

table.append(None)
table.append(['{:.10f}'.format(x) for x in reversed(c)])


#+END_SRC

#+RESULTS:
|         theta |          R/R0 | (R/R0 - 1) / theta^2 |           Fit |    Resid frac |
|---------------+---------------+---------------------+---------------+---------------|
|  0.0000000000 |  1.0000000000 |                 nan | -0.1750000221 |           nan |
|  0.0100000000 |  0.9999824995 |       -0.1750050347 | -0.1750050546 |  0.0000001139 |
|  0.0200000000 |  0.9999299920 |       -0.1750200711 | -0.1750200816 |  0.0000000600 |
|  0.0300000000 |  0.9998424596 |       -0.1750448911 | -0.1750448912 |  0.0000000008 |
|  0.0400000000 |  0.9997198734 |       -0.1750791388 | -0.1750791306 | -0.0000000467 |
|  0.0500000000 |  0.9995621942 |       -0.1751223158 | -0.1751223057 | -0.0000000577 |
|  0.0600000000 |  0.9993693744 |       -0.1751737852 | -0.1751737812 | -0.0000000227 |
|  0.0700000000 |  0.9991413594 |       -0.1752327734 | -0.1752327807 |  0.0000000419 |
|  0.0800000000 |  0.9988780904 |       -0.1752983736 | -0.1752983867 |  0.0000000748 |
|  0.0900000000 |  0.9985795067 |       -0.1753695491 | -0.1753695403 | -0.0000000503 |
|---------------+---------------+---------------------+---------------+---------------|
| -0.1750000221 | -0.0503839209 |        0.5881965600 |               |               |


For very small \beta it seems to be better to not use the first two points in the fit 
*** Find \alpha on a grid of \beta, \xi


#+BEGIN_SRC python :eval no :tangle alpha-vs-beta-xi.py
  import numpy as np
  import equation6
  from astropy.table import Table, Column

  def find_alpha(beta, xi, dtheta=0.01, ntheta=10, npoly=2):
      """Find the coefficient of theta**2 in the Taylor expansion of R(theta)"""
      theta = dtheta*np.arange(ntheta)
      thsq = theta**2
      shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
      R = shell.radius(theta)
      R0 = np.sqrt(beta)/(1 + np.sqrt(beta))
      ahat = (R/R0 - 1) / thsq
      c = np.polyfit(thsq[2:], ahat[2:], npoly)
      return c[-1]



  if __name__ == '__main__':

      xi_range = np.linspace(0.1, 1.0, 10)
      beta_range = np.linspace(0.001, 1.0, 300)

      tab = Table()
      tab.add_column(Column(name='beta', data=beta_range, format='{:.6f}'))
      for xi in xi_range:
          # print(xi)
          tab.add_column(Column(name='xi = {:.1f}'.format(xi),
                                data=[find_alpha(beta, xi) for beta in beta_range],
                                format='{:.6f}'))

      tabfilename = 'alpha-vs-beta-xi.tab'
      tab.write(tabfilename, format='ascii.tab')
      print(tabfilename)
#+END_SRC

#+BEGIN_SRC sh :results file
python alpha-vs-beta-xi.py
#+END_SRC

#+RESULTS:
[[file:alpha-vs-beta-xi.tab]]
*** New analytic solution for \alpha
+ According to my new attempt at the small angle expansion we have
  + \[\alpha = \frac{c}{1 + \beta^{1/2}} + \frac16 (1 + 2\beta^{1/2})\]
  + \[c = \frac{1}{30} \left(1 - \beta - \frac94 k\right)\]
+ This is now fully verified against the numerical solution

#+BEGIN_SRC python :eval no :tangle alpha_analytic.py
  import numpy as np

  def alpha_from_c_beta(c, beta):
      sb = np.sqrt(beta)
      return c/(1.0 + sb) + (1.0 + 2.0*sb)/6.0


  def c_from_beta_k(beta, k):
      return (1.0 - beta - 9.0*k/4.0)/30.0


  def k_from_xi(xi):
      return 2.0/xi - 2.0


  def alpha_from_beta_xi(beta, xi):
      return alpha_from_c_beta(c_from_beta_k(beta, k_from_xi(xi)), beta)

#+END_SRC
*** Plot \alpha as function of \beta for each \xi
+ This comparees the numerical solution for the radius of curvature (line) with the analytical formula (symbols)
+ To get them to agree, we have had to fiddle the analyic result
  + Next job is to verify this
#+BEGIN_SRC python :return plotfile :results file
  from matplotlib import pyplot as plt
  from astropy.table import Table
  import seaborn as sns
  from alpha_analytic import alpha_from_beta_xi as alpha

  plotfile = 'alpha-vs-beta-xi.pdf'
  tab = Table.read('alpha-vs-beta-xi.tab', format='ascii.tab')
  sns.set_palette('magma', 10)
  fig, ax = plt.subplots(1, 1)
  xcol = tab.colnames[0]
  for ycol in tab.colnames[1:]:
      line, = ax.plot(tab[xcol], tab[ycol], label=r'$\{}$'.format(ycol))
      xi = float(ycol.split('=')[-1])
      ax.plot(tab[xcol], alpha(tab[xcol], xi), 'o', markevery=20,
              color=line.get_color(), label='')
  ax.legend(ncol=2, fontsize='x-small', loc='lower right')
  ax.set_xlabel(r'$\beta$')
  ax.set_ylabel(r'$\alpha$')
  ax.set_xlim(-0.03, 1.03)
  fig.set_size_inches(3, 6)
  fig.tight_layout()
  fig.savefig(plotfile)
  fig.savefig(plotfile.replace('.pdf', '.png'), dpi=50)
#+END_SRC

#+RESULTS:
[[file:alpha-vs-beta-xi.pdf]]


Here is the image inline:

[[file:alpha-vs-beta-xi.png]]

* Utility functions for A, B, and \theta_c

#+BEGIN_SRC python :eval no :tangle conic_parameters.py
  import numpy as np
  from scipy.optimize import fsolve
  from scipy.special import gamma as gamma_func
  from alpha_analytic import alpha_from_beta_xi as gamma

  def A(beta, xi):
      return 1.0/(1.0 - 2.0*gamma(beta, xi))


  def th1_90_method1(beta, xi):
      x = 3*beta*xi
      return np.sqrt(x/(1 + x/5))


  def th1_90_method2(beta, xi):
      return np.sqrt(2.5*(np.sqrt(1.0 + 12*xi*beta/5.0) - 1.0))


  def B(beta,xi=1.0, th1_90=th1_90_method1):
      """
      Returns R_90 normalized with R_0
      """
      numerator = (1+np.sqrt(beta))*th1_90(beta, xi)
      denominator = (1.-xi*beta)*np.sqrt(beta)
      return numerator/denominator


  def theta_c(beta,xi=1.0):
      """
      theta_c defines the excentricity of a given conic
      """
      arg = 2*A(beta,xi) - B(beta, xi)**2
      return np.sign(arg)*np.arctan(np.sqrt(np.abs(arg)))



  #
  # Now, functions for the hyperbola that fits the tail
  #

  def finf(th, beta, xi):
      """Function that gives f(theta) = 0 when theta = theta_infty
  
      Version for hemispheric flow with anisotropy xi
      """
      k = 2./xi-2
      C = (k+2*(1-beta))/(k+2)
      I = np.sqrt(np.pi)*gamma_func(0.5*(k+1))/(4*gamma_func(0.5*k+2))
      D = np.pi + 2*beta*I
      return th - C*np.tan(th) - D

  def finf_CRW(th, beta, xi):
      """Function that gives f(theta) = 0 when theta = theta_infty
  
      Version for spherically symmetric flow, as in CRW
      """
      assert xi is None, 'Parameter xi is meaningless for vanilla CRW'
      return th - np.tan(th) - np.pi/(1.0 -beta)


  def theta_tail(beta, xi, f=finf, th_init=np.radians(91.0)):
      """Opening half-angle of tail: th1_infty

      This version only works with scalar args `beta` and `xi`
      """
      thinf = fsolve(f, th_init, args=(beta, xi))
      return np.pi - thinf
#+END_SRC




* The fit to the tail
+ We have determined the \theta_c = -\theta_{1,\infty} for the tail
+ But this does not uniquely determine the hyperbola
+ We can assume tha the center of the hyperbola is the "other" star
  + So this is at x/r_0 = D/r_0 = (1 + \beta^{1/2}) / \beta^{1/2}
  + We can draw the asymptote from their to check this

* Comparing the conic fits with the numerical solutions
#+BEGIN_SRC python :eval no :tangle crw-conic-compare.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import equation6
  import conic_parameters
  sys.path.append('../conic-projection')
  from conproj_utils import Conic


  def R_from_theta(theta, beta, xi):
      shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
      R = shell.radius(theta)
      return R/shell.R0


  xigrid = [1.0, 0.8, 0.4, 0.1]
  nxi = len(xigrid)
  betagrid = [0.001, 0.01, 0.1]
  nbeta = len(betagrid)

  ntheta = 100
  theta = np.linspace(0.0, np.pi, ntheta)

  figfilename = sys.argv[0].replace('.py', '.pdf')
  fig, axes = plt.subplots(nxi, nbeta, sharex=True, sharey=True)

  for j, xi in enumerate(xigrid):
      for i, beta in enumerate(betagrid):
          ax = axes[j, i]

          # Geberalized CRW solution
          R_crw = R_from_theta(theta, beta, xi)
          x_crw = R_crw*np.cos(theta)
          y_crw = R_crw*np.sin(theta)

          # Matched conic parameters
          A = conic_parameters.A(beta, xi)
          th_conic = np.degrees(conic_parameters.theta_c(beta, xi))
          c = Conic(A=A, th_conic=th_conic)
          t = c.make_t_array()
          x_con = c.x(t)
          y_con = c.y(t)

          # Hyperbola fit to tail
          th_tail = np.degrees(conic_parameters.theta_tail(beta, xi))

          # First draw the asymptote
          D = (1 + np.sqrt(beta))/np.sqrt(beta)
          b_a = np.tan(np.radians(th_tail))
          x_cone = np.linspace(-10*D, 10*D, 3)
          y_cone = -b_a*(x_cone - 0.5*(1 + np.sqrt(beta))*D)
          print(th_tail, b_a, x_cone, y_cone)

  
          # c2 = Conic(A=0.3*A, th_conic=-th_tail)
          # t2 = c2.make_t_array()
          # x_tail = c2.x(t2)
          # y_tail = c2.y(t2)

          # # Renormalize to give the same B
          # y90_tail = np.abs(y_tail[np.argmin(x_tail**2)])
          # y90_con = np.abs(y_con[np.argmin(x_con**2)])
          # fac = y90_con/y90_tail
          # print('beta = {:.3f}, xi = {:.1f}. Renormalizing by {:.3f}'.format(beta, xi, fac))
          # x_tail *= fac
          # y_tail *= fac

          # Compare the three curves
          ax.plot(x_crw, y_crw)
          ax.plot(x_con, y_con, '--')
          ax.plot(x_cone, y_cone, ':')
          ax.plot(0.0, 0.0, 'o', color='k')
          ax.axhline(ls=':')
          ax.axvline(ls=':')
          ax.text(1.5, 2.5, r'$\beta = {:.3f}$ '.format(beta), ha='right')
          ax.text(1.5, 2.0, r'$\xi = {:.1f}$ '.format(xi), ha='right')

  # axes[-1, 0].set_xlim(-1.5, 1.5)
  # axes[-1, 0].set_ylim(-0.1, 3.0)
  axes[-1, 0].set_xlim(-3.0, 2.1)
  axes[-1, 0].set_ylim(-0.1, 5.0)
  axes[-1, 0].set_xlabel(r'$x / r_{0}$')
  axes[-1, 0].set_ylabel(r'$y / r_{0}$')

  fig.set_size_inches(9, 12)
  fig.tight_layout()
  fig.savefig(figfilename)
  print(figfilename)

#+END_SRC


#+BEGIN_SRC sh :results verbatim
python crw-conic-compare.py
#+END_SRC

#+RESULTS:
#+begin_example
[ 9.90968802] [ 0.17470218] [-326.22776602    0.          326.22776602] [ 59.93245119   2.93974851 -54.05295417]
[ 21.88379684] [ 0.40166896] [-110.    0.  110.] [ 46.61368288   2.43009721 -41.75348845]
[ 47.7298386] [ 1.10013608] [-41.6227766   0.         41.6227766] [ 48.80426882   3.01355073 -42.77716736]
[ 8.4465471] [ 0.14849737] [-326.22776602    0.          326.22776602] [ 50.94275927   2.49879485 -45.94516956]
[ 18.80143267] [ 0.34045567] [-110.    0.  110.] [ 39.50988066   2.05975681 -35.39036704]
[ 42.04447569] [ 0.9018106] [-41.6227766   0.         41.6227766] [ 40.00614827   2.47028713 -35.065574  ]
[ 5.55905005] [ 0.09732933] [-326.22776602    0.          326.22776602] [ 33.38930827   1.63777999 -30.1137483 ]
[ 12.53169704] [ 0.22227514] [-110.    0.  110.] [ 25.79503017   1.34476461 -23.10550096]
[ 29.1507029] [ 0.55775251] [-41.6227766   0.         41.6227766] [ 24.74303329   1.52782508 -21.68738312]
[ 2.67098097] [ 0.04665121] [-326.22776602    0.          326.22776602] [ 16.00392959   0.78500924 -14.4339111 ]
[ 6.06744139] [ 0.10629446] [-110.    0.  110.] [ 12.33547213   0.64308149 -11.04930916]
[ 14.45364449] [ 0.2577546] [-41.6227766   0.         41.6227766] [ 11.43451695   0.70605498 -10.022407  ]
crw-conic-compare.pdf
#+end_example



* DONE Problems with the asymptotic cone
CLOSED: [2016-06-29 Wed 08:47]
+ [2016-06-27 Mon] I am getting inconsistent results
+ The conical angle seems wrong
  + Don't know if this is problem with numerical or analytic result
  + [X] Solved [2016-06-28 Tue] - It was an error in the [[file:equation6.py::def%20anisotropic_momentum(theta):][function]] =equation6.anisotropic_momentum(theta)=.  Fixed now
+ [X] I need to do some more tests
+ [X] Plot the CRW result versus our hemisphere one for k = 0
  + We now see the slight difference for \theta > \pi/2
+ [X] And check the CRW asymptotic angle
  + This comes out right
+ [X] Compare with approximate solution
  + This is done in [[file:crw_misc_utils.py]], tangled from below
+ [X] NOW look at approach to asymptotic angle
  + Plot (\theta_1 - \theta_{1,\infty}) versus (\theta - \theta_{\infty})
  + And also (\alpha -\alpha_\infty) versus (\theta - \theta_{\infty})
    + Where tan \alpha = (1 + \omega tan \theta) / (tan \theta - \omega)
    + And \omega = (1/R) (d R/d \theta)
    + Of course \alpha_\infty =  \theta_{1,\infty} = \pi - \theta_{\infty}
    + \(\alpha_\infty =  \theta_{1,\infty} = \pi - \theta_{\infty}\)


#+BEGIN_SRC python :eval no :tangle crw_misc_utils.py
  """Miscellaneous functions for Canto, Raga, Wilkin (1996) bow shocks

  """

  import numpy as np


  def th1_approx(th, beta):
      """Equation (26) of CRW"""
      fac = 0.8*beta*(1.0 - th/np.tan(th))
      return np.sqrt(7.5*(np.sqrt(1.0 + fac) - 1.0))
    

  def radius(th, th1):
      """Radius in terms of D from Eq (23) of CRW
    
      This applies generally, even for anisotropic cases
      """
      return np.sin(th1)/np.sin(th + th1)


#+END_SRC


#+BEGIN_SRC python :eval no :tangle crw-tail-check.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import equation6
  import conic_parameters
  sys.path.append('../conic-projection')
  from conproj_utils import Conic
  import crw_misc_utils


  def polar_plot(r, th, ax, **kwargs):
      ax.plot(r*np.cos(th), r*np.sin(th), **kwargs)


  def omega(R, theta):
      """(1/R) (d R/d theta) by finite differences"""
      dR_dtheta = np.pad(np.diff(R)/np.diff(theta), (0, 1), 'edge')
      return dR_dtheta/R


  def alpha(R, theta):
      """Angle of tangent to curve R(theta)"""
      t = np.tan(theta)
      om = omega(R, theta)
      tana = (1 + om*t)/(t - om)
      return np.arctan(tana)


  try:
      beta = float(sys.argv[1])
  except IndexError:
      sys.exit('Usage: {} BETA'.format(sys.argv[0]))


  ntheta = 400
  nearly = 1.0 # - 1e-5

  xmax = 1.5

  R0 = np.sqrt(beta)/(1 + np.sqrt(beta))
  shell = equation6.Shell(beta=beta)
  theta = np.linspace(0.0, nearly*shell.th_infty, ntheta)
  R, th1 = shell.radius(theta, method='brent', full=True)
  alph = alpha(R, theta)
  R_approx = crw_misc_utils.radius(theta, crw_misc_utils.th1_approx(theta, beta))
  m = R_approx > 0.0

  th_tail = conic_parameters.theta_tail(beta, xi=None,
                                        f=conic_parameters.finf_CRW)
  print('th1_infty =', np.degrees(shell.th1_infty), np.degrees(th1[-4:]))
  print('alpha_infty =', np.degrees(alph[-4:]))

  b_a = np.tan(th_tail)
  x_tail = np.linspace(-xmax, xmax, 3)
  y_tail = -b_a*(x_tail - 1.0)


  shell2 = equation6.Shell(beta=beta, xi=1.0, innertype='anisotropic')
  theta2 = np.linspace(0.0, nearly*shell2.th_infty, ntheta)
  R2, th12 = shell2.radius(theta2, method='brent', full=True)
  alph2 = alpha(R2, theta2)
  th_tail2 = conic_parameters.theta_tail(beta, xi=1.0)
  print('th1_infty_2 =', np.degrees(shell2.th1_infty), np.degrees(th12[-4:]))
  print('alpha_infty_2 =', np.degrees(alph2[-4:]))

  b_a2 = np.tan(th_tail2)
  y_tail2 = -b_a2*(x_tail - 1.0)

  figfilename = sys.argv[0].replace('.py', '-{:05d}.pdf').format(int(1e4*beta))
  fig, (ax, axx) = plt.subplots(2, 1)
  polar_plot(R, theta, ax)
  polar_plot(R_approx[m], theta[m], ax, ls='None', marker='.', alpha=0.2)
  polar_plot(R2, theta2, ax, lw=0.6)
  ax.plot(x_tail, y_tail, '--')
  ax.plot(x_tail, y_tail2, '--')

  ax.set_xlim(-xmax, xmax)
  ax.set_ylim(-0.2*xmax, 1.2*xmax)
  ax.set_aspect('equal', adjustable='box')

  axx.plot(shell.th_infty - theta, shell.th1_infty - th1,
           alpha=0.7, label=r'$\theta_1 - \theta_{1,\infty}$ (CRW)')
  axx.plot(shell.th_infty - theta, alph - shell.th1_infty,
           alpha=0.7, label=r'$\alpha - \theta_{1,\infty}$ (CRW)')

  axx.plot(shell2.th_infty - theta2, shell2.th1_infty - th12,
           alpha=0.7, label=r'$\theta_1 - \theta_{1,\infty}$ ($k = 0$)')
  axx.plot(shell2.th_infty - theta2, alph2 - shell2.th1_infty,
           alpha=0.7, label=r'$\alpha - \theta_{1,\infty}$ ($k = 0$)')
  axx.set_ylim(0.0, 1.0)
  axx.set_xlabel(r'$\theta - \theta_{\infty}$')
  axx.legend(loc='upper left', fontsize='small')

  fig.set_size_inches(4.0, 6.0)
  fig.savefig(figfilename)
  print(figfilename)



#+END_SRC

#+BEGIN_SRC sh :results verbatim
python crw-tail-check.py 0.1  # 1>&2
#+END_SRC

#+RESULTS:
: th1_infty = 51.1601363953 [ 50.51058359  50.7257642   50.94227512          nan]
: alpha_infty = [ 51.4864857   51.48419607          nan          nan]
: th1_infty_2 = 47.7298385983 [ 47.26845601  47.42126366  47.57505055          nan]
: alpha_infty_2 = [ 48.06411049  48.06226863          nan          nan]
: crw-tail-check-01000.pdf


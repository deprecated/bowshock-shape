* Revisiting the radius of curvature for the generalized CRW models
+ [2016-06-11 Sat] We find that the anisotropic models have smaller R_c than our analytic formula
  + The first calculations of this are in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/papers/Paper1/oblate_analysis.ipynb]]
  + We calculated radius of curvature directly from finite differences
  + Another approach would be to fit the first few terms of a Taylor expansion:
    + \(R(\theta) = R_{0} \left( 1 + \alpha \theta^{2} + \mathcal{O}(\theta^{4}) \right)\)
  + Then the radius of curvature is
    + \(A \equiv R_{c}/R_{0} = (1 - 2\alpha)^{-1}\)
** Find R_c from fitting Taylor series

+ We could fit a polynomial in \(\theta^2\) to \(R(\theta)/R_{0}\) 
  + Where \(\alpha\) is given by the linear (in \(\theta^2\)) term
  + This is allowing the constant term to be different from 1
+ Or, we can put \(\hat\alpha(\theta) = ((R(\theta)/R_{0}) - 1)/\theta^{2}\) and then fit a polynomial in \(\theta^{2}\) to \(\hat\alpha(\theta)\)
  + Then \(\alpha\) is given by the constant term in the fit
  + This has the advantage of pinning radius to \(R_{0}\) on the axis
*** Test out the mechanism for fixed \beta, \xi

+ This seems to work perfectly
  + So long as we don't try and go to too large a value of theta in the fit

#+BEGIN_SRC python :return table
import numpy as np
import equation6

beta = 1.0
xi = 0.1
dtheta = 0.01
N = 10
NP = 2
theta = dtheta*np.arange(N)
thsq = theta**2
shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
R = shell.radius(theta)
R0 = np.sqrt(beta)/(1 + np.sqrt(beta))

ahat = (R/R0 - 1) / thsq
m = np.isfinite(ahat)
c = np.polyfit(thsq[2:], ahat[2:], NP)
p = np.poly1d(c)
residfrac = (p(thsq) - ahat)/ahat

table = [ ['theta', 'R/R0', '(R/R0 - 1) / theta^2', 'Fit', 'Resid frac'], None]


for row in zip(theta, R/R0, ahat, p(thsq), residfrac):
    table.append(['{:.10f}'.format(x) for x in row])

table.append(None)
table.append(['{:.10f}'.format(x) for x in reversed(c)])


#+END_SRC

#+RESULTS:
|         theta |          R/R0 | (R/R0 - 1) / theta^2 |           Fit |    Resid frac |
|---------------+---------------+---------------------+---------------+---------------|
|  0.0000000000 |  1.0000000000 |                 nan | -0.1750000221 |           nan |
|  0.0100000000 |  0.9999824995 |       -0.1750050347 | -0.1750050546 |  0.0000001139 |
|  0.0200000000 |  0.9999299920 |       -0.1750200711 | -0.1750200816 |  0.0000000600 |
|  0.0300000000 |  0.9998424596 |       -0.1750448911 | -0.1750448912 |  0.0000000008 |
|  0.0400000000 |  0.9997198734 |       -0.1750791388 | -0.1750791306 | -0.0000000467 |
|  0.0500000000 |  0.9995621942 |       -0.1751223158 | -0.1751223057 | -0.0000000577 |
|  0.0600000000 |  0.9993693744 |       -0.1751737852 | -0.1751737812 | -0.0000000227 |
|  0.0700000000 |  0.9991413594 |       -0.1752327734 | -0.1752327807 |  0.0000000419 |
|  0.0800000000 |  0.9988780904 |       -0.1752983736 | -0.1752983867 |  0.0000000748 |
|  0.0900000000 |  0.9985795067 |       -0.1753695491 | -0.1753695403 | -0.0000000503 |
|---------------+---------------+---------------------+---------------+---------------|
| -0.1750000221 | -0.0503839209 |        0.5881965600 |               |               |


For very small \beta it seems to be better to not use the first two points in the fit 
*** Find \alpha on a grid of \beta, \xi


#+BEGIN_SRC python :eval no :tangle alpha-vs-beta-xi.py
  import numpy as np
  import equation6
  from astropy.table import Table, Column

  def find_alpha(beta, xi, dtheta=0.01, ntheta=10, npoly=2):
      """Find the coefficient of theta**2 in the Taylor expansion of R(theta)"""
      theta = dtheta*np.arange(ntheta)
      thsq = theta**2
      shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
      R = shell.radius(theta)
      R0 = np.sqrt(beta)/(1 + np.sqrt(beta))
      ahat = (R/R0 - 1) / thsq
      c = np.polyfit(thsq[2:], ahat[2:], npoly)
      return c[-1]



  if __name__ == '__main__':

      xi_range = np.linspace(0.1, 1.0, 10)
      beta_range = np.linspace(0.001, 1.0, 300)

      tab = Table()
      tab.add_column(Column(name='beta', data=beta_range, format='{:.6f}'))
      for xi in xi_range:
          # print(xi)
          tab.add_column(Column(name='xi = {:.1f}'.format(xi),
                                data=[find_alpha(beta, xi) for beta in beta_range],
                                format='{:.6f}'))

      tabfilename = 'alpha-vs-beta-xi.tab'
      tab.write(tabfilename, format='ascii.tab')
      print(tabfilename)
#+END_SRC

#+BEGIN_SRC sh :results file
python alpha-vs-beta-xi.py
#+END_SRC

#+RESULTS:
[[file:alpha-vs-beta-xi.tab]]
*** New analytic solution for \alpha
+ According to my new attempt at the small angle expansion we have
  + \[\alpha = \frac{c}{1 + \beta^{1/2}} + \frac16 (1 + 2\beta^{1/2})\]
  + \[c = \frac{1}{30} \left(1 - \beta - \frac94 k\right)\]
+ This is now fully verified against the numerical solution

#+BEGIN_SRC python :eval no :tangle alpha_analytic.py
  import numpy as np

  def alpha_from_c_beta(c, beta):
      sb = np.sqrt(beta)
      return c/(1.0 + sb) + (1.0 + 2.0*sb)/6.0


  def c_from_beta_k(beta, k):
      return (1.0 - beta - 9.0*k/4.0)/30.0


  def k_from_xi(xi):
      if xi is None:
          return 0.0
      else:
          return 2.0/xi - 2.0


  def alpha_from_beta_xi(beta, xi):
      return alpha_from_c_beta(c_from_beta_k(beta, k_from_xi(xi)), beta)

#+END_SRC
*** Plot \alpha as function of \beta for each \xi
+ This comparees the numerical solution for the radius of curvature (line) with the analytical formula (symbols)
+ To get them to agree, we have had to fiddle the analyic result
  + Next job is to verify this
#+BEGIN_SRC python :return plotfile :results file
  from matplotlib import pyplot as plt
  from astropy.table import Table
  import seaborn as sns
  from alpha_analytic import alpha_from_beta_xi as alpha

  plotfile = 'alpha-vs-beta-xi.pdf'
  tab = Table.read('alpha-vs-beta-xi.tab', format='ascii.tab')
  sns.set_palette('magma', 10)
  fig, ax = plt.subplots(1, 1)
  xcol = tab.colnames[0]
  for ycol in tab.colnames[1:]:
      line, = ax.plot(tab[xcol], tab[ycol], label=r'$\{}$'.format(ycol))
      xi = float(ycol.split('=')[-1])
      ax.plot(tab[xcol], alpha(tab[xcol], xi), 'o', markevery=20,
              color=line.get_color(), label='')
  ax.legend(ncol=2, fontsize='x-small', loc='lower right')
  ax.set_xlabel(r'$\beta$')
  ax.set_ylabel(r'$\alpha$')
  ax.set_xlim(-0.03, 1.03)
  fig.set_size_inches(3, 6)
  fig.tight_layout()
  fig.savefig(plotfile)
  fig.savefig(plotfile.replace('.pdf', '.png'), dpi=50)
#+END_SRC

#+RESULTS:
[[file:alpha-vs-beta-xi.pdf]]


Here is the image inline:

[[file:alpha-vs-beta-xi.png]]

* TODO Utility functions for A, B, and \theta_c

#+BEGIN_SRC python :eval no :tangle conic_parameters.py
  import sys
  import numpy as np
  from scipy.optimize import fsolve
  from scipy.special import gamma as gamma_func
  from alpha_analytic import alpha_from_beta_xi as gamma
  sys.path.append('../conic-projection')
  from conproj_utils import Conic

  def A(beta, xi):
      return 1.0/(1.0 - 2.0*gamma(beta, xi))


  def th1_90_method1(beta, xi):
      x = 3*beta*xi
      return np.sqrt(x/(1 + x/5))


  def th1_90_method2(beta, xi):
      return np.sqrt(2.5*(np.sqrt(1.0 + 12*xi*beta/5.0) - 1.0))


  def B(beta,xi=1.0, th1_90=th1_90_method1):
      """
      Returns R_90 normalized with R_0
      """
      if xi is None:
          xxi = 1.0
      else:
          xxi = xi
      numerator = (1+np.sqrt(beta))*th1_90(beta, xxi)
      denominator = (1.-xxi*beta)*np.sqrt(beta)
      return numerator/denominator


  def theta_c(beta,xi=1.0):
      """
      theta_c defines the excentricity of a given conic
      """
      arg = 2*A(beta,xi) - B(beta, xi)**2
      return np.sign(arg)*np.arctan(np.sqrt(np.abs(arg)))



  #
  # Now, functions for the hyperbola that fits the tail
  #

  def finf(th, beta, xi):
      """Function that gives f(theta) = 0 when theta = theta_infty

      Version for hemispheric flow with anisotropy xi
      """
      k = 2./xi-2
      C = (k+2*(1-beta))/(k+2)
      I = np.sqrt(np.pi)*gamma_func(0.5*(k+1))/(4*gamma_func(0.5*k+2))
      D = np.pi + 2*beta*I
      return th - C*np.tan(th) - D

  def finf_CRW(th, beta, xi):
      """Function that gives f(theta) = 0 when theta = theta_infty

      Version for spherically symmetric flow, as in CRW
      """
      assert xi is None, 'Parameter xi is meaningless for vanilla CRW'
      return th - np.tan(th) - np.pi/(1.0 -beta)


  def theta_tail(beta, xi, f=finf, th_init=np.radians(91.0)):
      """Opening half-angle of tail: th1_infty

      This version only works with scalar args `beta` and `xi`
      """
      thinf, = fsolve(f, th_init, args=(beta, xi))
      return np.pi - thinf


  def phi_ratio_CRW(beta, tht):
      """Limit of (th_1 - th_1,inf) / (th_inf - th) as th -> th_inf

      This is now also equal to J in the expansion: 

          phi_1 = J phi + K phi^2
      """
      return beta*(np.pi/G(tht) - 1.0)


  def G(theta):
      """Auxiliary angle function"""
      return theta - np.sin(theta)*np.cos(theta)


  def phi_ratio_anisotropic(beta, xi, tht):
      """Limit of (th_1 - th_1,inf) / (th_inf - th) as th -> th_inf"""
      # raise NotImplementedError('TODO: write phi_ratio for anisotropic case')
      return phi_ratio_CRW(beta, tht)

  def K_func_CRW(beta, tht, J):
      """Second order co-efficient in phi_1 = J phi + K phi^2 expansion"""
      rslt = -(1 + J)/(1 - beta)/np.tan(tht)
      rslt *= 1 - J**2*np.sin(tht)**2
      return rslt 


  def K_func_anisotropic(beta, xi, tht, J):
      """Second order co-efficient in phi_1 = J phi + K phi^2 expansion"""
      # raise NotImplementedError('TODO: write K function for anisotropic case')
      return 0.0

  def a_over_x(tau, J, K):
      """Hyperbola scale in terms of coefficients J and K"""
      return np.sqrt(0.5*((K/(1 + J) - tau*J)*tau/(1 + tau**2) + 4*J))


  class HeadTail(object):
      """Conic fits to the head and tail"""
      def __init__(self, beta, xi=None, xmin=None):
          """`xmin` is minimum x value of natural matching point.  If `x_m` <
          `xmin`, then the matching point will be forced to be `xmin`"""
          #
          # Set head parameters
          #
          self.A_h = A(beta, xi)
          self.theta_h = theta_c(beta, xi)
          self.sig_h = np.sign(self.theta_h)
          self.tau_h = np.tan(np.abs(self.theta_h))
          self.a_h = self.A_h/self.tau_h**2
          self.x0_h = 1.0 - self.sig_h*self.a_h
          self.head_conic = Conic(A=self.A_h, th_conic=np.degrees(self.theta_h))
          self.t_h = self.head_conic.make_t_array()
          #
          # Set tail parameters
          #
          # Distance to other star in units of R0
          self.D = (1 + np.sqrt(beta)) / np.sqrt(beta)
          if xi == None:
              # Opening angle of tail
              self.theta_t = theta_tail(beta, xi, f=finf_CRW)
              # This was formerly known as phi1_over_phi
              self.J = phi_ratio_CRW(beta, self.theta_t)
              self.K = K_func_CRW(beta, self.theta_t, self.J)
              # Empirically determined correction factor
              self.K *= 0.5*self.J*(1.0 + beta)
          else:
              self.theta_t = theta_tail(beta, xi, f=finf)
              self.J = phi_ratio_anisotropic(beta, xi, self.theta_t)
              self.K = K_func_anisotropic(beta, xi, self.theta_t, self.J)
          # Center of tail hyperbola in units of R_0
          self.x0_t =  self.D / (1.0 + self.J)

          self.tau_t = np.tan(self.theta_t)
          self.T = (self.tau_h/self.tau_t)**2

          # New 30 Aug 2016
          # Scale of hyperbola now determined from the K coefficient
          # self.a_t = self.x0_t*a_over_x(self.tau_t, self.J, self.K)

          # Find the x value where two conics match in dy/dx
          self.x_m = (self.x0_t + self.sig_h*self.T*self.x0_h) / (1 + self.sig_h*self.T)
          if xmin is not None and self.x_m < xmin:
              # 30 Aug 2016: Match at x = xmin if gradients would naturally
              # match at a more negative value of x
              self.x_m = xmin
              # And throw away the previous value of x0_t so that we can
              # force y and dy/dx to match at x=0
              self.x0_t = (1 + self.sig_h*self.T)*xmin - self.sig_h*self.T*self.x0_h
        
          # Major and minor axes of tail hyperbola
          self.a_t = np.sqrt(
              (self.x_m - self.x0_t)**2
              - self.T*np.abs(self.a_h**2 - (self.x_m - self.x0_h)**2)
          )
          self.t_t = np.linspace(0.0, max(2.0, 10.0/self.a_t), 500)

      def x_head(self, t):
          """Parametric Cartesian x coordinate of head"""
          return self.head_conic.x(t)

      def y_head(self, t):
          """Parametric Cartesian y coordinate of tail"""
          return self.head_conic.y(t)

      def x_tail(self, t):
          """Parametric Cartesian x coordinate of tail"""
          return self.x0_t - self.a_t*np.cosh(t)

      def y_tail(self, t):
          """Parametric Cartesian y coordinate of tail"""
          return self.tau_t*self.a_t*np.sinh(t)

          """Parametric Cartesian x coordinate of tail"""
          return self.x0_t - self.a_t*np.cosh(t)

      def y_tail(self, t):
          """Parametric Cartesian y coordinate of tail"""
          return self.tau_t*self.a_t*np.sinh(t)

#+END_SRC




* The fit to the tail
+ We have determined the \theta_c = -\theta_{1,\infty} for the tail
+ But this does not uniquely determine the hyperbola
+ We can assume tha the center of the hyperbola is the "other" star
  + So this is at x/r_0 = D/r_0 = (1 + \beta^{1/2}) / \beta^{1/2}
  + We can draw the asymptote from their to check this

* Comparing the conic fits with the numerical solutions
#+BEGIN_SRC python :eval no :tangle crw-conic-compare.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import equation6
  import conic_parameters
  sys.path.append('../conic-projection')
  from conproj_utils import Conic


  def R_from_theta(theta, beta, xi):
      shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
      R = shell.radius(theta)
      return R/shell.R0


  xigrid = [1.0, 0.8, 0.4, 0.1]
  nxi = len(xigrid)
  betagrid = [0.001, 0.01, 0.1]
  nbeta = len(betagrid)

  ntheta = 100
  theta = np.linspace(0.0, np.pi, ntheta)

  figfilename = sys.argv[0].replace('.py', '.pdf')
  fig, axes = plt.subplots(nxi, nbeta, sharex=True, sharey=True)

  for j, xi in enumerate(xigrid):
      for i, beta in enumerate(betagrid):
          ax = axes[j, i]

          # Geberalized CRW solution
          R_crw = R_from_theta(theta, beta, xi)
          x_crw = R_crw*np.cos(theta)
          y_crw = R_crw*np.sin(theta)

          # Matched conic parameters
          A = conic_parameters.A(beta, xi)
          th_conic = np.degrees(conic_parameters.theta_c(beta, xi))
          c = Conic(A=A, th_conic=th_conic)
          t = c.make_t_array()
          x_con = c.x(t)
          y_con = c.y(t)

          # Hyperbola fit to tail
          th_tail = np.degrees(conic_parameters.theta_tail(beta, xi))

          # First draw the asymptote
          D = (1 + np.sqrt(beta))/np.sqrt(beta)
          b_a = np.tan(np.radians(th_tail))
          x_cone = np.linspace(-10*D, 10*D, 3)
          y_cone = -b_a*(x_cone - 0.5*(1 + np.sqrt(beta))*D)
          print(th_tail, b_a, x_cone, y_cone)

  
          # c2 = Conic(A=0.3*A, th_conic=-th_tail)
          # t2 = c2.make_t_array()
          # x_tail = c2.x(t2)
          # y_tail = c2.y(t2)

          # # Renormalize to give the same B
          # y90_tail = np.abs(y_tail[np.argmin(x_tail**2)])
          # y90_con = np.abs(y_con[np.argmin(x_con**2)])
          # fac = y90_con/y90_tail
          # print('beta = {:.3f}, xi = {:.1f}. Renormalizing by {:.3f}'.format(beta, xi, fac))
          # x_tail *= fac
          # y_tail *= fac

          # Compare the three curves
          ax.plot(x_crw, y_crw)
          ax.plot(x_con, y_con, '--')
          ax.plot(x_cone, y_cone, ':')
          ax.plot(0.0, 0.0, 'o', color='k')
          ax.axhline(ls=':')
          ax.axvline(ls=':')
          ax.text(1.5, 2.5, r'$\beta = {:.3f}$ '.format(beta), ha='right')
          ax.text(1.5, 2.0, r'$\xi = {:.1f}$ '.format(xi), ha='right')

  # axes[-1, 0].set_xlim(-1.5, 1.5)
  # axes[-1, 0].set_ylim(-0.1, 3.0)
  axes[-1, 0].set_xlim(-3.0, 2.1)
  axes[-1, 0].set_ylim(-0.1, 5.0)
  axes[-1, 0].set_xlabel(r'$x / r_{0}$')
  axes[-1, 0].set_ylabel(r'$y / r_{0}$')

  fig.set_size_inches(9, 12)
  fig.tight_layout()
  fig.savefig(figfilename)
  print(figfilename)

#+END_SRC


#+BEGIN_SRC sh :results verbatim
python crw-conic-compare.py
#+END_SRC

#+RESULTS:
#+begin_example
[ 9.90968802] [ 0.17470218] [-326.22776602    0.          326.22776602] [ 59.93245119   2.93974851 -54.05295417]
[ 21.88379684] [ 0.40166896] [-110.    0.  110.] [ 46.61368288   2.43009721 -41.75348845]
[ 47.7298386] [ 1.10013608] [-41.6227766   0.         41.6227766] [ 48.80426882   3.01355073 -42.77716736]
[ 8.4465471] [ 0.14849737] [-326.22776602    0.          326.22776602] [ 50.94275927   2.49879485 -45.94516956]
[ 18.80143267] [ 0.34045567] [-110.    0.  110.] [ 39.50988066   2.05975681 -35.39036704]
[ 42.04447569] [ 0.9018106] [-41.6227766   0.         41.6227766] [ 40.00614827   2.47028713 -35.065574  ]
[ 5.55905005] [ 0.09732933] [-326.22776602    0.          326.22776602] [ 33.38930827   1.63777999 -30.1137483 ]
[ 12.53169704] [ 0.22227514] [-110.    0.  110.] [ 25.79503017   1.34476461 -23.10550096]
[ 29.1507029] [ 0.55775251] [-41.6227766   0.         41.6227766] [ 24.74303329   1.52782508 -21.68738312]
[ 2.67098097] [ 0.04665121] [-326.22776602    0.          326.22776602] [ 16.00392959   0.78500924 -14.4339111 ]
[ 6.06744139] [ 0.10629446] [-110.    0.  110.] [ 12.33547213   0.64308149 -11.04930916]
[ 14.45364449] [ 0.2577546] [-41.6227766   0.         41.6227766] [ 11.43451695   0.70605498 -10.022407  ]
crw-conic-compare.pdf
#+end_example



* DONE Problems with the asymptotic cone
CLOSED: [2016-06-29 Wed 08:47]
+ [2016-06-27 Mon] I am getting inconsistent results
+ The conical angle seems wrong
  + Don't know if this is problem with numerical or analytic result
  + [X] Solved [2016-06-28 Tue] - It was an error in the [[file:equation6.py::def%20anisotropic_momentum(theta):][function]] =equation6.anisotropic_momentum(theta)=.  Fixed now
+ [X] I need to do some more tests
+ [X] Plot the CRW result versus our hemisphere one for k = 0
  + We now see the slight difference for \theta > \pi/2
+ [X] And check the CRW asymptotic angle
  + This comes out right
+ [X] Compare with approximate solution
  + This is done in [[file:crw_misc_utils.py]], tangled from below
+ [X] NOW look at approach to asymptotic angle
  + Plot (\theta_1 - \theta_{1,\infty}) versus (\theta - \theta_{\infty})
  + And also (\alpha -\alpha_\infty) versus (\theta - \theta_{\infty})
    + Where tan \alpha = (1 + \omega tan \theta) / (tan \theta - \omega)
    + And \omega = (1/R) (d R/d \theta)
    + Of course \alpha_\infty =  \theta_{1,\infty} = \pi - \theta_{\infty}
    + \(\alpha_\infty =  \theta_{1,\infty} = \pi - \theta_{\infty}\)


#+BEGIN_SRC python :eval no :tangle crw_misc_utils.py
  """Miscellaneous functions for Canto, Raga, Wilkin (1996) bow shocks

  """

  import numpy as np


  def th1_approx(th, beta):
      """Equation (26) of CRW"""
      fac = 0.8*beta*(1.0 - th/np.tan(th))
      return np.sqrt(7.5*(np.sqrt(1.0 + fac) - 1.0))
    

  def radius(th, th1):
      """Radius in terms of D from Eq (23) of CRW
    
      This applies generally, even for anisotropic cases
      """
      return np.sin(th1)/np.sin(th + th1)


#+END_SRC


#+BEGIN_SRC python :eval no :tangle crw-tail-check.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import equation6
  import conic_parameters
  sys.path.append('../conic-projection')
  from conproj_utils import Conic
  import crw_misc_utils


  def polar_plot(r, th, ax, **kwargs):
      ax.plot(r*np.cos(th), r*np.sin(th), **kwargs)


  def omega(R, theta):
      """(1/R) (d R/d theta) by finite differences"""
      dR_dtheta = np.pad(np.diff(R)/np.diff(theta), (0, 1), 'edge')
      return dR_dtheta/R


  def alpha(R, theta):
      """Angle of tangent to curve R(theta)"""
      t = np.tan(theta)
      om = omega(R, theta)
      tana = (1 + om*t)/(t - om)
      return np.arctan(tana)


  try:
      beta = float(sys.argv[1])
  except IndexError:
      sys.exit('Usage: {} BETA'.format(sys.argv[0]))

  try:
      fix_K = float(sys.argv[2])
  except IndexError:
      fix_K = None


  ntheta = 400
  nearly = 1.0 # - 1e-5

  xmax = 1.5

  R0 = np.sqrt(beta)/(1 + np.sqrt(beta))
  shell = equation6.Shell(beta=beta)
  theta = np.linspace(0.0, nearly*shell.th_infty, ntheta)
  R, th1 = shell.radius(theta, method='brent', full=True)
  alph = alpha(R, theta)
  R_approx = crw_misc_utils.radius(theta, crw_misc_utils.th1_approx(theta, beta))
  m = R_approx > 0.0

  th_tail = conic_parameters.theta_tail(beta, xi=None,
                                        f=conic_parameters.finf_CRW)
  print('th1_infty =', np.degrees(shell.th1_infty), np.degrees(th1[-4:]))
  print('alpha_infty =', np.degrees(alph[-4:]))

  # Gradient: d phi_1 / d phi
  grad = np.diff(shell.th1_infty - th1) / np.diff(shell.th_infty - theta)
  # Theoretical estimate:
  grad0 = beta*(np.pi / (shell.th1_infty
                         - np.sin(shell.th1_infty)*np.cos(shell.th1_infty)) - 1)
  print('gradient:', grad0, grad[-4:])

  b_a = np.tan(th_tail)
  x_tail = np.linspace(-xmax, xmax, 3)
  y_tail = -b_a*(x_tail - 1.0)


  # 30 Aug 2016 - add in the attempted quadratic fit to phi_1 vs phi
  ht = conic_parameters.HeadTail(beta)
  print('Original tail parameters:')
  print('beta = {:.4f}, tau = {:.2f}, J = {:.2f}, K = {:.2f}'.format(beta, ht.tau_t, ht.J, ht.K))
  # ht.K *= ht.tau_t**2
  if fix_K is not None: 
      ht.K = fix_K
      print('Corrected K = {:.2f}'.format(ht.K))

  def fquad(phi, J=ht.J, K=ht.K):
      return J*phi + K*phi**2

  shell2 = equation6.Shell(beta=beta, xi=1.0, innertype='anisotropic')
  theta2 = np.linspace(0.0, nearly*shell2.th_infty, ntheta)
  R2, th12 = shell2.radius(theta2, method='brent', full=True)
  alph2 = alpha(R2, theta2)
  th_tail2 = conic_parameters.theta_tail(beta, xi=1.0)
  print('th1_infty_2 =', np.degrees(shell2.th1_infty), np.degrees(th12[-4:]))
  print('alpha_infty_2 =', np.degrees(alph2[-4:]))

  b_a2 = np.tan(th_tail2)
  y_tail2 = -b_a2*(x_tail - 1.0)

  figfilename = sys.argv[0].replace('.py', '-{:05d}.pdf').format(int(1e4*beta))
  fig, (ax, axx, axxx) = plt.subplots(3, 1)
  polar_plot(R, theta, ax)
  polar_plot(R_approx[m], theta[m], ax, ls='None', marker='.', alpha=0.2)
  polar_plot(R2, theta2, ax, lw=0.6)
  ax.plot(x_tail, y_tail, '--')
  ax.plot(x_tail, y_tail2, '--')

  ax.set_xlim(-xmax, xmax)
  ax.set_ylim(-0.2*xmax, 1.2*xmax)
  ax.set_aspect('equal', adjustable='box')

  phi = shell.th_infty - theta
  phi1 = shell.th1_infty - th1
  axx.plot(phi, phi1, alpha=0.7, label=r'$\theta_1 - \theta_{1,\infty}$ (CRW)')
  axx.plot(phi, phi1, alpha=0.7, label=r'$\alpha - \theta_{1,\infty}$ (CRW)')

  axx.plot(shell2.th_infty - theta2, shell2.th1_infty - th12,
           alpha=0.7, label=r'$\theta_1 - \theta_{1,\infty}$ ($k = 0$)')
  axx.plot(shell2.th_infty - theta2, alph2 - shell2.th1_infty,
           alpha=0.7, label=r'$\alpha - \theta_{1,\infty}$ ($k = 0$)')

  # 30 Aug 2016: plot the phi_1 = J phi + K phi^2 approximation
  axx.plot(phi, fquad(phi), lw=0.5, color='k', 
           label='$J, K = {:.2f}, {:.2f}$'.format(ht.J, ht.K))
  axx.plot(phi, fquad(phi, K=0.0), lw=0.5, ls='--', color='k', label=None)

  axx.set_xlim(0.0, 0.8)
  m = np.isfinite(phi1) & (phi < 0.8)
  ymax = phi1[m].max()
  print('ymax =', ymax)
  axx.set_ylim(0.0, ymax)
  axx.set_xlabel(r'$\theta - \theta_{\infty}$')
  axx.legend(loc='upper left', fontsize='small')

  axxx.plot(phi, -(phi1 - fquad(phi, K=0.0))/phi**2)
  axxx.set_xlim(0.0, 0.8)
  axxx.set_ylim(0.0, None)

  fig.set_size_inches(4.0, 8.0)
  fig.savefig(figfilename)
  print(figfilename)



#+END_SRC

#+BEGIN_SRC sh :results verbatim
python crw-tail-check.py 0.0001 -3.6 # 1>&2
python crw-tail-check.py 0.001 -1.73 # 1>&2
python crw-tail-check.py 0.01 -0.82 # 1>&2
python crw-tail-check.py 0.1 -0.375 # 1>&2
python crw-tail-check.py 0.3 -0.225 # 1>&2
python crw-tail-check.py 0.5 -0.14 # 1>&2
#+END_SRC

#+RESULTS:
#+begin_example
th1_infty = 5.61053761102 [ 5.04754783  5.21625875  5.40278582         nan]
alpha_infty = [ 6.09196301  6.06324514         nan         nan]
gradient: 0.502738479244 [ 0.3513968   0.38600759  0.42677064         nan]
Original tail parameters:
beta = 0.0001, tau = 0.10, J = 0.50, K = -15.26
Corrected K = -3.60
th1_infty_2 = 4.52858115888 [ nan  nan  nan  nan]
alpha_infty_2 = [ nan  nan  nan  nan]
ymax = 0.0688472447277
crw-tail-check-00001.pdf
th1_infty = 12.0350049161 [ 11.43392859  11.62472911  11.82481909          nan]
alpha_infty = [ 12.47720895  12.46323824          nan          nan]
gradient: 0.51198342559 [ 0.43288716  0.45324568  0.47531274         nan]
Original tail parameters:
beta = 0.0010, tau = 0.21, J = 0.51, K = -7.02
Corrected K = -1.73
th1_infty_2 = 9.90968802471 [ 9.37558249  9.54287887  9.7205421          nan]
alpha_infty_2 = [ 10.35754303  10.34342778          nan          nan]
ymax = 0.125889746985
crw-tail-check-00010.pdf
th1_infty = 25.4537374759 [ 24.83446588  25.03681074  25.24318386          nan]
alpha_infty = [ 25.85049812  25.84424862          nan          nan]
gradient: 0.549129738241 [ 0.51237752  0.52240408  0.53280405         nan]
Original tail parameters:
beta = 0.0100, tau = 0.48, J = 0.55, K = -3.10
Corrected K = -0.82
th1_infty_2 = 21.883796841 [ 21.38563992  21.5474959   21.71348425          nan]
alpha_infty_2 = [ 22.28809581  22.282792            nan          nan]
ymax = 0.222253141397
crw-tail-check-00100.pdf
th1_infty = 51.1601363953 [ 50.51058359  50.7257642   50.94227512          nan]
alpha_infty = [ 51.4864857   51.48419607          nan          nan]
gradient: 0.676799464889 [ 0.66232692  0.66638587  0.67050565         nan]
Original tail parameters:
beta = 0.1000, tau = 1.24, J = 0.68, K = -1.08
Corrected K = -0.38
th1_infty_2 = 47.7298385983 [ 47.26845601  47.42126366  47.57505055          nan]
alpha_infty_2 = [ 48.06411049  48.06226863          nan          nan]
ymax = 0.398195326879
crw-tail-check-01000.pdf
th1_infty = 68.5292896045 [ 67.86000858  68.08250879  68.30560068          nan]
alpha_infty = [ 68.81021572  68.80918358          nan          nan]
gradient: 0.801750605332 [ 0.79432177  0.79642071  0.79853859         nan]
Original tail parameters:
beta = 0.3000, tau = 2.54, J = 0.80, K = -0.45
Corrected K = -0.23
th1_infty_2 = 66.8633828798 [ 66.36625491  66.53187638  66.6975825           nan]
alpha_infty_2 = [ 67.14883646  67.14756687          nan          nan]
ymax = 0.547191442464
crw-tail-check-03000.pdf
th1_infty = 77.4533975624 [ 76.77775218  77.00264735  77.22786175          nan]
alpha_infty = [ 77.71122642  77.71068084          nan          nan]
gradient: 0.878168607082 [ 0.87381418  0.87504776  0.87628982         nan]
Original tail parameters:
beta = 0.5000, tau = 4.49, J = 0.88, K = -0.22
Corrected K = -0.14
th1_infty_2 = 76.7601773186 [ 76.21277743  76.39558226  76.57804553          nan]
alpha_infty_2 = [ 77.02065833  77.01949975          nan          nan]
ymax = 0.638539865345
crw-tail-check-05000.pdf
#+end_example

Comparison of empirically derived K' with the analytic K values:

|   beta |  tau |    J |      K |    K' |  K'/K | J (1 + beta) / 2 |
|--------+------+------+--------+-------+-------+------------------|
| 0.0001 | 0.10 | 0.50 | -15.26 | -3.60 | 0.236 |            0.250 |
|  0.001 | 0.21 | 0.51 |  -7.02 | -1.73 | 0.246 |            0.255 |
|   0.01 | 0.48 | 0.55 |  -3.10 | -0.82 | 0.265 |            0.278 |
|    0.1 | 1.24 | 0.68 |  -1.08 | -0.38 | 0.352 |            0.374 |
|    0.3 | 2.54 | 0.80 |  -0.45 | -0.23 | 0.511 |            0.520 |
|    0.5 | 4.49 | 0.88 |  -0.22 | -0.14 | 0.636 |            0.660 |
#+TBLFM: $6=$-1/$-2;f3::$7=0.5 $3 (1 + $1);f3

beta = 0.0001, tau = 0.10, J = 0.50, K = -15.26
Corrected K = -3.60
beta = 0.0010, tau = 0.21, J = 0.51, K = -7.02
Corrected K = -1.73
beta = 0.0100, tau = 0.48, J = 0.55, K = -3.10
Corrected K = -0.82


* TODO [4/5] Joining the head and tail conics
+ Revisiting this after summer break [2016-08-23 Tue]
+ [X] Seems to be working for CRW case, so log as head quadric is hyperbola
+ [X] Need to track down error for when head quadric is ellipse
+ [X] *CANCELLED* And need to find \(\phi_{}_{}_{}_{}_{}_{}_{}_{1}/\phi_{}\) for the general-k case
+ [X] Finally, we need to look at using alternative join points
  + Such as x=0, since derivative there is discontinuous anyway
  + We could try using max(x_m, 0), since when x_m < 0 (corresponding to approx \beta < 0.1) then the head quadric is not a good approximation anymore at x_m.  But it still seems OK back to x = 0.
+ [-] Comments from git commit message [2016-08-31 Wed]
  + I went on a long wild goose chase with trying to use the asymptotic espansion as theta -> theta_\infty, but that turned out to be a waste of time
  + I am now back to matching the gradients and values, and that works well for larger beta, but becomes inaccurate at small beta since it is trying to match at a point where the head quadric is no longer a good fit
  + [X] The next plan is to abandon the use of even the linear term in the phi_1(phi) expansion, which gives us back an extra degree of freedom. We can use that to match both y and dy/dx at a fixed x (instead of letting x float, as we have been doing).  I will try doing it at x=0 for the low beta cases
  + [ ] We also need to include the variable-k case.  But this should be easy if we are not doing the phi_1(phi) expansion any more
    + This requires generalising the conic that we plot too
    + And means that the name =crw-conic-head-tail.p= is now a misnomer





#+BEGIN_SRC python :eval no :tangle conic-head-tail.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import equation6
  import conic_parameters
  sys.path.append('../conic-projection')
  from conproj_utils import Conic

  try:
      XMIN_PARAMETER = float(sys.argv[1])
  except IndexError:
      XMIN_PARAMETER = -1.0

  try:
      XI_PARAMETER = float(sys.argv[2])
      suffix = '-xi{:03d}'.format(int(100*XI_PARAMETER))
  except IndexError:
      XI_PARAMETER = None
      suffix = '-crw'


  def R_from_theta(theta, beta, xi=None):
      if xi is None:
          shell = equation6.Shell(innertype='isotropic', beta=beta)
      else:
          shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
      R = shell.radius(theta)
      return R/shell.R0

  betagrid = [3e-5, 1e-4, 0.001, 0.003, 0.01, 0.03, 0.1, 0.5]
  nbeta = len(betagrid)

  ntheta = 100
  theta = np.linspace(0.0, np.pi, ntheta)

  figfilename = sys.argv[0].replace('.py', suffix + '.pdf')

  sns.set_style('whitegrid')
  sns.set_color_codes('dark')

  NROWS = 2
  fig, axes = plt.subplots(NROWS, nbeta//NROWS, sharex=True, sharey=True)

  xmin, xmax = -5.0, 2.1
  ymin, ymax = -0.1, 7.0
  # xmin, xmax = -7.0, 4.1
  # ymin, ymax = -0.1, 11.0

  ytop = ymin + 0.98*(ymax - ymin)
  xright = xmin + 0.98*(xmax - xmin)
  whitebox = {'edgecolor': 'none', 'facecolor': 'white',
              'alpha': 0.7, 'boxstyle': 'round,pad=0.1'}


  # x-data for tail asymptote
  xa = np.linspace(xmin, xmax, 2)

  for i, beta in enumerate(betagrid):
      ax = axes.flat[i]

      # The exact solution to the bow
      R_crw = R_from_theta(theta, beta, xi=XI_PARAMETER)
      x_crw = R_crw*np.cos(theta)
      y_crw = R_crw*np.sin(theta)

      ht = conic_parameters.HeadTail(beta, xi=XI_PARAMETER, xmin=XMIN_PARAMETER)

      x_head = ht.x_head(ht.t_h)
      y_head = ht.y_head(ht.t_h)

      x_tail = ht.x_tail(ht.t_t)
      y_tail = ht.y_tail(ht.t_t)

      # asymptote to tail
      ya = (ht.x0_t - xa)*np.tan(ht.theta_t)
      #ax.plot(xa, ya, lw=0.3, color='orange')

      ax.plot(x_crw, y_crw, lw=4, color='y', alpha=0.7)
      ax.plot(x_head, y_head, '--', color='g')
      ax.plot(x_tail, y_tail, '-', dashes=[8, 4, 2, 4], color='r')
      ax.plot(0.0, 0.0, 'o', color='k')
      ax.plot(ht.x0_t - ht.a_t, 0.0, '.', color='k')
      ax.axhline(ls=':')
      ax.axvline(ls=':')
      ax.axvline(x=ht.x_m, lw=1.0, ls='--', color='black', alpha=0.3)
      ax.set_aspect('equal', adjustable='box-forced')
      text = r'$\beta = {:.5f}$ '.format(beta)
      text += '\n' + r'$x_m = {:.2f}$ '.format(ht.x_m)
      text += '\n' + r'$x_t = {:.2f}$ '.format(ht.x0_t)
      text += '\n' + r'$x_t - a_t = {:.2f}$ '.format(ht.x0_t - ht.a_t)
      text += '\n' + r'$x_h = {:.2f}$ '.format(ht.x0_h)
      text += '\n' + r"$J = {:.2f}$ ".format(ht.J)
      # text += '\n' + r"$K = {:.2f}$ ".format(ht.K)
      text += '\n' + r"$\theta_h = {:.2f}$ ".format(np.degrees(ht.theta_h))
      text += '\n' + r"$\theta_t = {:.2f}$ ".format(np.degrees(-ht.theta_t))
      ax.text(xright, ytop, text, ha='right', va='top', bbox=whitebox, fontsize='small')


  axes[1, 0].set_xlim(xmin, xmax)
  axes[1, 0].set_ylim(ymin, ymax)
  axes[1, 0].set_xlabel(r'$x / r_{0}$')
  axes[1, 0].set_ylabel(r'$y / r_{0}$')

  fig.set_size_inches(3*nbeta/NROWS, 3*NROWS)
  fig.tight_layout()
  fig.savefig(figfilename)
  print(figfilename)
 



#+END_SRC

#+BEGIN_SRC sh :results file
python conic-head-tail.py -0.8
#+END_SRC

#+RESULTS:
[[file:conic-head-tail-crw.pdf]]

#+BEGIN_SRC sh :results file
python conic-head-tail.py -2.5 1.0
#+END_SRC

#+RESULTS:
[[file:conic-head-tail-xi100.pdf]]


#+BEGIN_SRC sh :results file
python conic-head-tail.py -0.75 0.8
#+END_SRC

#+RESULTS:
[[file:conic-head-tail-xi080.pdf]]

#+BEGIN_SRC sh :results file
python conic-head-tail.py 0.0 0.4
#+END_SRC

#+RESULTS:
[[file:conic-head-tail-xi040.pdf]]

#+BEGIN_SRC sh :results file
python conic-head-tail.py 0.15 0.2
#+END_SRC

#+RESULTS:
[[file:conic-head-tail-xi020.pdf]]


** 

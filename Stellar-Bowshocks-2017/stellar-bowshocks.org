* Bowshocks around moving OB and RSG stars
** Nature of arcs around O stars
+ There is some question whether they are really bow shocks, or are instead dust waves.
  + Example of the latter is 
** Previous work on theory of projected shapes
*** Cox et al 2012
+ Have a reasonably sane discussion of the projection of the /Wilkinoid/ shape
+ Consider R_0 and R_90
+ 
** Observations of O star bow shocks 
+ Use Kubulnicky (2016), who have 709 objects!
+ Best observations are 24 micron Spitzer MIPSGAL images
*** Catalog of Kobulnicky bow shocks 
+ [[file:OB/Kobulnicky2016/table1.dat]]
*** How to get the images of OB bow shocks
+ Loop through the table and do searches on the coordinates
  + Follow the API described at http://irsa.ipac.caltech.edu/applications/Atlas/AtlasProgramInterface.html
  + The example given for MIPSGAL is
    + http://irsa.ipac.caltech.edu/cgi-bin/Atlas/nph-atlas?mission=MIPSGAL&locstr=NGC+6631&regSize=12.5&covers=on&mode=PI
    + But we would be best off using coordinates
    + As in =&locstr=17h18m57s+60d21m12s=
  + We could probably use the =requests= python library for that
    + It looks very easy to use
    + Relevant example code from the [[http://docs.python-requests.org/en/master/user/quickstart/][documentation]]
      #+BEGIN_SRC python
        payload = {'key1': 'value1', 'key2': 'value2'}
        r = requests.get('http://httpbin.org/get', params=payload)
      #+END_SRC
  + This gives an XML file that will contain a line like this
    #+BEGIN_SRC xml
      <result status="ok">
      <description>
      <collection>MIPSGAL</collection>
      <ra>276.813000</ra>
      <dec>-12.020000</dec>
      <regSize>12.500000</regSize>
      <radius>6.250000</radius>
      <radunits>degrees</radunits>
      </description>
      <coverageMap>
      <resultHtml>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/index.html
      </resultHtml>
      <resultMap>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/region.jpg
      </resultMap>
      <resultFits>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/background_IRAS_ISSA_12micron.fits
      </resultFits>
      </coverageMap>
      <summary>
      <counts>
      <imagesN>12</imagesN>
      <sourcesN>0</sourcesN>
      <spectraN>0</spectraN>
      </counts>
      <downloadScript>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/wget_data.bat
      </downloadScript>
      <dataTag>ADS/IRSA.Atlas#2017/0303/205546_3307</dataTag>
      </summary>
      <images>
      <counts>12</counts>
      <metadata>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/images.tbl
      </metadata>
      <metadataVOtable>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/images.xml
      </metadataVOtable>
      </images>
      </result>
    #+END_SRC
  + Then you can grab for example the =wwget_data.bat= file
    + Although the url is bad, since it should be https instead of http
  + And that will give you something like this
    #+BEGIN_SRC sh 
      #!/bin/sh
      #
      # To run as an executable on a unix platform, do the following:
      # chmod 775 wget_data.bat
      # ./wget_data.bat
      #
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/compcubes/MG0200n005_024_compcube.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/compcubes/MG0190n005_024_compcube.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/residual/residual_MG0190n005_024_all.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/residual/residual_MG0200n005_024_all.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_maskcube_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_maskcube_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_std_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_std_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_covg_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_covg_024.fits"

    #+END_SRC
  + Alternatively, the images.xml table has the list of FITS images and associated metadata as a VOTable
  + Or the images.tbl has it as a simple table
  + Either should be readable with astropy
**** Download all the MIPS 24 micron images
#+BEGIN_SRC sh
mkdir -pv OB/MipsGal
#+END_SRC


#+BEGIN_SRC python :eval no :tangle mipsgal-image-stamps.py
  import os
  import sys
  import requests
  import xmltodict
  import numpy as np
  from astropy.table import Table
  from astropy.io import fits
  from astropy.wcs import WCS
  import astropy.units as u
  import astropy.coordinates as coord

  SST_URL = 'http://irsa.ipac.caltech.edu/cgi-bin/Atlas/nph-atlas'
  mipsgal_params = {
      'mission': 'MIPSGAL',
      'mode': 'PI',
      'regSize': '0.01',
      'covers': 'on',
  }
  IMG_URL_ROOT = 'https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL'

  SOURCE_DIR = 'OB/Kobulnicky2016'
  source_table = Table.read(
      os.path.join(SOURCE_DIR, 'table1.dat'),
      format='ascii.cds',
      readme=os.path.join(SOURCE_DIR, 'ReadMe')
  )

  OUTPUT_IMAGE_DIR = 'OB/MipsGal'
  IMAGE_SIZE_DEGREES = 4.0/60.0           

  def skycoord_from_table_row(data):
      ra = f"{data['RAh']} {data['RAm']} {data['RAs']}"
      dec = f"{data['DE-']}{data['DEd']} {data['DEm']} {data['DEs']}"
      return coord.SkyCoord(f'{ra} {dec}', unit=(u.hourangle, u.deg))

  try:
      k1 = int(sys.argv[1])
  except:
      k1 = None
  try:
      k2 = int(sys.argv[2])
  except:
      k2 = None

  # Loop over all sources in the table
  for source_data in source_table[k1:k2]:
      # Make a SkyCoord object
      c = skycoord_from_table_row(source_data)
      # Perform a search around the specified coordinates
      r = requests.get(SST_URL,
                       params={**mipsgal_params, 'locstr': c.to_string()})

      # Extract the URL of the table of images (if present)
      try:
          img_tbl_url = xmltodict.parse(r.content)['result']['images']['metadata']
      except KeyError:
          # Probably a source without Spitzer observations
          continue
      # Need to switch to https and grab the file
      r2 = requests.get(img_tbl_url.replace('http:', 'https:'))
      # We need to remove the first line from the table so that it can be parsed
      table_lines = r2.content.decode().split('\n')[1:]
      # Then read it in as another astropy table
      img_table = Table.read(table_lines, format='ascii')

      # Select out all the images that are mosaic science images
      mosaic_images = {}
      for img_row in img_table:
          fname = img_row['fname']
          m_id = fname.split('/')[-1].split('_')[0]
          if img_row['file_type'] == 'science' and 'mosaics24' in fname:
              mosaic_images[m_id] = os.path.join(IMG_URL_ROOT, fname)

      # Now make postage stamps of all the selected images
      for m_id in mosaic_images:
          hdu = fits.open(mosaic_images[m_id])[0]
          w = WCS(hdu)
          # pixel coord of source
          i0, j0 = np.round(c.to_pixel(w))
          # find pixel limits of cut-out image window around source
          xpix_scale, ypix_scale = np.abs(w.wcs.cdelt)
          di = np.round(0.5*IMAGE_SIZE_DEGREES/xpix_scale)
          dj = np.round(0.5*IMAGE_SIZE_DEGREES/ypix_scale)
          win = slice(int(j0 - dj), int(j0 + dj)), slice(int(i0 - di), int(i0 + di))
          # Construct a new HDU
          hdr_win = w.slice(win).to_header()
          for k in 'Seq', 'Name', 'R0', 'PA':
              hdr_win[k] = source_data[k]
          hdr_win['MIPSGAL'] = m_id
          hdr_win['ORIGURL'] = mosaic_images[m_id]
          imwin = fits.PrimaryHDU(
              data=hdu.data[win],
              header=hdr_win)
          # Construct a suitable file name
          imid = f"{source_data['Seq']:04d}-{source_data['Name']}-{m_id}"
          imfn = os.path.join(OUTPUT_IMAGE_DIR, f'{imid}.fits')
          imwin.writeto(imfn, overwrite=True)
#+END_SRC
*** How to trace the shapes of the OB bow shocks
+ Strategy is to start at the nominal PA of the bowshock axis and take radial slices
  + Maybe fit a Gaussian brightness as function of radius for each \theta
  + calculate \theta and R for each pixel
  + use \theta \pm d\theta/2 to construct a mask over all the pixels
  + where d\theta is the interval between radii
    + say, d\theta = 5\deg perhaps
+ We can stop when we have got to \pm45\deg or maybe \pm60\deg and then calculate the radius of curvature and a better estimate for the symmetry axis
  + Then we do it again, but with radii drawn from the center of curvature that we have just determined
  + We can call this angle \theta_c
  + The idea is that we are best off taking slices that are close to normal to the bowshock, so that we can get out to \theta = \pm 90\deg if we are lucky
+ [ ] Note that at some point I might want to use "sky offset" frames - see documentation for =astropy.coordinates=
#+BEGIN_SRC python :eval no :tangle mipsgal-trace-arc.py
  import glob
  import os
  import numpy as np
  from astropy.table import Table
  from astropy.io import fits
  from astropy.wcs import WCS
  import astropy.units as u
  import astropy.coordinates as coord
  from matplotlib import pyplot as plt
  import seaborn as sns

  sns.set_style('white')


  SOURCE_DIR = 'OB/Kobulnicky2016'
  source_table = Table.read(
      os.path.join(SOURCE_DIR, 'table1.dat'),
      format='ascii.cds',
      readme=os.path.join(SOURCE_DIR, 'ReadMe')
  )

  IMAGE_DIR = 'OB/MipsGal'

  def skycoord_from_table_row(data):
      ra = f"{data['RAh']} {data['RAm']} {data['RAs']}"
      dec = f"{data['DE-']}{data['DEd']} {data['DEm']} {data['DEs']}"
      return coord.SkyCoord(f'{ra} {dec}', unit=(u.hourangle, u.deg))

  for source_data in source_table[0:10]:
      # Coordinates of source central star
      c = skycoord_from_table_row(source_data)
      # Find all the images for this source
      provisional_list = glob.glob(
          f"{IMAGE_DIR}/*-{source_data['Name']}-*.fits")
      # Look for an image that is good
      good_image_list = []
      for image_name in provisional_list:
          hdu, = fits.open(image_name)
          looks_good = hdu.header['NAXIS1'] == hdu.header['NAXIS2']
          if looks_good:
              good_image_list.append(image_name)

      if good_image_list:
          # Use the first one in the list - because: why not? 
          hdu, = fits.open(good_image_list[0])
      else:
          # If there were no good images, then never mind
          continue

      # Create WCS object for this image
      w = WCS(hdu)
      # Find celestial coordinates for each pixel
      ny, nx = hdu.data.shape
      xpix = np.arange(nx)[None, :]
      ypix = np.arange(ny)[:, None]
      cpix = coord.SkyCoord.from_pixel(xpix, ypix, w)
      # Now find radius and position angle from source
      rpix = c.separation(cpix).to(u.arcsec)
      pa_pix = c.position_angle(cpix).to(u.degree)
      # Nominal PA of bowshock axis from table
      pa0 = coord.Angle(source_data['PA'], unit=u.degree)
      # theta is angle from nominal axis, set to range [-180:180]
      theta_pix = coord.Longitude(pa_pix - pa0, wrap_angle=180*u.degree)

      # Also create an offset frame in case we need it later, in which
      # measurements are with respect to the central source coordinate,
      # and rotated by pa0
      offset_frame = c.skyoffset_frame(rotation=pa0)
      # Coordinates of each pixel in the offset frame - this has
      # components: offset_pix.lat (along pa0) and offset_pix.lon
      # (perpendicular to pa0)
      offset_pix = cpix.transform_to(offset_frame)

      # Nominal arc radius from source table
      R0 = source_data['R0']*u.arcsec
      # Only look in a restricted range of radius around R0
      rad_mask = (rpix > 0.1*R0) & (rpix < 3.0*R0)

      # Minimum and median brightness, which we might need later
      bright_min = np.nanmin(hdu.data)
      bright_median = np.nanmedian(hdu.data)

      # Next, a two step process to trace the arc.  First step is just
      # to find center and radius of curvature

      # Loop over a grid of angles between +/- 60 degrees
      ntheta = 25
      theta_grid, dtheta = np.linspace(-120.0, 120.0, ntheta, retstep=True)
      # Make everything be a longitude in range [-180:180]
      theta_grid = coord.Longitude(theta_grid, unit=u.degree, wrap_angle=180*u.degree)
      dtheta = coord.Longitude(dtheta, unit=u.degree, wrap_angle=180*u.degree)
      rpeak_grid = []
      rmean_grid = []
      bmax_grid = []
      bmean_grid = []
      for theta in theta_grid:
          # Select only pixels in the wedge within +/- dtheta/2 of this theta
          theta_mask = np.abs(theta_pix - theta) < 0.5*dtheta
          # Combine with the radius mask
          m = theta_mask & rad_mask

          if np.alltrue(~m):
              # If mask is empty, fill in this theta with NaNs
              rpeak = np.nan*u.deg
              rmean = np.nan*u.deg
              bright_max = np.nan
              bmean = np.nan
          else:            
              # Try a variety of methods for determining the arc radius
              # at this theta ...

              # Peak brightness
              ipeak = hdu.data[m].argmax()
              rpeak = rpix[m][ipeak]

              # Mean brightness-weighted radius. We divide weights by
              # radius to compensate for density of pixels. Also, we
              # select only points brighter than 0.5 times the peak
              # brightness in this wedge.  And all brightnesses are
              # relative to a background floor, which is either the
              # median over the whole image or, if the peak in the wedge
              # is lower than that, then the minimum over the image
              bright_max = hdu.data[m].max()
              bright_floor = bright_median if bright_max > bright_median else bright_min
              mb = (hdu.data - bright_floor) > 0.5*(bright_max - bright_floor)
              weights = (hdu.data[m & mb] - bright_floor)/rpix[m & mb]
              rmean = np.average(rpix[m & mb], weights=weights)*u.arcsec
              bmean = np.average(hdu.data[m & mb], weights=weights)

          # Fit Gaussian to profile - TODO?

          # Save all quantities into grid lists
          rmean_grid.append(rmean)
          rpeak_grid.append(rpeak)
          bmax_grid.append(bright_max)
          bmean_grid.append(bmean)

      # convert to single array of each quantity
      rmean_grid = coord.Angle(rmean_grid)
      rpeak_grid = coord.Angle(rpeak_grid)
      bmax_grid = np.array(bmax_grid)
      bmean_grid = np.array(bmean_grid)

      # Save a figure for each source
      fig = plt.figure(figsize=(10, 8))
      # Make a plot of the radii and brightnesses versus theta
      ax_r = plt.subplot(2, 2, 1)
      ax_i = plt.subplot(2, 2, 2, projection=w)
      ax_b = plt.subplot(2, 2, 3)
      ax_r.plot(theta_grid, rmean_grid, label='mean')
      ax_r.plot(theta_grid, rpeak_grid, label='peak')
      ax_r.axhline(R0.value)
      ax_r.legend()
      ax_r.set(ylim=[0.0, None], ylabel='Bow shock radius, arcsec')
      ax_b.plot(theta_grid, bmean_grid - bright_median, label='mean')
      ax_b.plot(theta_grid, bmax_grid - bright_median, label='peak')
      ax_b.legend()
      ax_b.set(ylim=[0.0, None], ylabel='Bow shock brightness',
               xlabel='Angle from nominal axis, degree'
      )

      # And also plot the image
      ax_i.imshow(hdu.data,
                  vmin=bright_min, vmax=bmean_grid.max(), origin='lower')

    
      fig.tight_layout()
      fig.savefig(image_name.replace('.fits', '-multiplot.png'))

#+END_SRC


*** Where the figures are suposed to be (but they aren't)
http://iopscience.iop.org/0067-0049/227/2/18/suppdata/
http://iopscience.iop.org/0067-0049/227/2/18/media

** Tracing the shapes
*** OB stars
*** RSG stars (and AGB)
:PROPERTIES:
:ID:       94EECFDB-B61E-4242-89C2-09BD3B36D587
:END:
**** \alpha Orionis (Betelgeuse)
+ Press release image
  + [[file:RSG/Betelgeuse_Herschel_large.jpg]]
  + http://herschel.cf.ac.uk/results/betelgeuse
+ Original data from http://archives.esac.esa.int/hsa/whsa/
  + Use the most processed version: https://www.cosmos.esa.int/web/herschel/user-provided-data-products
  + [[file:RSG/AlphaOri-160_10_AFGL190.mod.fits]]
+ Put crosses on to trace the outer arc
  + file:RSG/Betelgeuse_Herschel-arcs.reg
+ Fit circle to the arc

#+BEGIN_SRC sh :results verbatim
cd RSG
python ../../read-shapes-LL/find-xy-shell.py alphaori --pa0 45
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results verbatim
cd RSG
python ../../read-shapes-LL/fit-circle-shell.py alphaori --debug --thmax 75
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 115
    # variables        = 2
    chi-square         = 4833.978
    reduced chi-square = 42.779
    Akaike info crit   = 433.927
    Bayesian info crit = 439.417
[[Variables]]
    xc:  -136.600747 +/- 4.042615 (2.96%) (init=-328.3531)
    yc:  -68.7003769 +/- 2.189979 (3.19%) (init=-161.0606)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.788 
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 88.79302917,  7.40696111)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 88.75476522,  7.38787767)>
Separation star->center in arcsec:  152.90622356827168
sqrt(xc**2 + yc**2) =  152.903583849
#+end_example
**** Sources from Cox et al
+ From Fig 1, these look like good candidates
+ These are the ones that look like they will give a good chance of measuring R_c and R_90
  + Constitute 7 out of 22 "Type I" morphologies, which are the ones with bowshocks
  + So this is about 15% of the total sample
| Name      |       IRAS | Arc | PA (pm) | PA (R_0) |
|-----------+------------+-----+---------+---------|
| \alpha Ori     | 05524+0723 |  70 |    47.7 |      54 |
| UU Aur    | 06331+3829 |  70 |   170.4 |     200 |
| R Leo     | 09448+1139 |  70 |   112.3 |     117 |
| R Hya     | 13269-2301 |  70 |   313.7 |     284 |
| V1943 Sgr | 20038-2722 | 160 |     155 |     135 |
| X Pav     | 20075-6005 |  70 |    84.9 |      88 |
| \mu Cep     | 21419+5832 |  70 |   216.3 |      85 |
+ Position angles:
  + The PA (pm) column is the PA from proper motion
  + The PA (R_0) column is \theta in Cox et al table, which is PA of measured R_0
  + They are roughly similar, except for in \mu Cep
+ Arc tracing
  + Done at 70 micron in most of them, since higher resolution and arc is generally more prominent
  + Exception is V1943 Sgr, which was better at 160 micron because the arc is incomplete (and smaller radius) in 70 micron

#+BEGIN_SRC sh :results verbatim
cd RSG
D=../../read-shapes-LL
python $D/find-xy-shell.py uuaur --pa0 200
python $D/find-xy-shell.py rleo --pa0 120
python $D/find-xy-shell.py rhya --pa0 280
python $D/find-xy-shell.py v1943sgr --pa0 135
python $D/find-xy-shell.py xpav --pa0 90
python $D/find-xy-shell.py mucep --pa0 90
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results verbatim
cd RSG
D=../../read-shapes-LL
python $D/fit-circle-shell.py uuaur --debug --thmax 75 --savefig
python $D/fit-circle-shell.py rleo --debug --thmax 75 --savefig
python $D/fit-circle-shell.py rhya --debug --thmax 75 --savefig
python $D/fit-circle-shell.py v1943sgr --debug --thmax 75 --savefig
python $D/fit-circle-shell.py xpav --debug --thmax 75 --savefig
python $D/fit-circle-shell.py mucep --debug --thmax 75 --savefig
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 32
    # variables        = 2
    chi-square         = 42.236
    reduced chi-square = 1.408
    Akaike info crit   = 12.881
    Bayesian info crit = 15.813
[[Variables]]
    xc:   15.0610640 +/- 1.100570 (7.31%) (init= 63.51735)
    yc:   25.5300293 +/- 0.918767 (3.60%) (init= 52.16668)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.851 
outer : 15.0610640641 25.5300293379 111.870661618
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 99.13680833,  38.44531944)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 99.14215003,  38.45241112)>
Separation star->center in arcsec:  29.641116012318466
sqrt(xc**2 + yc**2) =  29.6414920126
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 27
    # variables        = 2
    chi-square         = 104.474
    reduced chi-square = 4.179
    Akaike info crit   = 40.534
    Bayesian info crit = 43.125
[[Variables]]
    xc:  -33.3846142 +/- 2.578846 (7.72%) (init=-86.3434)
    yc:   9.37818363 +/- 1.079356 (11.51%) (init= 26.9824)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.698 
outer : -33.3846142656 9.37818363087 126.756157072
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 146.88944583,  11.42896667)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 146.87998473,  11.43157172)>
Separation star->center in arcsec:  34.67668601017268
sqrt(xc**2 + yc**2) =  34.6768337349
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 24
    # variables        = 2
    chi-square         = 609.197
    reduced chi-square = 27.691
    Akaike info crit   = 81.618
    Bayesian info crit = 83.974
[[Variables]]
    xc:   110.175601 +/- 10.67015 (9.68%) (init= 90.24736)
    yc:  -23.0858829 +/- 6.627401 (28.71%) (init=-55.71501)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.895 
outer : 110.175601373 -23.0858829412 213.540750481
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.4279125, -23.28110833)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.46122962, -23.28752108)>
Separation star->center in arcsec:  112.56569836972328
sqrt(xc**2 + yc**2) =  112.568295399
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 11
    # variables        = 2
    chi-square         = 17.864
    reduced chi-square = 1.985
    Akaike info crit   = 9.334
    Bayesian info crit = 10.129
[[Variables]]
    xc:  -9.68883170 +/- 1.643640 (16.96%) (init=-38.86762)
    yc:   14.9640406 +/- 1.958355 (13.09%) (init= 50.65795)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.827 
outer : -9.68883170818 14.9640406645 83.2641253433
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 301.73027917, -27.22538889)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 301.72725251, -27.22123221)>
Separation star->center in arcsec:  17.826931215089093
sqrt(xc**2 + yc**2) =  17.8268329459
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 23
    # variables        = 2
    chi-square         = 11.868
    reduced chi-square = 0.565
    Akaike info crit   = -11.218
    Bayesian info crit = -8.947
[[Variables]]
    xc:  -22.2929159 +/- 1.108003 (4.97%) (init=-54.10835)
    yc:  -4.27263268 +/- 0.341913 (8.00%) (init=-10.72157)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.477 
outer : -22.2929159036 -4.27263268094 78.6385241074
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 302.94182917, -59.9371)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 302.92946771, -59.93828684)>
Separation star->center in arcsec:  22.698275321362722
sqrt(xc**2 + yc**2) =  22.6986671307
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 23
    # variables        = 2
    chi-square         = 143.971
    reduced chi-square = 6.856
    Akaike info crit   = 46.185
    Bayesian info crit = 48.456
[[Variables]]
    xc:  -29.4220193 +/- 3.508065 (11.92%) (init=-69.01557)
    yc:   8.35037470 +/- 1.062646 (12.73%) (init=-12.28705)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.392 
outer : -29.4220192961 8.35037470152 102.964786609
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 325.8768,  58.78037778)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 325.86103216,  58.78269733)>
Separation star->center in arcsec:  30.583102380367688
sqrt(xc**2 + yc**2) =  30.5840477556
#+end_example

R Hya looks like it would be better with --thmax 45
#+BEGIN_SRC sh :results verbatim
cd RSG
D=../../read-shapes-LL
python $D/fit-circle-shell.py rhya --debug --thmax 45 --savefig
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 14
    # variables        = 2
    chi-square         = 26.774
    reduced chi-square = 2.231
    Akaike info crit   = 13.077
    Bayesian info crit = 14.355
[[Variables]]
    xc:   58.4657628 +/- 8.404392 (14.37%) (init= 90.24736)
    yc:  -15.0097612 +/- 4.656127 (31.02%) (init=-55.71501)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.950 
outer : 58.4657628622 -15.0097612186 166.101863129
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.4279125, -23.28110833)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.44559256, -23.28527771)>
Separation star->center in arcsec:  60.36084260447921
sqrt(xc**2 + yc**2) =  60.361729257
#+end_example

* Convert images to FITS
+ This has not been necessary yet, but may be needed for the O star arcs
#+BEGIN_SRC sh
python ~/Work/Image2FITS/image2fits.py RSG/Betelgeuse_Herschel_large.jpg
#+END_SRC

#+RESULTS:


* DONE Testing the angle functions in =find-xy-shell.py=
CLOSED: [2017-02-28 Tue 10:28]
+ There was a problem with the order of angles in \alpha Ori
  + Turns out it was simply due to failing to convert input degrees to radians for internal use
  + *Fixed* [2017-02-28 Tue]
+ This is the function that is used for sorting the angles:
#+name: find-th-order
#+BEGIN_SRC python
import numpy as np
def canonicalize(th, unit="radians"):
    """Fold an angle theta into the canonical range [-pi:pi]"""
    if unit == "radians":
        return ((th + np.pi) % (2*np.pi)) - np.pi
    elif unit == "degrees":
        return ((th + 180.0) % (360.0)) - 180.0
    else:
        raise NotImplementedError

def find_th_order(th, pa_ref, debug=True): 
    """Returns a sort order for a collection of angles theta
    
    Takes care to account for the wrap-around of angles by shifting
    the star-th1C vector to be at pi, so that all points are (with
    luck) in the range [0, 2 pi]

    """
    th1 = (canonicalize(th - pa_ref) + np.pi) % (2*np.pi)
    if debug: 
        print("Finding theta order:") 
        print("    th =", np.degrees(th)) 
        print("    pa_ref =", np.degrees(pa_ref)) 
        print("    th1 =", np.degrees(th1)) 
        print("    order =", th1.argsort()) 
    return th1.argsort()
#+END_SRC


#+BEGIN_SRC python :noweb yes :results output verbatim
<<find-th-order>>
th0 = np.radians(45.0)
th = np.radians([180, 45, 15, 90, 120, 310])
order = find_th_order(th, pa_ref=th0)

print(np.degrees(th[order]))
print(np.degrees(canonicalize(th[order] - th0)))

#+END_SRC

#+RESULTS:
: Finding theta order:
:     th = [ 180.   45.   15.   90.  120.  310.]
:     pa_ref = 45.0
:     th1 = [ 315.  180.  150.  225.  255.   85.]
:     order = [5 2 1 3 4 0]
: [ 310.   15.   45.   90.  120.  180.]
: [ -95.  -30.    0.   45.   75.  135.]


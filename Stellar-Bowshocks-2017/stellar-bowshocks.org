* Bowshocks around moving OB and RSG stars
** Nature of arcs around O stars
+ There is some question whether they are really bow shocks, or are instead dust waves.
  + Example of the latter is 
** Previous work on theory of projected shapes
*** Cox et al 2012
+ Have a reasonably sane discussion of the projection of the /Wilkinoid/ shape
+ Consider R_0 and R_90
+ 
** Observations of O star bow shocks 
+ Use Kubulnicky (2016), who have 709 objects!
+ Best observations are 24 micron Spitzer MIPSGAL images
*** Catalog of Kobulnicky bow shocks 
+ [[file:OB/Kobulnicky2016/table1.dat]]
*** How to get the images of OB bow shocks
+ Loop through the table and do searches on the coordinates
  + Follow the API described at http://irsa.ipac.caltech.edu/applications/Atlas/AtlasProgramInterface.html
  + The example given for MIPSGAL is
    + http://irsa.ipac.caltech.edu/cgi-bin/Atlas/nph-atlas?mission=MIPSGAL&locstr=NGC+6631&regSize=12.5&covers=on&mode=PI
    + But we would be best off using coordinates
    + As in =&locstr=17h18m57s+60d21m12s=
  + We could probably use the =requests= python library for that
    + It looks very easy to use
    + Relevant example code from the [[http://docs.python-requests.org/en/master/user/quickstart/][documentation]]
      #+BEGIN_SRC python
        payload = {'key1': 'value1', 'key2': 'value2'}
        r = requests.get('http://httpbin.org/get', params=payload)
      #+END_SRC
  + This gives an XML file that will contain a line like this
    #+BEGIN_SRC xml
      <result status="ok">
      <description>
      <collection>MIPSGAL</collection>
      <ra>276.813000</ra>
      <dec>-12.020000</dec>
      <regSize>12.500000</regSize>
      <radius>6.250000</radius>
      <radunits>degrees</radunits>
      </description>
      <coverageMap>
      <resultHtml>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/index.html
      </resultHtml>
      <resultMap>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/region.jpg
      </resultMap>
      <resultFits>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/background_IRAS_ISSA_12micron.fits
      </resultFits>
      </coverageMap>
      <summary>
      <counts>
      <imagesN>12</imagesN>
      <sourcesN>0</sourcesN>
      <spectraN>0</spectraN>
      </counts>
      <downloadScript>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/wget_data.bat
      </downloadScript>
      <dataTag>ADS/IRSA.Atlas#2017/0303/205546_3307</dataTag>
      </summary>
      <images>
      <counts>12</counts>
      <metadata>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/images.tbl
      </metadata>
      <metadataVOtable>
      http://irsa.ipac.caltech.edu:443/workspace/TMP_KlWKfI_2014/Atlas/NGC__6631_3307.v0001/images.xml
      </metadataVOtable>
      </images>
      </result>
    #+END_SRC
  + Then you can grab for example the =wwget_data.bat= file
    + Although the url is bad, since it should be https instead of http
  + And that will give you something like this
    #+BEGIN_SRC sh 
      #!/bin/sh
      #
      # To run as an executable on a unix platform, do the following:
      # chmod 775 wget_data.bat
      # ./wget_data.bat
      #
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/compcubes/MG0200n005_024_compcube.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/compcubes/MG0190n005_024_compcube.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/residual/residual_MG0190n005_024_all.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/residual/residual_MG0200n005_024_all.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_maskcube_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_maskcube_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_std_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_std_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0190n005_covg_024.fits"
      wget -x "https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL/images/mosaics24/MG0200n005_covg_024.fits"

    #+END_SRC
  + Alternatively, the images.xml table has the list of FITS images and associated metadata as a VOTable
  + Or the images.tbl has it as a simple table
  + Either should be readable with astropy
**** Download all the MIPS 24 micron images
#+BEGIN_SRC sh
mkdir -pv OB/MipsGal
#+END_SRC


#+BEGIN_SRC python :eval no :tangle mipsgal-image-stamps.py
  import os
  import sys
  import requests
  import xmltodict
  import numpy as np
  from astropy.table import Table
  from astropy.io import fits
  from astropy.wcs import WCS
  import astropy.units as u
  import astropy.coordinates as coord

  SST_URL = 'http://irsa.ipac.caltech.edu/cgi-bin/Atlas/nph-atlas'
  mipsgal_params = {
      'mission': 'MIPSGAL',
      'mode': 'PI',
      'regSize': '0.01',
      'covers': 'on',
  }
  IMG_URL_ROOT = 'https://irsa.ipac.caltech.edu:443/data/SPITZER/MIPSGAL'

  SOURCE_DIR = 'OB/Kobulnicky2016'
  source_table = Table.read(
      os.path.join(SOURCE_DIR, 'table1.dat'),
      format='ascii.cds',
      readme=os.path.join(SOURCE_DIR, 'ReadMe')
  )

  OUTPUT_IMAGE_DIR = 'OB/MipsGal'
  IMAGE_SIZE_DEGREES = 4.0/60.0           

  def skycoord_from_table_row(data):
      ra = f"{data['RAh']} {data['RAm']} {data['RAs']}"
      dec = f"{data['DE-']}{data['DEd']} {data['DEm']} {data['DEs']}"
      return coord.SkyCoord(f'{ra} {dec}', unit=(u.hourangle, u.deg))

  try:
      k1 = int(sys.argv[1])
  except:
      k1 = None
  try:
      k2 = int(sys.argv[2])
  except:
      k2 = None

  # Loop over all sources in the table
  for source_data in source_table[k1:k2]:
      # Make a SkyCoord object
      c = skycoord_from_table_row(source_data)
      # Perform a search around the specified coordinates
      r = requests.get(SST_URL,
                       params={**mipsgal_params, 'locstr': c.to_string()})

      # Extract the URL of the table of images (if present)
      try:
          img_tbl_url = xmltodict.parse(r.content)['result']['images']['metadata']
      except KeyError:
          # Probably a source without Spitzer observations
          continue
      # Need to switch to https and grab the file
      r2 = requests.get(img_tbl_url.replace('http:', 'https:'))
      # We need to remove the first line from the table so that it can be parsed
      table_lines = r2.content.decode().split('\n')[1:]
      # Then read it in as another astropy table
      img_table = Table.read(table_lines, format='ascii')

      # Select out all the images that are mosaic science images
      mosaic_images = {}
      for img_row in img_table:
          fname = img_row['fname']
          m_id = fname.split('/')[-1].split('_')[0]
          if img_row['file_type'] == 'science' and 'mosaics24' in fname:
              mosaic_images[m_id] = os.path.join(IMG_URL_ROOT, fname)

      # Now make postage stamps of all the selected images
      for m_id in mosaic_images:
          hdu = fits.open(mosaic_images[m_id])[0]
          w = WCS(hdu)
          # pixel coord of source
          i0, j0 = np.round(c.to_pixel(w))
          # find pixel limits of cut-out image window around source
          xpix_scale, ypix_scale = np.abs(w.wcs.cdelt)
          di = np.round(0.5*IMAGE_SIZE_DEGREES/xpix_scale)
          dj = np.round(0.5*IMAGE_SIZE_DEGREES/ypix_scale)
          win = slice(int(j0 - dj), int(j0 + dj)), slice(int(i0 - di), int(i0 + di))
          # Construct a new HDU
          hdr_win = w.slice(win).to_header()
          for k in 'Seq', 'Name', 'R0', 'PA':
              hdr_win[k] = source_data[k]
          hdr_win['MIPSGAL'] = m_id
          hdr_win['ORIGURL'] = mosaic_images[m_id]
          imwin = fits.PrimaryHDU(
              data=hdu.data[win],
              header=hdr_win)
          # Construct a suitable file name
          imid = f"{source_data['Seq']:04d}-{source_data['Name']}-{m_id}"
          imfn = os.path.join(OUTPUT_IMAGE_DIR, f'{imid}.fits')
          imwin.writeto(imfn, overwrite=True)
#+END_SRC
*** How to trace the shapes of the OB bow shocks
+ Strategy is to start at the nominal PA of the bowshock axis and take radial slices
  + Maybe fit a Gaussian brightness as function of radius for each \theta
  + calculate \theta and R for each pixel
  + use \theta \pm d\theta/2 to construct a mask over all the pixels
  + where d\theta is the interval between radii
    + say, d\theta = 5\deg perhaps
+ We can stop when we have got to \pm45\deg or maybe \pm60\deg and then calculate the radius of curvature and a better estimate for the symmetry axis
  + Then we do it again, but with radii drawn from the center of curvature that we have just determined
  + We can call this angle \theta_c
  + The idea is that we are best off taking slices that are close to normal to the bowshock, so that we can get out to \theta = \pm 90\deg if we are lucky
+ [X] Note that at some point I might want to use "sky offset" frames - see documentation for =astropy.coordinates=
+ [-] Improvements to make [2017-03-09 Thu]
  + [X] Add a vector to image to show nominal axis PA
  + [X] Indicate which cases have doubt about the central star
  + [X] Use the =OVERRIDE= dict for sources with bad data
  + [X] Try taking a longer step-back distance (maybe twice R0)
  + [X] Add the \pm90 vertical lines to the graphs
  + [ ] (/maybe/) Mask out the stars
    + Either detect point sources
    + Or, download the 8 micron images
  + [ ] Do the Rc and R90 fits
  + [ ] Deal with cases where the object dows not fit in the box:
    + 534, 542
+ List of the nicest sources
  + 595 - nice pointy wings
  + 509 - big flat thing
  + 530 - smaller pointy one
  + 634 - big cometary shape
  + 635 - flatter and big
  + 667 - nice curvy one
  + 677, 678 - these two overlap
#+BEGIN_SRC python :eval no :tangle mipsgal-trace-arc.py
  import glob
  import os
  from collections import OrderedDict
  import numpy as np
  from astropy.table import Table, QTable
  from astropy.io import fits
  from astropy.wcs import WCS
  import astropy.units as u
  import astropy.coordinates as coord
  from astropy.visualization.wcsaxes import SphericalCircle
  from matplotlib import pyplot as plt
  import seaborn as sns
  import circle_fit_utils

  sns.set_style('white')


  SOURCE_DIR = 'OB/Kobulnicky2016'
  source_table = Table.read(
      os.path.join(SOURCE_DIR, 'table1.dat'),
      format='ascii.cds',
      readme=os.path.join(SOURCE_DIR, 'ReadMe')
  )

  IMAGE_DIR = 'OB/MipsGal'

  ENVIRONMENTS = {
      'I': 'Isolated',
      'H': 'H II region',
      'FH': 'Facing H II region',
      'FB': 'Facing bright-rimmed cloud',
  }


  # Some data in the the Kobulnicky2016 table is just wrong
  OVERRIDE = {
      8: {'R0': 5.0},
      10: {'R0': 16.0},
      85: {'R0': 20.0},
      228: {'R0': 18.0},
      648: {'R0': 40},
      650: {'R0': 50},
  }
  STEP_BACK_FACTOR = 2.0
  CIRCLE_THETA = 45.0*u.deg

  THMIN, THMAX = coord.Angle([-160.0*u.deg, 160.0*u.deg])

  def description_from_table_row(data):
      desc = data['Name'] + '\n'
      if data['Alias']:
          desc += data['Alias'] + '\n'
      desc += f"R0 = {data['R0']:.1f} arcsec, PA = {data['PA']} deg" + '\n'
      csource = 'Multiple candidates' if data['Unc'] == 'C' else 'Single candidate'
      desc += f'{csource} for central source' + '\n'
      desc += f"Environment: {ENVIRONMENTS[data['Env']]}"
      return desc


  def skycoord_from_table_row(data):
      ra = f"{data['RAh']} {data['RAm']} {data['RAs']}"
      dec = f"{data['DE-']}{data['DEd']} {data['DEm']} {data['DEs']}"
      return coord.SkyCoord(f'{ra} {dec}', unit=(u.hourangle, u.deg))


  def coord_concat(array_tuple, **kwds):
      """Like numpy.concatenate but ensures result is of coordinate type"""
      return coord.SkyCoord(np.concatenate(array_tuple, **kwds))


  for source_data in source_table[300:]:

      # Override data from table where necessary
      if source_data['Seq'] in OVERRIDE:
          for k, v in OVERRIDE[source_data['Seq']].items():
              source_data[k] = v

      # Coordinates of source central star
      c = skycoord_from_table_row(source_data)
      # Find all the images for this source
      provisional_list = glob.glob(
          f"{IMAGE_DIR}/*-{source_data['Name']}-*.fits")
      # Look for an image that is good
      good_image_list = []
      for image_name in provisional_list:
          hdu, = fits.open(image_name)
          looks_good = hdu.header['NAXIS1'] == hdu.header['NAXIS2']
          if looks_good:
              good_image_list.append(image_name)

      if good_image_list:
          # Use the first one in the list - because: why not? 
          hdu, = fits.open(good_image_list[0])
      else:
          # If there were no good images, then never mind
          continue

      # Create WCS object for this image
      w = WCS(hdu)
      # Find celestial coordinates for each pixel
      ny, nx = hdu.data.shape
      xpix = np.arange(nx)[None, :]
      ypix = np.arange(ny)[:, None]
      cpix = coord.SkyCoord.from_pixel(xpix, ypix, w)
      # Now find radius and position angle from source
      rpix = c.separation(cpix).to(u.arcsec)
      pa_pix = c.position_angle(cpix).to(u.degree)
      # Nominal PA of bowshock axis from table
      pa0 = coord.Angle(source_data['PA'], unit=u.degree)
      # theta is angle from nominal axis, set to range [-180:180]
      theta_pix = coord.Longitude(pa_pix - pa0, wrap_angle=180*u.degree)

      # Also create an offset frame in case we need it later, in which
      # measurements are with respect to the central source coordinate,
      # and rotated by pa0
      offset_frame = c.skyoffset_frame(rotation=pa0)
      # Coordinates of each pixel in the offset frame - this has
      # components: offset_pix.lat (along pa0) and offset_pix.lon
      # (perpendicular to pa0)
      offset_pix = cpix.transform_to(offset_frame)

      # Nominal arc radius from source table
      R0 = source_data['R0']*u.arcsec

      # Only look in a restricted range of radius around R0
      rad_mask = (rpix > 0.5*R0) & (rpix < 3.0*R0)

      # Minimum and median brightness, which we might need later
      bright_min = np.nanmin(hdu.data)
      bright_median = np.nanmedian(hdu.data)

      # Next, we trace the arc

      # 08 Mar 2017 - Try a different tack - take radii from a center
      # that is "stepped back" by STEP_BACK_FACTOR times R0 away from
      # the source
      c_sb = coord.SkyCoord(0.0*u.deg, -STEP_BACK_FACTOR*R0,
                            frame=offset_frame).transform_to('icrs')
      # Repeat all the above to find radius, angle from this new point
      # Now find radius and position angle from source
      r_sb_pix = c_sb.separation(cpix).to(u.arcsec)
      pa_sb_pix = c_sb.position_angle(cpix).to(u.degree)
      # theta is angle from nominal axis, set to range [-180:180]
      th_sb_pix = coord.Longitude(pa_sb_pix - pa0, wrap_angle=180*u.degree)
      # And a frame relative to the "step back" center too
      sb_offset_frame = c_sb.skyoffset_frame(rotation=pa0)


      # Loop over a grid of angles between +/- 60 degrees
      ntheta = 51
      theta_grid, dtheta = np.linspace(-60.0, 60.0, ntheta, retstep=True)
      # Make everything be a longitude in range [-180:180]
      th_sb_grid = coord.Longitude(theta_grid, unit=u.degree, wrap_angle=180*u.degree)
      dtheta = coord.Longitude(dtheta, unit=u.degree, wrap_angle=180*u.degree)
      r_sb_peak_grid = []
      r_sb_mean_grid = []
      bmax_grid = []
      bmean_grid = []
      for th_sb in th_sb_grid:
          # Select only pixels in the wedge within +/- dtheta/2 of this theta
          theta_mask = np.abs(th_sb_pix - th_sb) < 0.5*dtheta
          # Combine with the radius mask
          m = theta_mask & rad_mask

          if np.alltrue(~m):
              # If mask is empty, fill in this theta with NaNs
              r_sb_peak = np.nan*u.deg
              r_sb_mean = np.nan*u.deg
              bright_max = np.nan
              bmean = np.nan
          else:            
              # Try a variety of methods for determining the arc radius
              # at this theta ...

              # Peak brightness
              ipeak = hdu.data[m].argmax()
              r_sb_peak = r_sb_pix[m][ipeak]

              # Mean brightness-weighted radius. We divide weights by
              # radius to compensate for density of pixels. Also, we
              # select only points brighter than 0.5 times the peak
              # brightness in this wedge.  And all brightnesses are
              # relative to a background floor, which is either the
              # median over the whole image or, if the peak in the wedge
              # is lower than that, then the minimum over the image
              bright_max = hdu.data[m].max()
              bright_floor = bright_median if bright_max > bright_median else bright_min
              mb = (hdu.data - bright_floor) > 0.5*(bright_max - bright_floor)
              weights = (hdu.data[m & mb] - bright_floor)/r_sb_pix[m & mb]
              try: 
                  r_sb_mean = np.average(r_sb_pix[m & mb], weights=weights)*u.arcsec
                  bmean = np.average(hdu.data[m & mb], weights=weights)
              except ZeroDivisionError:
                  r_sb_mean = np.nan*u.deg
                  bmean = np.nan

          # Fit Gaussian to profile - TODO?

          # Save all quantities into grid lists
          r_sb_mean_grid.append(r_sb_mean)
          r_sb_peak_grid.append(r_sb_peak)
          bmax_grid.append(bright_max)
          bmean_grid.append(bmean)

      # convert to single array of each quantity
      r_sb_mean_grid = coord.Angle(r_sb_mean_grid)
      r_sb_peak_grid = coord.Angle(r_sb_peak_grid)
      bmax_grid = np.array(bmax_grid)
      bmean_grid = np.array(bmean_grid)


      # Now switch back to the frame centered on the source

      # Get the arc coordinates in RA, Dec
      #
      # Use the offset frame centered on the source and aligned with PA
      # axis.  The order of components is (lon, lat) where lon is
      # perpendicular and lat parallel to the bowshock axis
      rmean_coords = coord.SkyCoord(
          r_sb_mean_grid*np.sin(th_sb_grid),
          r_sb_mean_grid*np.cos(th_sb_grid),
          frame=sb_offset_frame).transform_to('icrs')
      rpeak_coords = coord.SkyCoord(
          r_sb_peak_grid*np.sin(th_sb_grid),
          r_sb_peak_grid*np.cos(th_sb_grid),
          frame=sb_offset_frame).transform_to('icrs')

      # Switch back to frame centered n surce
      rmean_grid = c.separation(rmean_coords).to(u.arcsec)
      theta_mean_grid = coord.Longitude(
          c.position_angle(rmean_coords).to(u.degree) - pa0,
          wrap_angle=180*u.degree)
      rpeak_grid = c.separation(rpeak_coords).to(u.arcsec)
      theta_peak_grid = coord.Longitude(
          c.position_angle(rpeak_coords).to(u.degree) - pa0,
          wrap_angle=180*u.degree)

      # Fit circle to peak points within CIRCLE_THETA of axis
      cmask_peak = np.abs(theta_peak_grid) <= CIRCLE_THETA
      cmask_mean = np.abs(theta_mean_grid) <= CIRCLE_THETA
      # Use the mean and peak points
      try: 
          points2fit = coord_concat((rpeak_coords[cmask_peak],
                                     rmean_coords[cmask_mean]))
          # Initial guess for center would make Rc/R0 = 2
          center0 = coord.SkyCoord(0.0*u.deg, -R0,
                                   frame=offset_frame).transform_to('icrs')
          Rc, center = circle_fit_utils.fit_circle(points2fit, center0)
          Rc = Rc.to(u.arcsec)
      except:
          print('ABORT - Problem with points2fit or circle_fit_utils.fit_circle')
          continue


      if Rc > 100*R0:
          print('ABORT due to ridiculous radius of curvature: Rc =', Rc)
          continue

      # Find standard deviation of points from circle
      Rc_sigma = np.std(
          circle_fit_utils.deviation_from_circle(points2fit, center)
      ).to(u.arcsec)

      # Find PA of circle fit
      # First assume case where center of curvature is "behind" the source
      pa_circ = center.position_angle(c).to(u.deg)
      # Find difference between fitted and nominal position angle
      delta_pa = coord.Longitude(pa_circ - pa0, wrap_angle=180*u.deg)
      if np.abs(delta_pa) > 90*u.deg:
          # Check for Case where center of curvature is "in front of" the source
          pa_circ = c.position_angle(center).to(u.deg)
          delta_pa = coord.Longitude(pa_circ - pa0, wrap_angle=180*u.deg)

      # Find our estimate of R0
      #
      # Make some masks selecting points within 10 deg of pa_circ
      m0_peak = np.abs(theta_peak_grid - delta_pa) <= 10.0*u.deg
      m0_mean = np.abs(theta_mean_grid - delta_pa) <= 10.0*u.deg
      # Then concatenate all the R values that meet this condition
      R0_grid = coord.Angle(
          np.concatenate((rpeak_grid.value[m0_peak],
                          rmean_grid.value[m0_mean])),
          unit=u.arcsec)
      R0_fit, R0_sigma = R0_grid.mean(), R0_grid.std()
      fit_msg = f'Fitted R0 = {R0_fit.arcsec:.1f} +/- {R0_sigma.arcsec:.1f} arcsec' + '\n'

      # Make an offset frame centered on the center of curvature
      circ_offset_frame = center.skyoffset_frame(rotation=pa_circ)
      # Find R(theta) for the fitted circle
      thdash = np.linspace(-180.0, 180.0, 501)*u.deg
      circ_points = coord.SkyCoord(
          Rc*np.sin(thdash), Rc*np.cos(thdash),
          frame=circ_offset_frame).transform_to('icrs')
      circ_theta = coord.Longitude(
          c.position_angle(circ_points).to(u.deg) - pa0,
          wrap_angle=180*u.degree)
      circ_radius = c.separation(circ_points).to(u.arcsec)
      # Eliminate points that are not within +/- 100 deg of nominal axis
      mcirc = (circ_theta >= -100.0*u.deg) & (circ_theta <= 100.0*u.deg)
      circ_radius[~mcirc] *= np.nan
      fit_msg += f'PA_circ = {pa_circ.deg:.1f}, delta PA = {delta_pa.deg:.1f}' + '\n'
      fit_msg += f'Rc = {Rc.arcsec:.1f} +/- {Rc_sigma.arcsec:.1f} arcsec' + '\n'

      # Find R90
      #
      # Make some masks selecting points within 10 deg of +90 and -90
      m90p_peak = np.abs(theta_peak_grid - 90.0*u.deg) <= 10.0*u.deg
      m90n_peak = np.abs(theta_peak_grid + 90.0*u.deg) <= 10.0*u.deg
      m90p_mean = np.abs(theta_mean_grid - 90.0*u.deg) <= 10.0*u.deg
      m90n_mean = np.abs(theta_mean_grid + 90.0*u.deg) <= 10.0*u.deg
      # Then concatenate all the R values for the two cases
      R90p_grid = coord.Angle(
          np.concatenate((rpeak_grid.value[m90p_peak],
                          rmean_grid.value[m90p_mean])),
          unit=u.arcsec)
      R90n_grid = coord.Angle(
          np.concatenate((rpeak_grid.value[m90n_peak],
                          rmean_grid.value[m90n_mean])),
          unit=u.arcsec)
      # And calculate mean and standard deviation
      R90p, R90p_sigma = R90p_grid.mean(), R90p_grid.std()
      R90n, R90n_sigma = R90n_grid.mean(), R90n_grid.std()
      fit_msg += f'R90+ = {R90p.arcsec:.1f} +/- {R90p_sigma.arcsec:.1f} arcsec' + '\n'
      fit_msg += f'R90- = {R90n.arcsec:.1f} +/- {R90n_sigma.arcsec:.1f} arcsec' + '\n'


      # Save the fit data for each source
      table_file_name = image_name.replace('.fits', '-arcfit.tab')
      save_vars = [
          ['Seq', source_data['Seq']], 
          ['R0_fit', R0_fit.arcsec], 
          ['R0_sigma', R0_sigma.arcsec],
          ['pa_circ', pa_circ.deg],
          ['delta_pa', delta_pa.deg],
          ['Rc', Rc.arcsec],
          ['Rc_sigma', Rc_sigma.arcsec],
          ['R90p', R90p.arcsec],
          ['R90p_sigma', R90p_sigma.arcsec],
          ['R90n', R90n.arcsec],
          ['R90n_sigma', R90n_sigma.arcsec],
      ]
      colnames, colvals = zip(*save_vars)
      Table(rows=[list(colvals)],
            names=list(colnames)).write(table_file_name,
					format='ascii.tab',
					overwrite=True)

      # Save a figure for each source
      fig = plt.figure(figsize=(12, 8))

      # Make a plot of the radii and brightnesses versus theta
      ax_r = fig.add_axes((0.08, 0.55, 0.35, 0.4))
      ax_b = fig.add_axes((0.08, 0.08, 0.35, 0.4))
      ax_i = fig.add_axes((0.5, 0.1, 0.45, 0.45), projection=w)
      ax_r.plot(theta_mean_grid, rmean_grid, 'o', c='c', label='mean')
      ax_r.plot(theta_peak_grid, rpeak_grid, 'o', c='r', label='peak')
      ax_r.plot(circ_theta, circ_radius,
		'--', c='m', label='circle fit')
      ax_r.axhline(R0.value)
      ax_r.axvspan(-90.0, 90.0, facecolor='k', alpha=0.05)
      ax_r.axvspan(-CIRCLE_THETA.value, CIRCLE_THETA.value, facecolor='k', alpha=0.05)
      ax_r.axvline(0.0, c='k', ls='--')
      ax_r.legend()
      ax_r.set(xlim=[THMIN.deg, THMAX.deg],
               ylim=[0.0, None], ylabel='Bow shock radius, arcsec')
      ax_b.plot(theta_mean_grid, bmean_grid - bright_median, 'o', c='c', label='mean')
      ax_b.plot(theta_peak_grid, bmax_grid - bright_median, 'o', c='r', label='peak')
      ax_b.axvspan(-90.0, 90.0, facecolor='k', alpha=0.05)
      ax_b.axvspan(-CIRCLE_THETA.value, CIRCLE_THETA.value, facecolor='k', alpha=0.05)
      ax_b.axvline(0.0, c='k', ls='--')
      ax_b.legend()
      ax_b.set(xlim=[THMIN.deg, THMAX.deg], xlabel='Angle from nominal axis, degree',
               ylim=[0.0, None], ylabel='Bow shock brightness',
      )

      # And also plot the image
      ax_i.imshow(hdu.data,
                  vmin=bright_min, vmax=bmean_grid.max(), origin='lower')

      # And contours
      if bmax_grid.max() > bright_median:
          clevels = np.linspace(bright_median, bmax_grid.max(), 10)
      else:
          clevels = np.linspace(bright_median, hdu.data.max(), 10)
      ax_i.contour(hdu.data, levels=clevels, alpha=0.5)

      wtran = ax_i.get_transform('world')

      # Add markers for the traced bow shock
      ax_i.scatter(rmean_coords.ra.deg, rmean_coords.dec.deg, transform=wtran,
                   marker='.', c='c', s=30, alpha=0.5)
      ax_i.scatter(rpeak_coords.ra.deg, rpeak_coords.dec.deg, transform=wtran,
                   marker='.', c='r', s=30, alpha=0.5)

      # Add a line for the PA orientation
      PA_coords = coord.SkyCoord(
          [0.0*u.deg, 0.0*u.deg], [-2*R0, 2*R0],
          frame=offset_frame).transform_to('icrs')
      ax_i.plot(PA_coords.ra.deg, PA_coords.dec.deg,
		transform=wtran, c='orange', lw=2, alpha=0.8)

      # And plot the fitted circle
      circ = SphericalCircle((center.ra, center.dec), Rc,
                             edgecolor='m', lw=2, alpha=0.5, facecolor='none',
                             transform=wtran)
      ax_i.add_patch(circ)
      # And a line for the fitted PA axis
      PA_fit_coords = coord.SkyCoord(
          [0.0*u.deg, 0.0*u.deg], [-1.2*Rc, 1.2*Rc],
          frame=circ_offset_frame).transform_to('icrs')
      ax_i.plot(PA_fit_coords.ra.deg, PA_fit_coords.dec.deg,
		transform=wtran, c='m', lw=1.5, alpha=0.6)
      # And the center of curvature
      ax_i.scatter(center.ra.deg, center.dec.deg, transform=wtran,
                   marker='o', s=30, edgecolor='k', facecolor='m')
      # Add a marker for the source
      ax_i.scatter(c.ra.deg, c.dec.deg, transform=wtran,
                   s=150, marker='*', edgecolor='k', facecolor='orange')


      # Add coordinate grids
      ax_i.coords.grid(color='m', linestyle='solid', alpha=0.2)
      ax_i.coords['ra'].set_axislabel('Right Ascension')
      ax_i.coords['dec'].set_axislabel('Declination')
      overlay = ax_i.get_coords_overlay('galactic')
      overlay.grid(color='c', linestyle='solid', alpha=0.2)
      overlay['l'].set_axislabel('Galactic Longitude')
      overlay['b'].set_axislabel('Galactic Latitude')

      # Add title
      ax_i.text(0.5, 1.7, description_from_table_row(source_data),
		transform=ax_i.transAxes, ha='center', va='bottom'
      )
      ax_i.text(0.5, 1.6, fit_msg,
		transform=ax_i.transAxes, ha='center', va='top'
      )

      fig.savefig(image_name.replace('.fits', '-multiplot.png'))
      # Important to close figure explicitly so as not to leak resources
      plt.close(fig)

#+END_SRC
**** Updated routines for circle fitting
+ Updated version of [[file:~/Work/Bowshocks/Jorge/bowshock-shape/read-shapes-LL/fit-circle-shell.py]]
+ Main difference is that we work in sky coordinates
  + =astropy.coords.SkyCoord=
#+BEGIN_SRC python :eval no :tangle circle_fit_utils.py
  import numpy as np
  import astropy.coordinates as coord
  import astropy.units as u
  import lmfit

  def Rc_from_data(points, center):
      return np.mean(center.separation(points))

  def deviation_from_circle(points, center):
      return center.separation(points) - Rc_from_data(points, center)

  def model_minus_data(params, points):
      center = coord.SkyCoord(params["ra"].value*u.deg, params["dec"].value*u.deg)
      return deviation_from_circle(points, center).arcsec

  def fit_circle(points, center0):
      """Fit a circle to `points` with initial guess that center is at
  `center0`.  Returns radius of curvature and center of curvature"""
      params = lmfit.Parameters()
      params.add("ra", value=center0.ra.deg)
      params.add("dec", value=center0.dec.deg)
      out = lmfit.minimize(model_minus_data, params, args=(points,))
      lmfit.report_fit(out)
      center = coord.SkyCoord(out.params["ra"].value*u.deg, out.params["dec"].value*u.deg)
      Rc = Rc_from_data(points, center)
      return Rc, center

#+END_SRC


*** Where the figures are suposed to be (but they aren't)
http://iopscience.iop.org/0067-0049/227/2/18/suppdata/
http://iopscience.iop.org/0067-0049/227/2/18/media

** Tracing the shapes
*** OB stars
*** RSG stars (and AGB)
:PROPERTIES:
:ID:       94EECFDB-B61E-4242-89C2-09BD3B36D587
:END:
**** \alpha Orionis (Betelgeuse)
+ Press release image
  + [[file:RSG/Betelgeuse_Herschel_large.jpg]]
  + http://herschel.cf.ac.uk/results/betelgeuse
+ Original data from http://archives.esac.esa.int/hsa/whsa/
  + Use the most processed version: https://www.cosmos.esa.int/web/herschel/user-provided-data-products
  + [[file:RSG/AlphaOri-160_10_AFGL190.mod.fits]]
+ Put crosses on to trace the outer arc
  + file:RSG/Betelgeuse_Herschel-arcs.reg
+ Fit circle to the arc

#+BEGIN_SRC sh :results verbatim
cd RSG
python ../../read-shapes-LL/find-xy-shell.py alphaori --pa0 45
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results verbatim
cd RSG
python ../../read-shapes-LL/fit-circle-shell.py alphaori --debug --thmax 75
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 115
    # variables        = 2
    chi-square         = 4833.978
    reduced chi-square = 42.779
    Akaike info crit   = 433.927
    Bayesian info crit = 439.417
[[Variables]]
    xc:  -136.600747 +/- 4.042615 (2.96%) (init=-328.3531)
    yc:  -68.7003769 +/- 2.189979 (3.19%) (init=-161.0606)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.788 
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 88.79302917,  7.40696111)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 88.75476522,  7.38787767)>
Separation star->center in arcsec:  152.90622356827168
sqrt(xc**2 + yc**2) =  152.903583849
#+end_example
**** Sources from Cox et al
+ From Fig 1, these look like good candidates
+ These are the ones that look like they will give a good chance of measuring R_c and R_90
  + Constitute 7 out of 22 "Type I" morphologies, which are the ones with bowshocks
  + So this is about 15% of the total sample
| Name      |       IRAS | Arc | PA (pm) | PA (R_0) |
|-----------+------------+-----+---------+---------|
| \alpha Ori     | 05524+0723 |  70 |    47.7 |      54 |
| UU Aur    | 06331+3829 |  70 |   170.4 |     200 |
| R Leo     | 09448+1139 |  70 |   112.3 |     117 |
| R Hya     | 13269-2301 |  70 |   313.7 |     284 |
| V1943 Sgr | 20038-2722 | 160 |     155 |     135 |
| X Pav     | 20075-6005 |  70 |    84.9 |      88 |
| \mu Cep     | 21419+5832 |  70 |   216.3 |      85 |
+ Position angles:
  + The PA (pm) column is the PA from proper motion
  + The PA (R_0) column is \theta in Cox et al table, which is PA of measured R_0
  + They are roughly similar, except for in \mu Cep
+ Arc tracing
  + Done at 70 micron in most of them, since higher resolution and arc is generally more prominent
  + Exception is V1943 Sgr, which was better at 160 micron because the arc is incomplete (and smaller radius) in 70 micron

#+BEGIN_SRC sh :results verbatim
cd RSG
D=../../read-shapes-LL
python $D/find-xy-shell.py uuaur --pa0 200
python $D/find-xy-shell.py rleo --pa0 120
python $D/find-xy-shell.py rhya --pa0 280
python $D/find-xy-shell.py v1943sgr --pa0 135
python $D/find-xy-shell.py xpav --pa0 90
python $D/find-xy-shell.py mucep --pa0 90
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sh :results verbatim
cd RSG
D=../../read-shapes-LL
python $D/fit-circle-shell.py uuaur --debug --thmax 75 --savefig
python $D/fit-circle-shell.py rleo --debug --thmax 75 --savefig
python $D/fit-circle-shell.py rhya --debug --thmax 75 --savefig
python $D/fit-circle-shell.py v1943sgr --debug --thmax 75 --savefig
python $D/fit-circle-shell.py xpav --debug --thmax 75 --savefig
python $D/fit-circle-shell.py mucep --debug --thmax 75 --savefig
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 32
    # variables        = 2
    chi-square         = 42.236
    reduced chi-square = 1.408
    Akaike info crit   = 12.881
    Bayesian info crit = 15.813
[[Variables]]
    xc:   15.0610640 +/- 1.100570 (7.31%) (init= 63.51735)
    yc:   25.5300293 +/- 0.918767 (3.60%) (init= 52.16668)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.851 
outer : 15.0610640641 25.5300293379 111.870661618
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 99.13680833,  38.44531944)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 99.14215003,  38.45241112)>
Separation star->center in arcsec:  29.641116012318466
sqrt(xc**2 + yc**2) =  29.6414920126
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 27
    # variables        = 2
    chi-square         = 104.474
    reduced chi-square = 4.179
    Akaike info crit   = 40.534
    Bayesian info crit = 43.125
[[Variables]]
    xc:  -33.3846142 +/- 2.578846 (7.72%) (init=-86.3434)
    yc:   9.37818363 +/- 1.079356 (11.51%) (init= 26.9824)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.698 
outer : -33.3846142656 9.37818363087 126.756157072
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 146.88944583,  11.42896667)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 146.87998473,  11.43157172)>
Separation star->center in arcsec:  34.67668601017268
sqrt(xc**2 + yc**2) =  34.6768337349
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 24
    # variables        = 2
    chi-square         = 609.197
    reduced chi-square = 27.691
    Akaike info crit   = 81.618
    Bayesian info crit = 83.974
[[Variables]]
    xc:   110.175601 +/- 10.67015 (9.68%) (init= 90.24736)
    yc:  -23.0858829 +/- 6.627401 (28.71%) (init=-55.71501)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.895 
outer : 110.175601373 -23.0858829412 213.540750481
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.4279125, -23.28110833)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.46122962, -23.28752108)>
Separation star->center in arcsec:  112.56569836972328
sqrt(xc**2 + yc**2) =  112.568295399
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 11
    # variables        = 2
    chi-square         = 17.864
    reduced chi-square = 1.985
    Akaike info crit   = 9.334
    Bayesian info crit = 10.129
[[Variables]]
    xc:  -9.68883170 +/- 1.643640 (16.96%) (init=-38.86762)
    yc:   14.9640406 +/- 1.958355 (13.09%) (init= 50.65795)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.827 
outer : -9.68883170818 14.9640406645 83.2641253433
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 301.73027917, -27.22538889)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 301.72725251, -27.22123221)>
Separation star->center in arcsec:  17.826931215089093
sqrt(xc**2 + yc**2) =  17.8268329459
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 23
    # variables        = 2
    chi-square         = 11.868
    reduced chi-square = 0.565
    Akaike info crit   = -11.218
    Bayesian info crit = -8.947
[[Variables]]
    xc:  -22.2929159 +/- 1.108003 (4.97%) (init=-54.10835)
    yc:  -4.27263268 +/- 0.341913 (8.00%) (init=-10.72157)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.477 
outer : -22.2929159036 -4.27263268094 78.6385241074
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 302.94182917, -59.9371)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 302.92946771, -59.93828684)>
Separation star->center in arcsec:  22.698275321362722
sqrt(xc**2 + yc**2) =  22.6986671307
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 23
    # variables        = 2
    chi-square         = 143.971
    reduced chi-square = 6.856
    Akaike info crit   = 46.185
    Bayesian info crit = 48.456
[[Variables]]
    xc:  -29.4220193 +/- 3.508065 (11.92%) (init=-69.01557)
    yc:   8.35037470 +/- 1.062646 (12.73%) (init=-12.28705)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.392 
outer : -29.4220192961 8.35037470152 102.964786609
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 325.8768,  58.78037778)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 325.86103216,  58.78269733)>
Separation star->center in arcsec:  30.583102380367688
sqrt(xc**2 + yc**2) =  30.5840477556
#+end_example

R Hya looks like it would be better with --thmax 45
#+BEGIN_SRC sh :results verbatim
cd RSG
D=../../read-shapes-LL
python $D/fit-circle-shell.py rhya --debug --thmax 45 --savefig
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 14
    # variables        = 2
    chi-square         = 26.774
    reduced chi-square = 2.231
    Akaike info crit   = 13.077
    Bayesian info crit = 14.355
[[Variables]]
    xc:   58.4657628 +/- 8.404392 (14.37%) (init= 90.24736)
    yc:  -15.0097612 +/- 4.656127 (31.02%) (init=-55.71501)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.950 
outer : 58.4657628622 -15.0097612186 166.101863129
#### Checking offset of outer arc center ####
Star coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.4279125, -23.28110833)>
Arc center coords:  <SkyCoord (ICRS): (ra, dec) in deg
    ( 202.44559256, -23.28527771)>
Separation star->center in arcsec:  60.36084260447921
sqrt(xc**2 + yc**2) =  60.361729257
#+end_example

* Convert images to FITS
+ This has not been necessary yet, but may be needed for the O star arcs
#+BEGIN_SRC sh
python ~/Work/Image2FITS/image2fits.py RSG/Betelgeuse_Herschel_large.jpg
#+END_SRC

#+RESULTS:


* DONE Testing the angle functions in =find-xy-shell.py=
CLOSED: [2017-02-28 Tue 10:28]
+ There was a problem with the order of angles in \alpha Ori
  + Turns out it was simply due to failing to convert input degrees to radians for internal use
  + *Fixed* [2017-02-28 Tue]
+ This is the function that is used for sorting the angles:
#+name: find-th-order
#+BEGIN_SRC python
import numpy as np
def canonicalize(th, unit="radians"):
    """Fold an angle theta into the canonical range [-pi:pi]"""
    if unit == "radians":
        return ((th + np.pi) % (2*np.pi)) - np.pi
    elif unit == "degrees":
        return ((th + 180.0) % (360.0)) - 180.0
    else:
        raise NotImplementedError

def find_th_order(th, pa_ref, debug=True): 
    """Returns a sort order for a collection of angles theta
    
    Takes care to account for the wrap-around of angles by shifting
    the star-th1C vector to be at pi, so that all points are (with
    luck) in the range [0, 2 pi]

    """
    th1 = (canonicalize(th - pa_ref) + np.pi) % (2*np.pi)
    if debug: 
        print("Finding theta order:") 
        print("    th =", np.degrees(th)) 
        print("    pa_ref =", np.degrees(pa_ref)) 
        print("    th1 =", np.degrees(th1)) 
        print("    order =", th1.argsort()) 
    return th1.argsort()
#+END_SRC


#+BEGIN_SRC python :noweb yes :results output verbatim
<<find-th-order>>
th0 = np.radians(45.0)
th = np.radians([180, 45, 15, 90, 120, 310])
order = find_th_order(th, pa_ref=th0)

print(np.degrees(th[order]))
print(np.degrees(canonicalize(th[order] - th0)))

#+END_SRC

#+RESULTS:
: Finding theta order:
:     th = [ 180.   45.   15.   90.  120.  310.]
:     pa_ref = 45.0
:     th1 = [ 315.  180.  150.  225.  255.   85.]
:     order = [5 2 1 3 4 0]
: [ 310.   15.   45.   90.  120.  180.]
: [ -95.  -30.    0.   45.   75.  135.]


* Bow waves formed by radiation pressure on dust grains
+ This mini-project has outgrown its original home, which was in [[id:5493D03D-24D5-479B-8C7B-0BE2FCA576EF][Multifactor pair plot of the non-shape parameters]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Stellar-Bowshocks-2017/stellar-bowshocks.org][../Stellar-Bowshocks-2017/stellar-bowshocks.org]]
+ So, I am moving it here to give it room to grow
** Copy dust wave figure files to paper folder
#+BEGIN_SRC sh :results output
  FIGFILES='dust-couple-stream-annotate.pdf dust-wave-Rc-R90*.pdf dust-coupling-1d.pdf dust-divergent.pdf dust-couple-div-stream.jpg'
  date
  pwd
  for f in $FIGFILES; do
      cp -av $f ../papers/Paper1/figs 
  done
#+END_SRC

#+RESULTS:
: Fri Nov 17 18:27:25 CST 2017
: /Users/will/Work/Bowshocks/Jorge/bowshock-shape/Dust-wave
: dust-couple-stream-annotate.pdf -> ../papers/Paper1/figs/dust-couple-stream-annotate.pdf
: dust-wave-Rc-R90-error.pdf -> ../papers/Paper1/figs/dust-wave-Rc-R90-error.pdf
: dust-wave-Rc-R90.pdf -> ../papers/Paper1/figs/dust-wave-Rc-R90.pdf
: dust-coupling-1d.pdf -> ../papers/Paper1/figs/dust-coupling-1d.pdf
: dust-divergent.pdf -> ../papers/Paper1/figs/dust-divergent.pdf
: dust-couple-div-stream.jpg -> ../papers/Paper1/figs/dust-couple-div-stream.jpg

** Dust grain trajectories
+ The figure of these in the case of zero gas-grain coupling is done in [[id:8EC004CA-32CC-4B41-830C-535FF79B0544][Dust grain trajectories in a central force]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Quadric-shapes/quadric-projected-2017.org][../Quadric-shapes/quadric-projected-2017.org]]
+ [X] I would like to do some sort of n-body code coupled with a gas code to allow a more realistic model
  + A first approach would be a test-particle approximation, which would avoid the need for the gas code
  + We would have a uniform background gas flow to provide drag, but would ignore the back reaction of the grains on the gas (valid for sufficiently low dust-gas ratio)
  + We could solve this using ~scipy.integrate.odeint~ or ~scipy.integrate.ode~
  + On the axis, for sufficiently weak coupling, I think the trajectories will oscillate between
    1. an inner radius, r_0, where drift speed w \gg inflow speed v_0, allowing grain to decouple and turn from inflow to outflow
    2. an outer radius, r_1, where w = v_0, so grain re-couples and turns from outflow back to inflow again 
  + If density is constant, then w \propto 1/r, so if w_0 is the drift speed at r_0, then r_1 = r_0 w_0 / v_0
  + Although, wouldnâ€™t grain get trapped at r_1?
  + Yes, it turns out that the phase space (x, u) trajectories spiral into (x=r_1, u=0)
*** On-axis numerical solution for trajectories
#+BEGIN_SRC python :eval no :tangle dust-coupling-1d.py
  import sys
  import numpy as np
  from scipy.integrate import odeint
  from matplotlib import pyplot as plt
  import seaborn as sns

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      x, u = y
      dxdt = u
      dudt = 0.5*(x**(-2) - alpha**2 * (u + 1.0))
      return [dxdt, dudt]

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Initial conditions
  y0 = [10.0, -1.0]

  # Coupling parameter
  alpha = 1.0/2.0

  # Time grid
  t = np.linspace(0.0, 60.0, 501)
  soln = odeint(dydt, y0, t, args=(alpha,))
  t0 = t[np.argmin(soln[:, 0])]

  # Slippage velocity
  w = 1.0 + soln[:, 1]
  # Drift velocity
  wdrift = 1.0 / alpha / soln[:, 0]

  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(t - t0, soln[:, 0], label='$R/R_{0}$')
  ax.plot(t - t0, w, label='$w / v_{\infty}$')
  ax.plot(t - t0, wdrift, ls='--', label='$w_\mathrm{drift} / v_{\infty}$')

  ax.axhline(1.0/alpha, ls=':', color='k', lw=0.8)
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  ax.legend(title=r"$\alpha_\mathrm{drag} = 0.5$")
  ax.set(xlabel=r'Time / $(R_{0} / v_{\infty})$', ylim=[-0.3, 4.3])
  t2 = np.linspace(0.0, 20.0, 201)
  soln2 = odeint(dydt, y0, t2, args=(2.0,))
  soln0 = odeint(dydt, y0, t2, args=(0.0,))

  axp.plot(soln0[:, 0], soln0[:, 1], label=r"$\alpha_\mathrm{drag} = 0$")
  axp.plot(soln[:, 0], soln[:, 1], label=r"$\alpha_\mathrm{drag} = 0.5$")
  axp.plot(soln2[:, 0], soln2[:, 1], label=r"$\alpha_\mathrm{drag} = 2$")
  axp.axhline(0, xmax=0.55, color='k', lw=0.5)
  axp.legend(title='Phase space\n  trajectories')
  axp.set(xlabel='$R/R_{0}$', ylabel='$v / v_{\infty}$',
          xlim=[-0.35, 6.9], ylim=[-1.1, 1.1],
          xticks=range(7),
          yticks=[-1.0, -0.5, 0., 0.5, 1.0])

  sns.despine(trim=True)
  fig.tight_layout()
  fig.text(0.02, 0.97, '(a)')
  fig.text(0.02, 0.5, '(b)')
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC shell :results file
python dust-coupling-1d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-1d.pdf]]
*** Two-d solution for trajectories


#+BEGIN_SRC python :eval no :tangle dust_couple_ode.py
  import numpy as np
  from scipy.integrate import odeint

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      X, U, Y, V = y
      dXdt = U
      dYdt = V
      R2 = X**2 + Y**2
      theta = np.arctan2(Y, X)
      dUdt = 0.5*(np.cos(theta)/R2 - alpha**2 * (U + 1.0))
      dVdt = 0.5*(np.sin(theta)/R2 - alpha**2 * V)
      return [dXdt, dUdt, dYdt, dVdt]

  def dydt_div(y, t, alpha, mu):
      """Derivatives for ODE in divergent case"""
      X, U, Y, V = y
      dXdt = U
      dYdt = V
      R2 = X**2 + Y**2
      # Gas flow diverges from point (X1, Y1) = (1/mu, 0)
      X1, Y1 = 1.0/mu, 0.0
      # Gas flow is radial from that point
      R1 = np.hypot(X - X1, Y - Y1)
      U1 = (X - X1)/R1
      V1 = (Y - Y1)/R1
      theta = np.arctan2(Y, X)
      dUdt = 0.5*(np.cos(theta)/R2 - alpha**2 * (U - U1))
      dVdt = 0.5*(np.sin(theta)/R2 - alpha**2 * (V - V1))
      return [dXdt, dUdt, dYdt, dVdt]


  def streamline(alpha=1.0/3.0, X0=10.0, Y0=0.0,
                 tstop=60.0, n=201, mu=None):
      # Time grid
      t = np.linspace(0.0, tstop, n)
      if mu is None:
          # parallel stream
          # Vector of initial conditions
          y0 = [X0, -1.0, Y0, 0.0]
          soln = odeint(dydt, y0, t, args=(alpha,))
      else:          # Vector of initial conditions

          # divergent stream
          X1, Y1 = 1.0/mu, 0.0
          assert X0 < X1, 'Start point must be to left of wind source'
          R1 = np.hypot(X0 - X1, Y0 - Y1)
          U0 = (X0 - X1)/R1
          V0 = (Y0 - Y1)/R1
          # Vector of initial conditions
          y0 = [X0, U0, Y0, V0]
          soln = odeint(dydt_div, y0, t, args=(alpha, mu))
        
      return {'t': t, 'b': Y0, 'alpha': alpha, 'mu': mu, 
              'x': soln[:, 0], 'u': soln[:, 1],
              'y': soln[:, 2], 'v': soln[:, 3],}

#+END_SRC

#+BEGIN_SRC python :eval no :tangle dust-coupling-2d.py
  import sys
  from matplotlib import pyplot as plt
  import seaborn as sns
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Impact parameter
  b = 0.001
  stream = streamline(Y0=b, alpha=1.0/2.0, tstop=70, X0=20., n=501, mu=0.01)
  sns.set_style('white')
  sns.set_color_codes()
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(stream['t'], stream['u'], label='$U$')
  ax.plot(stream['t'], stream['v'], label='$V$')
  ax.plot(stream['t'], stream['x'], label='$X$')
  ax.plot(stream['t'], stream['y'], label='$Y$')
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  label = fr"$\alpha = {stream['alpha']:.2f}$, "
  if stream['mu'] is not None:
      label += fr"$\mu = {stream['mu']:.2f}$, "
  label += f"$b = {b:.3f}$"
  ax.legend(title=label, ncol=2)
  ax.set(xlabel='Time', ylim=[-6, 8])

  axp.plot(stream['x'], stream['u'], label='$(X, U)$')
  axp.plot(stream['y'], stream['v'], label='$(Y, V)$')
  axp.axhline(0, color='k', lw=0.5)
  axp.legend(title='Phase space')
  axp.set(xlabel='$X$, $Y$', ylabel='$U$, $V$',
          xlim=[-7, 9], ylim=[-1.1, 1.1])

  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-coupling-2d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-2d.pdf]]


#+BEGIN_SRC python :eval no :tangle dust-couple-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.jpg')

  sns.set_style('white')
  sns.set_color_codes()
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  nb = 25*200 + 1
  bgrid = 0.001 + np.linspace(0.0, 5.0, nb)
  ibspecial = 25*np.array([1, 4, 10, 20, 40, 60])
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth

  rm = 2.0/(1.0 + np.cos(thm_grid))
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  xmin, xmax = [-3.99, 3.99]
  ymin, ymax = [0.0, 4.99]
  for alpha, ax in zip(alphas, axes.flat):
      xx, yy, ww = [], [], []
      xs, ys = [], []
      for ib, b in enumerate(bgrid):
          s = streamline(X0=5, Y0=b, tstop=30, alpha=alpha, n=30001)
          # ax.plot(s['x'], s['y'], color='k', lw=0.5)
          # Accumulate (x, y) points in a long list
          xx.extend(s['x'])
          yy.extend(s['y'])
          # Weights proportional to b/r
          ww.extend(s['b']/s['y'])
          # ax.plot(s['x'], s['y'], '.',
          #         mec='none', mfc='r', ms=3, alpha=0.02)
          if ib in ibspecial:
              # Save streamlines for selected impact parameters
              xs.append(s['x'])
              ys.append(s['y'])
      # Plot a density histogram of all the (x, y) points we accumulated
      H, xe, ye = np.histogram2d(xx, yy, bins=(80/1, 50/1), weights=ww,
                                 range=[[xmin, xmax], [ymin, ymax]])
      rho_m = np.median(H)
      ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
                vmin=0.0, vmax=2.0*rho_m, cmap='gray_r')
      # Plot the streamlines that we saved earlier
      for x, y in zip(xs, ys):
          ax.plot(x, y, '-', color='w', lw=0.8, alpha=0.5)
          ax.plot(x, y, '-', color='k', lw=0.5)
      ax.plot(xlocus, ylocus, ':', color='w', alpha=0.5, lw=2)
      ax.axvline(0.0, ls='--', color='w', lw=0.5)
      ax.text(1.0, 4.0, 
              fr"$\alpha_\mathrm{{drag}} = {alpha:.2f}$",
              color='k')
      ax.set_aspect('equal', adjustable='box-forced')

      # Save the minimum radius as a function of theta
      rr = np.hypot(xx, yy)
      theta = np.arctan2(yy, xx)
      rrm_grid = np.empty_like(thm_grid)
      for j, th0 in enumerate(thm_grid):
          # Mask to select points with theta between th0 -> th0 + dth
          m = np.abs(theta - (th0 + 0.5*dth)) <= 0.5*dth
          try:
              rrm_grid[j] = rr[m].min()
          except:
              # Sometimes mask may be empty
              rrm_grid[j] = np.nan
            
      tabfilename = sys.argv[0].replace('.py', f'-alpha{int(100*alpha):03d}.tab')
      Table({'theta': thm_grid, 'R': rrm_grid}).write(tabfilename, format='ascii.tab')

  for ax in axes[:, 0]:
      ax.set(ylabel='$y/R_{0}$', ylim=[ymin, ymax])
  for ax in axes[-1, :]:
      ax.set(xlabel='$x/R_{0}$', xlim=[xmin, xmax])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile, dpi=600)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-couple-stream.py
#+END_SRC

#+RESULTS:
[[file:dust-couple-stream.jpg]]

+ I will now annotate this figure with Graphic.app
  + PDF export in [[file:dust-couple-stream-annotate.pdf]]
+ Now repeat for a divergent incident stream
  + We have problems with the large \alpha_drag models because the bow gets
    small.  So what I will do is to scale the lengths by 1/(1 +
    \alpha_drag), which should make the stand-off distances be the same in
    all cases.
  + Except the factor isn't exactly that.
    + Maybe just try 1/\alpha_drag since that is the stagnation radius,
    + which is close to the inner edge for \alpha_drag \gg 1
    + But not for \alpha_drag < 1

#+BEGIN_SRC python :eval no :tangle dust-couple-div-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.jpg')

  sns.set_style('ticks')
  sns.set_color_codes()
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  alphas = [1.0, 1.0, 4.0, 4.0]
  mus = [0.05, 0.2, 0.2, 0.8]
  nb = 25*200 + 1
  bgrid = 0.001 + np.linspace(0.0, 5.0, nb)
  ibspecial = 25*np.array([1, 4, 10, 20, 40, 60])
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth


  xmin, xmax = [-4.1, 4.1]
  ymin, ymax = [0.0, 5.1]
  for alpha, mu, ax in zip(alphas, mus, axes.flat):
      xx, yy, ww = [], [], []
      xs, ys = [], []

      # zoom in on the alpha > 1 models since they get small
      zoom = alpha if alpha > 1.0 else 1.0

      # Launch grains on a uniform grid of th1
      # Make sure it fills the plot
      th1max = np.arctan2(ymax/zoom, 1.0/mu - xmax/zoom)
      th1grid = 0.001*mu + np.linspace(0.0, th1max, nb)
      bgrid = np.sin(th1grid)/mu

      # Hyperbola solution for drag-free case, but scaling mu by alpha
      ecc = 1.0 / (1.0 - 2*mu/alpha)
      # And scale radius by alpha too
      rm = (1.0 + ecc)/(1.0 + ecc*np.cos(thm_grid))/alpha
      rm[rm < 0.0] = np.nan
      xlocus = rm*np.cos(thm_grid)
      ylocus = rm*np.sin(thm_grid)


      for ib, (th1, b) in enumerate(zip(th1grid, bgrid)):
          # Start from a circle just outside the plot window
          Rlaunch = 1/mu - xmax/zoom
          assert Rlaunch > 0.0
          X0 = 1./mu - Rlaunch*np.cos(th1)
          Y0 = Rlaunch*np.sin(th1)
          s = streamline(X0=X0, Y0=Y0, tstop=30, alpha=alpha, mu=mu, n=30001)
          # ax.plot(s['x'], s['y'], color='k', lw=0.5)
          # Accumulate (x, y) points in a long list
          xx.extend(s['x'])
          yy.extend(s['y'])
          # Weights proportional to b/r
          ww.extend(s['b']/s['y'])
          # ax.plot(s['x'], s['y'], '.',
          #         mec='none', mfc='r', ms=3, alpha=0.02)
          if ib in ibspecial:
              # Save streamlines for selected impact parameters
              xs.append(s['x'])
              ys.append(s['y'])
      # Plot a density histogram of all the (x, y) points we accumulated
      H, xe, ye = np.histogram2d(xx, yy, bins=(80/1, 50/1), weights=ww,
                                 range=[[xmin/zoom, xmax/zoom], [ymin/zoom, ymax/zoom]])
      rho_m = np.median(H[H != 0.0])
      rho_m = H[-1, -1]
      ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
                vmin=0.0, vmax=2.0*rho_m, cmap='gray_r')
      # Plot the streamlines that we saved earlier
      for x, y in zip(xs, ys):
          ax.plot(x*zoom, y*zoom, '-', color='w', lw=0.8, alpha=0.5)
          ax.plot(x*zoom, y*zoom, '-', color='k', lw=0.5)
      ax.plot(xlocus*zoom, ylocus*zoom, ':', color='w', alpha=0.5, lw=2)
      ax.axvline(0.0, ls='--', color='w', lw=0.5)
      label = fr"$\alpha_\mathrm{{drag}} = {alpha:.1f}$"
      label += '\n' + fr"$\mu = {mu:.2f}$"
      ax.text(1.0, 4.0, label, color='k')
      ax.set_aspect('equal', adjustable='box-forced')

      # Save the minimum radius as a function of theta
      rr = np.hypot(xx, yy)
      theta = np.arctan2(yy, xx)
      rrm_grid = np.empty_like(thm_grid)
      for j, th0 in enumerate(thm_grid):
          # Mask to select points with theta between th0 -> th0 + dth
          m = np.abs(theta - (th0 + 0.5*dth)) <= 0.5*dth
          try:
              rrm_grid[j] = rr[m].min()
          except:
              # Sometimes mask may be empty
              rrm_grid[j] = np.nan

      suffix = f'-alpha{int(100*alpha):03d}'
      suffix += f'-mu{int(100*mu):03d}'
      tabfilename = sys.argv[0].replace('.py', suffix + '.tab')
      Table({'theta': thm_grid, 'R': rrm_grid}).write(tabfilename, format='ascii.tab', overwrite=True)

  for ax in axes[:, 0]:
      ax.set(
          ylabel=r'$\alpha_\mathrm{{drag}} \,Y$',
          ylim=[ymin, ymax],
          yticks=range(5),
      )
  for ax in axes[-1, :]:
      ax.set(
          xlabel=r'$\alpha_\mathrm{{drag}} \,X$',
          xlim=[xmin, xmax],
          xticks=range(-4,5),
      )

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile, dpi=600)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-couple-div-stream.py
#+END_SRC

*** Shape parameters as function of drag parameter
+ We have written tables of R(\theta) for the inner edge of the dust shells
  + [[file:dust-couple-stream-alpha025.tab]]
  + [[file:dust-couple-stream-alpha050.tab]]
  + [[file:dust-couple-stream-alpha100.tab]]
  + [[file:dust-couple-stream-alpha200.tab]]
+ So we can find R_c and R_90 and plot them as function of \alpha_drag

#+BEGIN_SRC python :eval no :tangle dust-wave-Rc-R90.py
  import sys
  import json
  import numpy as np
  from scipy.interpolate import interp1d
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  import astropy.modeling.fitting
  from astropy.modeling.models import custom_model
  from astropy.modeling.fitting import LevMarLSQFitter
  sys.path.append('../conic-projection')
  from conproj_utils import Conic

  @custom_model
  def conic_y_x(x, x0=-3.0, a=5.0, b=3.0):
      s = np.sign(x0 - 1.0)
      return b*np.sqrt(1.0 + s*((x - x0)/a)**2)

  alldata = {}

  fit = LevMarLSQFitter()

  figfile = sys.argv[0].replace('.py', '.pdf')
  sns.set_style('white')
  sns.set_color_codes()

  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  efig, eaxes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))

  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  results = {'alpha': [0.0] + alphas, 'Rc': [2.0], 'R90': [2.0]}
  for alpha, ax, eax in zip(alphas, axes.flat, eaxes.flat):
      astring = f'-alpha{int(100*alpha):03d}.tab'
      alpha_label = fr"$\alpha_\mathrm{{drag}} =  {alpha:.02f}$"
      fitdata = {}
      t = Table.read('dust-couple-stream' + astring, format='ascii.tab')
      dth = np.pi/len(t)
      theta = t['theta'] + 0.5*dth
      # Mask to select only the near-apex region
      m = np.degrees(theta) <= 30.0
      # Reflect through origin to ensure an even function
      thth = np.concatenate([-theta[m][::-1], theta[m]])
      RR = np.concatenate([t['R'][m][::-1], t['R'][m]])
      # Fit polynomial to find R0 and Rc
      a, b, c = np.polyfit(thth, RR, deg=2)
      assert(b == 0.0, 'Linear term should be non-zero, but is not')
      R0 = c
      Rc = 1.0/(1.0 - 2.0*a/c)

      # Find R90 by linear interpolation
      f = interp1d(theta, t['R'], kind='linear')
      R90 = f(0.5*np.pi)/R0
      results['Rc'].append(Rc)
      results['R90'].append(R90)

      R_bow = t['R']/R0
      x_bow = R_bow*np.cos(theta)
      y_bow = R_bow*np.sin(theta)

      # Define the head-fit conic section that corresponds to (Rc, R90)
      arg = 2*Rc - R90**2
      thc = np.sign(arg)*np.arctan(np.sqrt(np.abs(arg)))
      head_conic = Conic(A=Rc, th_conic=np.degrees(thc))
      t = head_conic.make_t_array()
      x_head = head_conic.x(t)
      y_head = head_conic.y(t)
      th_head = np.arctan2(y_head, x_head)
      R_head = np.hypot(x_head, y_head)

      # Save the parameters for the head fit
      fitdata['head'] = {'Rc': Rc,
                         'R90': R90,
                         'T': head_conic.b_a**2}

      # Now find a tail-fit conic
      # We only fit the tail between xswitch and xfar
      xswitch, xfar = -1.0, -8.0
      mtail = (x_bow < xswitch) & (x_bow > xfar)
      mfar = (x_bow <= xfar) & (x_bow > -40.0)

      # Try a more direct approach: fit hyperbola with LM
      model = conic_y_x()
      best_model = fit(model, x_bow[mtail], y_bow[mtail])
      r0_tail = best_model.a.value + best_model.x0.value

      x_tail = np.linspace(r0_tail, -30.0, 1000)
      y_tail = best_model(x_tail)
      th_tail = np.arctan2(y_tail, x_tail)
      R_tail = np.hypot(x_tail, y_tail)

      # Save the parameters for the tail fit
      fitdata['tail'] = {'x0': best_model.x0.value,
                         'a': best_model.a.value,
                         'b': best_model.b.value,
                         'r0': best_model.a.value + best_model.x0.value,
                         'T': (best_model.b.value/best_model.a.value)**2}

      # Finally, a third fit to the far tail with a hyperbola
      # model2 = conic_y_x(x0=15.0, a=30.0, b=1.0)
      model2 = conic_y_x(x0=-15.0, a=30.0, b=y_bow[mfar].max())
      best_model2 = fit(model2, x_bow[mfar], y_bow[mfar]) 
      x_far = np.linspace(2.0, -100.0, 1000)
      y_far = best_model2(x_far)
      th_far = np.arctan2(y_far, x_far)
      R_far = np.hypot(x_far, y_far)

      # Save the parameters for the far tail fit
      fitdata['far'] = {'x0': best_model2.x0.value,
                        'a': best_model2.a.value,
                        'b': best_model2.b.value,
                        'r0': best_model2.a.value + best_model2.x0.value,
                        'T': (best_model2.b.value/best_model2.a.value)**2}

      # Stash the fit data in the big dict
      alldata[alpha] = fitdata

      # Plot the bow and the two fits
      ax.axvspan(xfar, xswitch, color='k', alpha=0.05)
      ax.plot(x_bow, y_bow, lw=7, alpha=0.3, label='_nolegend_')
      ax.plot(x_far, y_far, ls='-.', color='m', label="Far tail fit")
      ax.plot(x_tail, y_tail, ls=':', lw=2.5, color='r', label="Tail fit")
      ax.plot(x_head, y_head, ls='--', color='orange', label="Head fit")
      ax.text(-14, 0.8, alpha_label, fontsize='small')

      ax.set_aspect('equal', adjustable='box-forced')

      # And plot the errors
      f_R_tail = interp1d(th_tail, R_tail, bounds_error=False)
      e_tail = (f_R_tail(theta) - R_bow)/R_bow
      f_R_head = interp1d(th_head, R_head, bounds_error=False)
      e_head = (f_R_head(theta) - R_bow)/R_bow
      f_R_far = interp1d(th_far, R_far, bounds_error=False)
      e_far = (f_R_far(theta) - R_bow)/R_bow

      # Find angle that corresponds to x = -1
      th1 = interp1d(x_bow, theta)(xswitch)
      # Find angle that corresponds to x = -8
      th2 = interp1d(x_bow, theta)(xfar)
      mh = theta <= th1
      mt = (theta > th1) & (theta <= th2)
      mtt = theta > th2

      eax.axhline(0.0, lw=3, alpha=0.5, color='b')
      eax.axhspan(-0.01, 0.01, color='b', alpha=0.1, ec='none')
      eax.axvspan(np.degrees(th1), np.degrees(th2), color='k', alpha=0.05)

      # Plot each error curve twice, faintly over the bad zone â€¦
      eax.plot(np.degrees(theta[mt | mtt]), e_head[mt | mtt], label='_nolegend_',
               ls='--', color='orange', alpha=0.3)
      # And strongly over the range it should be fitting
      eax.plot(np.degrees(theta[mh]), e_head[mh], label="Head fit",
               ls='--', color='orange', alpha=1.0)

      # Same for the tail fit, but 3 times since we have a bad zone each side
      eax.plot(np.degrees(theta[mh]), e_tail[mh], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_tail[mtt], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mt]), e_tail[mt], label="Tail fit",
               ls=':', lw=2.5, color='r', alpha=1.0)

      # And now for the far-tail fit as well
      eax.plot(np.degrees(theta[mt]), e_far[mt], label='_nolegend_',
               ls='-.', color='m', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_far[mtt], label="Far tail fit",
               ls='-.', color='m', alpha=1.0)

      eax.text(10.0, -0.04, alpha_label, fontsize='small')


  for ax in axes[-1, :]:
      ax.set(xlim=[-15, 2.5], xlabel='$x/R_0$')
  for ax in axes[:, 0]:
      ax.set(ylim=[0, 8], ylabel='$y/R_0$')
  axes[-1,-1].legend(fontsize='small')

  for eax in eaxes[-1, :]:
      eax.set(xlim=[0.0, 180.0],
              xlabel=r"Polar angle: $\theta$, degrees",
              xticks=[0, 30, 60, 90, 120, 150, 180])
  for eax in eaxes[:, 0]:
      eax.set(ylim=[-0.05, 0.05],
              ylabel=r"Fractional error: $\delta R / R$")
  eaxes[-1,-1].legend(fontsize='small')
  eaxes[-1, 1].text(10.0, -0.9/100, r"$|\delta R/R| < 1\%$", 
                    color='b', fontsize='x-small')

  # print(results)
  #     ax.plot(theta, R, label=fr"${alpha:.2f}$")

  # ax.legend(title=r"$\alpha_\mathrm{drag}$")
  # ax.axhline(2.0, color='k', alpha=0.3, lw=1)
  # ax.axvline(90.0, color='k', alpha=0.3, lw=1)
  # ax.set(xlim=[0.0, 180.0], ylim=[0.0, 14.0],
  #        xlabel=r'$\theta$', ylabel=r'$R$')

  sns.despine(fig)
  fig.tight_layout()
  fig.savefig(figfile)

  sns.despine(efig)
  efig.tight_layout()
  efig.savefig(figfile.replace('.pdf', '-error.pdf'))

  jsonfile = figfile.replace('-Rc-R90.pdf', '-fitdata.json')
  with open(jsonfile, 'w') as f:
      json.dump(alldata, f, indent=4)

  print(figfile, end='')
#+END_SRC


#+BEGIN_SRC sh :results file
python dust-wave-Rc-R90.py
#+END_SRC

#+RESULTS:
[[file:dust-wave-Rc-R90.pdf]]

+ Error figure: [[file:dust-wave-Rc-R90-error.pdf]]
+ JSON data file: [[file:dust-wave-fitdata.json]]

*** Plot diagnostic diagrams for the 3-quadric dust wave fits
+ So this will be like the current Fig 16, but for the \alpha_drag models instead of the carawilkinoids
  + Could I call them /dragoids/?
  + Yes, I think I could
  + Actually, we need to ditch /[an]carawilkinoid/, since it is such a mouthful
  + New terms:
    + /cantoid/ for the CRW shape
    + /ancantoid/ for the anisotropic generalization of ~CRW~
      + Or maybe even /tarangoid/ !!
    + Special cases of ancantoids
      + /proploid/ for \xi = 0.8
      + /jetoid/ for small \xi
+ The graph for the carawilkinoids was done here: [[id:F47926C6-77DB-4797-9101-F83B5E59DA6A][R90 vs Rc for generalized CRW]]
  + It made use of this module: [[id:0483E2CE-E74E-4CFD-89B2-0AE92CCC6217][Utility functions for A, B, and \theta_c]]
  + But that is very specific to those fits and the tortuous process of trying to do analytic matching, which I ended up not using.
  + I think we can do something simpler
+ Some of the necessary equations are in [[id:B3ABBD4B-6A04-415F-8A8D-6A3179EB3686][Projection of Quadrics]]
  + But a lot of the seem to be only in my handwritten notes still
  + I have also copied some functions from [[id:9232DE3C-903E-4D13-8E72-FC2B92D1FF95][Projected R90 versus Rc]]
#+BEGIN_SRC python :eval no :tangle three-quadric-dragoid-R90-vs-Rc.py
  import sys
  import json
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns

  def Rc_prime(inc, Tc, Rc):
      f = np.sqrt(1.0 + Tc*np.tan(inc)**2)
      return Rc * (1 + np.tan(inc)**2) / f / (1.0 + Rc*(f - 1.0) / Tc)

  def Tc_prime(inc, Tc):
      fsquared = 1.0 + Tc*np.tan(inc)**2
      return Tc * (1.0 + np.tan(inc)**2) / fsquared

  def R90_prime(inc, Tc, Rc):
      return np.sqrt(2*Rc_prime(inc, Tc, Rc) - Tc_prime(inc, Tc))

  plotfile = sys.argv[0].replace('.py', '.pdf')

  alldata = json.load(open('dust-wave-fitdata.json'))


  sns.set_style('white')
  sns.set_color_codes('dark')

  fig, ax = plt.subplots(figsize=(5, 5))


  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)

  colors = 'bmgr'

  for (alpha, data), color in zip(alldata.items(), colors):
      # Parameters for head conic
      R0_h = 1.0
      T_h = data['head']['T']
      tilde_Rc_h = data['head']['Rc']
      R90_h = data['head']['R90']
      ax.plot([tilde_Rc_h], [R90_h], 'o', color=color)
      ax.plot(Rc_prime(inc, T_h, tilde_Rc_h),
              R90_prime(inc, T_h, tilde_Rc_h), '--', color=color)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)

  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 3.1],
      ylim=[0.0, 3.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        

  sns.despine()
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')


#+END_SRC


#+BEGIN_SRC sh :results file
  python three-quadric-dragoid-R90-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:three-quadric-dragoid-R90-vs-Rc.pdf]]



** DONE Diverging stream trajectories
CLOSED: [2017-11-17 Fri 09:15]
:LOGBOOK:
- Note taken on [2017-11-15 Wed 11:14] \\
  This is a new thing that has occurred to me.  What if the grains stream from a point source?
:END:

*** Gas-free case of diverging dust trajectories
+ The only difference from the parallel stream is that we add \theta_1 = sin^{-1} \mu b/R_0 to all the angles, where \mu = R_0/D
#+BEGIN_SRC python :tangle dust-divergent.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns

  figfile = sys.argv[0].replace('.py', '.pdf')
  NTH = 4001
  MU = 1./10.
  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, ax = plt.subplots(figsize=(4, 4))
  blist = np.linspace(0.0, 6.0) + 0.01
  thmlist = np.arccos(1./np.sqrt(1.0 + 4.0*blist**2))
  for thm, b in zip(thmlist, blist):
      epsilon = 1./np.cos(thm)
      th1 = np.arcsin(MU*b)
      ttheta = np.linspace(0.001, min(np.pi, 2*thm - 0.001), NTH)
      im = np.argmin(np.abs(ttheta - thm))
      r = 0.5*(epsilon**2 - 1)/(epsilon*np.cos(ttheta - thm) - 1.0)
      theta = ttheta - th1
      x = r*np.cos(theta)
      y = r*np.sin(theta)
      m_in = (theta <= thm) & (y >= 0.0)
      m_out = (theta > thm) & (y >= 0.0)
      ax.plot([r[im]*np.cos(theta[im])], [r[im]*np.sin(theta[im])],
              's', ms=0.6, color='k')
      ax.plot(x[m_in], y[m_in], '-', color='gray', alpha=0.8, lw=0.5)
      ax.plot(x[m_out], y[m_out], '-', color='r', alpha=0.8, lw=0.5)
  thm_grid = np.linspace(0.0, np.pi, 200)
  rm = 2.0/(1.0 + np.cos(thm_grid))
  ecc = 1.0/(1.0 - (3/2)*MU)**(4/3)
  rmh = (1.0 + ecc)/(1.0 + ecc*np.cos(thm_grid))
  rmh[rmh < 0.0] = np.nan
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  ax.plot(xlocus, ylocus, '-', color='k', alpha=0.2, lw=3)
  xlocus = rmh*np.cos(thm_grid)
  ylocus = rmh*np.sin(thm_grid)
  ax.plot(xlocus, ylocus, '-', color='k', alpha=0.2, lw=3)

  ax.plot([0.0], [0.0], '*', color='r')
  ax.set(xlim=[-3.1, 3.9], ylim=[-0.1, 6.9],
         xlabel="$x / R_0$",
         ylabel="$y / R_0$")
  ax.set_aspect('equal')
  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC


#+BEGIN_SRC shell :results file
python dust-divergent.py
#+END_SRC

#+RESULTS:
[[file:dust-divergent.pdf]]

* Projection of a general shape
+ The plan is to find the plane-of-sky shape (xâ€², yâ€²) numerically for an arbitrary R(\theta) at a given inclination
+ This will be a check on the multi-quadric 
+ Turns out that I already did a version of this years ago in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/projected/bowfuncs.py][projected/bowfuncs.py]], so I will copy routines from there and modify accordingly
+ [7/9] Plan of work for ~bow_projection.py~ and its applications
  1. [X] Implement analytic R(\theta) functions: paraboloid, wilkinoid, cantoid
  2. [X] Implement \omega(\theta)
     + Test for analytic functions
  3. [X] Implement xâ€™_t, yâ€™_t
     + Plot projected shapes for analytic functions
  4. [X] Implement numerical R(\theta) functions: ancantoid, dragoid
     + [X] Use spline fits to get nice smooth derivatives (use much fewer spline knots than we have theta grid points)
     + [X] Solve the problems I have at \theta = 0 and \theta \to 180
     + [X] Use equation6.py or similar for the ancantoid
     + [X] Read dragoid shapes from json files
  5. [X] Implement R_c, R_90
     + [X] Deal better with telling if we are outside the bow
     + [X] Plot diagnostic graphs
       + [X] Dragoids
       + [X] Ancantoids and cantoids
     + This might be better combined with the following step
  6. [X] Make a convenience function that will do all that is necessary to get the info for a given shape at a given inclination
     - *cancelled* This is not necessary, since much is already done by  ~characteristic_radii_projected~
     - Find the range of relevant \theta and make an array
     - Find the R_0â€™, R_câ€™, R_90â€™.
       - Use linear interpolation to get the exact values for \theta_90, \theta_0
       - Fit a quadratic to Râ€™(\thetaâ€™) 
     - Calculate the (x_tâ€™, y_tâ€™) curve, including the bottom branch and the special points.  Also the \thetaâ€™ array
     - Return a dict with all this packaged up
  7. [ ] Include some of these graphs in the paper
     - [ ] Copy figure files
     - [ ] Write about them
  8. [X] Implement standing wave perturbations
     - [X] Write class to perturb a base shape
     - [X] Make graphs of (x, y) appearance
     - [X] Make graphs of (R_c, R_90) diagrams
  9. [ ] I need to find a better home for this work than the dust-wave file

** Copy bow projection figure files to paper folder
#+BEGIN_SRC sh :results output
  FIGFILES='test_xyprime.pdf test_xyprime_*dragoid.pdf test_xyprime_ancantoid.pdf *oid-R90-vs-Rc*.pdf compare_xyprime_wave-wilkinoid.pdf wave-R90-vs-Rc-A010-N10.pdf wave-R90-vs-Rc-A005-N20.pdf wave_xyprime-A005-N20-dragoid-alpha100.pdf wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf'
  date
  pwd
  for f in $FIGFILES; do
      cp -av $f ../papers/Paper1/figs 
  done
#+END_SRC

#+RESULTS:
#+begin_example
Fri Nov 17 18:27:37 CST 2017
/Users/will/Work/Bowshocks/Jorge/bowshock-shape/Dust-wave
test_xyprime.pdf -> ../papers/Paper1/figs/test_xyprime.pdf
test_xyprime_div_dragoid.pdf -> ../papers/Paper1/figs/test_xyprime_div_dragoid.pdf
test_xyprime_dragoid.pdf -> ../papers/Paper1/figs/test_xyprime_dragoid.pdf
test_xyprime_ancantoid.pdf -> ../papers/Paper1/figs/test_xyprime_ancantoid.pdf
ancantoid-R90-vs-Rc-a.pdf -> ../papers/Paper1/figs/ancantoid-R90-vs-Rc-a.pdf
ancantoid-R90-vs-Rc-b.pdf -> ../papers/Paper1/figs/ancantoid-R90-vs-Rc-b.pdf
ancantoid-R90-vs-Rc-lobeta-a.pdf -> ../papers/Paper1/figs/ancantoid-R90-vs-Rc-lobeta-a.pdf
dragoid-R90-vs-Rc.pdf -> ../papers/Paper1/figs/dragoid-R90-vs-Rc.pdf
three-quadric-dragoid-R90-vs-Rc.pdf -> ../papers/Paper1/figs/three-quadric-dragoid-R90-vs-Rc.pdf
wilkinoid-R90-vs-Rc-wave-A005-N20.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A005-N20.pdf
wilkinoid-R90-vs-Rc-wave-A005-N25.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A005-N25.pdf
wilkinoid-R90-vs-Rc-wave-A010-N10.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A010-N10.pdf
wilkinoid-R90-vs-Rc-wave-A010-N15.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A010-N15.pdf
wilkinoid-R90-vs-Rc-wave-A015-N07.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A015-N07.pdf
compare_xyprime_wave-wilkinoid.pdf -> ../papers/Paper1/figs/compare_xyprime_wave-wilkinoid.pdf
wave-R90-vs-Rc-A010-N10.pdf -> ../papers/Paper1/figs/wave-R90-vs-Rc-A010-N10.pdf
wave-R90-vs-Rc-A005-N20.pdf -> ../papers/Paper1/figs/wave-R90-vs-Rc-A005-N20.pdf
wave_xyprime-A005-N20-dragoid-alpha100.pdf -> ../papers/Paper1/figs/wave_xyprime-A005-N20-dragoid-alpha100.pdf
wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf -> ../papers/Paper1/figs/wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf
#+end_example


** Utility library ~bow_projection.py~ source
#+BEGIN_SRC python :tangle bow_projection.py :eval no
  import sys
  import numpy as np
  from scipy.optimize import brentq
  from scipy.misc import derivative


  # * Module parameters
  #
  # The delta theta that is used in the central difference approximation
  # to the derivative of the R(theta) function.  For optimum balance
  # between round-off and discretization error, this should be of order
  # ~sqrt(eps)~, where ~eps~ is the machine precision
  DX_FOR_NUMERICAL_DERIVATIVE = 3.0*np.sqrt(np.finfo(1.0).resolution)

  # If True, then print out some diagnostic info
  DEBUG = False

  # * Functions to find plane-of-sky shape
  #
  # All these functions should have argument lists of the form:
  #
  # :    theta, [inc], func_R, *args_for_func_R
  #
  # where ~func_R~ has signature ~func_R(theta, *args_for_func_R)~ and
  # ~inc~ is the inclination (for those functions that depend on that).
  #
  # They should also be written as element-wise functions of a vector
  # ~theta~, so no ~if~ statements are allowed, but ~inc~ must be a
  # scalar, as must all of the extra args for ~func_R~.
  #
  def omega(theta, func_R, *args_for_func_R):
      """Find omega = R^{-1} d R/d theta 

  Note that theta may be an array. Any extra arguments are passed to
  `func_R` after `theta`

      """
      def log_R(theta, *args):
          return np.log(func_R(theta, *args))

      return derivative(log_R, theta,
                        dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)


  def sin_phi_t(theta, inc, func_R, *args_for_func_R):
      """Returns sin(phi_t), where phi_t is azimuth along tangent line"""
      if np.tan(inc) == 0.0:
          # Avoid NaNs in the zero inclination case
          return np.zeros_like(theta)

      om = omega(theta, func_R, *args_for_func_R)
      tan_theta = np.tan(theta)
      return np.tan(inc)*(1.0 + om*tan_theta)/(om - tan_theta) 


  def xyprime_t(theta, inc, func_R, *args_for_func_R):
      """Returns observer-frame (x', y') coordinates of tangent line"""
      R = func_R(theta, *args_for_func_R)
      sphi_t = sin_phi_t(theta, inc, func_R, *args_for_func_R)
      cos_theta, sin_theta = np.cos(theta), np.sin(theta)
      xx = cos_theta*np.cos(inc) - sin_theta*sphi_t*np.sin(inc)
      with np.errstate(all='ignore'):
          yy = sin_theta*np.sqrt(1.0 - sphi_t**2)
      return R*xx, R*yy


  def radius_of_curvature(theta, func_R, *args_for_func_R):
      """Returns R_c = (R^2 + R'^2)^{3/2} / |R^2 + 2 R'^2 - R R''| 

  Uses numerical differentiation.  NOT RECOMMENDED SINCE NOT ACCURATE ON
  THE AXIS.  Use `axis_Rc` instead.

      """
      R = func_R(theta, *args_for_func_R)
      dR = derivative(func_R, theta,
                      dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)
      d2R = derivative(func_R, theta, n=2,
                       dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)
      return (R**2 + dR**2)**1.5 / np.abs(R**2 + 2*dR**2 - R*d2R)


  # * Projected R_c and R_{90}
  #

  # How close we try to get to the asymptotic theta
  TOLERANCE_THETA_INFINITY = 1.e-6

  def theta_infinity(func_R, *args_for_func_R):
      """Return maximum theta where R its derivative are still finite"""
      th0, dth = 0.0, np.pi
      with np.errstate(all='ignore'):
          # Keep repeating on a finer and finer grid until we get to within
          # the required tolerance
          while dth > TOLERANCE_THETA_INFINITY:
              # This will divide dth by 50 on each iteration
              th, dth = np.linspace(th0, th0 + dth, retstep=True)
              # It is more stringent to insist that omega must be
              # finite, since that needs to be an extra distance (=
              # DX_FOR_NUMERICAL_DERIVATIVE) away from the asymptote in
              # order to calculate the numerical derivative
              om = omega(th, func_R, *args_for_func_R)
              # The largest th for which omega is finite must be within at most
              # (dth + DX_FOR_NUMERICAL_DERIVATIVE) of the true asymptote
              th0 = th[np.isfinite(om)].max()

      return th0



  def theta_0_90(inc, func_R, *args_for_func_R):
      """Return (theta_0, theta_90), corresponding projected x and y axes
      """

      # Easy case first
      if inc == 0.0:
          return 0.0, np.pi/2

      # Second, check tangent line existence
      th_inf = theta_infinity(func_R, *args_for_func_R)
      if np.abs(inc) > th_inf - np.pi/2:
          return np.nan, np.nan

      # Otherwise, use root finding

      tani = np.tan(inc)
      sinsq2i = np.sin(2*inc)**2
      cossqi = np.cos(inc)**2

      def _f0(theta):
          """Function that is zero at theta = theta_0"""
          om = omega(theta, func_R, *args_for_func_R)
          return np.sin(theta)*(1.0 - om*tani) - np.cos(theta)*(om + tani)

      def _f90(theta):
          """Function that is zero at theta = theta_90"""
          om = omega(theta, func_R, *args_for_func_R)
          return (1.0/np.tan(theta)
                  - (1.0 - np.sqrt(1.0 + om**2 * sinsq2i))/(2*om*cossqi))

      th_inf = theta_infinity(func_R, *args_for_func_R)
      # If the inclination is too high, then there may be no solution
      if np.abs(inc) > th_inf - np.pi/2:
          return np.nan

      # The theta_0 value could be anywhere in range 0 -> th_inf, but we
      # set the lower limit higher than that to avoid some rare errors.
      # This should be alright unless R_c/R_0 < 0.1, which is not true
      # for any of the models I am interested in
      th1, th2 = 0.1*inc, th_inf
      # Make sure we do indeed bracket the root
      assert _f0(th1)*_f0(th2) <= 0.0, f"Unbracketed th0 root: {_f0(th1)}, {_f0(th2)}"
      # And use Brent's method to find the root
      th0 = brentq(_f0, th1, th2)

      # Repeat for the theta_90 value, which must be higher than theta_0
      th1, th2 = th0, th_inf
      assert _f90(th1)*_f90(th2) <= 0.0, f"Unbracketed th90 root: {_f90(th1)}, {_f90(th2)}"
      th90 = brentq(_f90, th1, th2)

      return th0, th90


  # Number of neighborhood points to use when fitting around projected
  # axes (theta' = 0 and theta' = 90)
  N_NEIGHBORHOOD = 50
  # Theta scale of neighborhood around theta' = 0 in units of (pi - th0)
  SCALE_NEIGHBORHOOD = 0.2
  # Degree of theta'^2 polynomial used in fitting R'(theta') @ theta' = 0
  DEGREE_POLY_NEIGHBORHOOD = 1

  # Same for around theta' = 90.  These need to be different since we
  # are fitting a polynomial in just theta' instead of theta'^2
  SCALE_NEIGHBORHOOD_90 = 0.03
  DEGREE_POLY_NEIGHBORHOOD_90 = 2

  def characteristic_radii_projected(inc, func_R, *args_for_func_R):
      """Return all the characteristic radii for projected bow shock

  Returns dict of 'R_0 prime', 'tilde R_c prime', 'theta_0', 'tilde R_90
  prime', 'theta_90'

      """

      # Zeroth step, check that we do have a tangent line
      th_inf = theta_infinity(func_R, *args_for_func_R)

      # What to return when there is no solution 
      no_solution = {'R_0 prime': np.nan, 'theta_inf': th_inf,
                     'tilde R_c prime': np.nan, 'theta_0': np.nan,
                     'tilde R_90 prime': np.nan, 'theta_90': np.nan}

      if np.abs(inc) > th_inf - np.pi/2:
          # No tangent line, so return all NaNs
          return no_solution

      # First, the quantities at th0, which is theta on the projected
      # symmetry axis (y' = 0) for this inclination
      th0, th90 = theta_0_90(inc, func_R, *args_for_func_R)

      # Make a grid of theta in the neighborhood of th0
      dth = SCALE_NEIGHBORHOOD*(np.pi - th0)
      th = np.linspace(th0, th0 + dth, N_NEIGHBORHOOD)
      if DEBUG:
          print("theta", th, file=sys.stderr)
          print("R", func_R(th, *args_for_func_R), file=sys.stderr)
          print("sin(phi_t)", sin_phi_t(th, inc, func_R, *args_for_func_R),
                file=sys.stderr)

      # Now find the tangent line and convert back to polar coordinates
      xprime, yprime = xyprime_t(th, inc, func_R, *args_for_func_R)
      Rprime = np.hypot(xprime, yprime)
      thprime = np.arctan2(yprime, xprime)
      if DEBUG:
          print("x'", xprime, file=sys.stderr)
          print("y'", yprime, file=sys.stderr)
          print("R'", Rprime, file=sys.stderr)
          print("theta'", thprime, file=sys.stderr)
      # Filter out any NaNs in the projected coordinates
      m = np.isfinite(Rprime*thprime)
      if m.sum() <= 3*DEGREE_POLY_NEIGHBORHOOD:
          # If not enough good points, then give up
          return no_solution

      # Fit R' with a cubic in (theta')^2, and use the constant and
      # linear coefficients to find the projected R_0 and R_c
      #
      # It seems to be enough to use deg=2 on 8 points
      coeffs = np.polyfit(thprime[m]**2, Rprime[m],
                          deg=DEGREE_POLY_NEIGHBORHOOD)
      R0_prime = coeffs[-1]
      gamma = coeffs[-2]/coeffs[-1]
      Rc_prime = 1./(1. - 2*gamma)
      if DEBUG:
          print("Polynomial coefficients", coeffs/coeffs[-1], file=sys.stderr)


      # Second, the quantities at th90, which is the theta on the projected
      # perpendicular axis (x' = 0)
      dth = SCALE_NEIGHBORHOOD_90*np.pi/2
      th = np.linspace(th90 - dth/2, th90 + dth/2, N_NEIGHBORHOOD)
      xprime, yprime = xyprime_t(th, inc, func_R, *args_for_func_R)
      Rprime = np.hypot(xprime, yprime)
      thprime = np.arctan2(yprime, xprime)
      if DEBUG:
          print("90 x'", xprime, file=sys.stderr)
          print("90 y'", yprime, file=sys.stderr)
          print("90 R'", Rprime, file=sys.stderr)
          print("90 theta'", thprime, file=sys.stderr)
      m = np.isfinite(Rprime*thprime)
      if m.sum() <= 3*DEGREE_POLY_NEIGHBORHOOD_90:
          # If not enough good points, then give up
          return no_solution
      # Fit a polynomial to thprime, Rprime in the vecinity of pi/2
      p = np.poly1d(np.polyfit(thprime[m], Rprime[m],
                               deg=DEGREE_POLY_NEIGHBORHOOD_90))
      # Evaluate polynomial at pi/2 to find R90_prime
      R90_prime = p(np.pi/2)/R0_prime
      if DEBUG:
          print("90 Polynomial coefficients", coeffs/coeffs[-1], file=sys.stderr)

      return {'R_0 prime': R0_prime, 'theta_inf': th_inf,
              'tilde R_c prime': Rc_prime, 'theta_0': th0,
              'tilde R_90 prime': R90_prime, 'theta_90': th90}



  # * Example analytic shape functions
  #

  def wilkinoid_R_theta(theta):
      """Wilkin solution for wind-stream interaction"""
      # Convert to array if scalar
      theta = np.atleast_1d(theta)
      # Equation (9) of Wilkin (1996)
      R = np.sqrt(3*(1.0 - theta/np.tan(theta)))/np.sin(np.abs(theta))
      # Equation is not stable for very small theta, so we use a Taylor
      # expansion instead
      small_angle = np.abs(theta) < 1e-5
      R[small_angle] = 1.0 + 0.2*theta[small_angle]**2
      return R

  def cantoid_R_theta(theta, beta):
      """Cantoid solution from CRW for wind-wind interaction

  Returns R(theta), normalized to the stagnation radius. Extra parameter
  `beta` is the momentum ratio of the two winds.  Note that this will
  not be accurate if beta is too close to zero, but it seems to be OK
  with beta >= 1.e-6.  For lower values than this, the results will be
  almost identical to the Wilkinoid, so `wilkinoid_R_theta` should be
  used instead.

      """

      theta = np.atleast_1d(theta)

      # Approximate solution for theta_1, the polar angle measured from
      # the "other" star
      theta1 = np.sqrt(7.5*(-1.0 + np.sqrt(
          1.0 + 0.8*beta*(1.0 - theta/np.tan(theta)))))
      # Make sure theta1 and theta have the same sign
      theta1 *= np.sign(theta)


      # On-axis (theta = 0) radius to stagnation point, in units of
      # star-star separation D
      R0 = np.sqrt(beta)/(1.0+np.sqrt(beta))

      R = np.where(np.abs(theta + theta1) > np.pi,
                   # theta > theta_inf => no solution
                   np.nan,
                   # theta <= theta_inf => return radius in units of R0
                   np.sin(theta1) / np.sin(theta + theta1) / R0)

      # Replace with Taylor expansion close to axis
      C = (1.0 - beta)/30.0
      gamma = C/(1.0 + np.sqrt(beta)) + (1.0 + 2*np.sqrt(beta))/6
      small_angle = np.abs(theta) < 1.e-5
      R[small_angle] = 1.0 + gamma*theta[small_angle]**2

      return R


  def paraboloid_R_theta(theta):
      """This is the special parabola with Rc = 2"""
      return 2.0 / (1.0 + np.cos(theta))


  def paraboloid_omega_true(theta):
      """Analytic omega for special parabola"""
      return np.sin(theta)  / (1.0 + np.cos(theta))


  # * Non-analytic shape functions
  #
  # These are bow shock shapes for which it is "non-trivial" to
  # calculate each R(theta).  E.g., requiring numerical root finding, so
  # hard to write naturally in an element-wise vector form
  #
  # For efficiency, we therefore calculate R(theta) once on a grid, and
  # then use a spline interpolation for fast subsequent evaluation
  # of R(theta) and its derivative

  import scipy.interpolate

  class _Spline_R_theta(object):
      """Base class for non-analytic shapes

  The R(theta) shape is initialized once on a grid when the class is
  instantiated, and fitted by a B-spline.  The object can then be called
  as a function of theta, which will be very fast since it just
  evaluates the B-spline.

      """

      thgrid = None
      Rgrid = None
      def _init_grid(self, ngrid, **shape_kwds):
          raise NotImplementedError("Override this method in a sub-class")

      def _init_spline(self, kspline, Rmax, smooth):
          """Fit a smoothing spline to the R(theta) grid. 

  We fit B-splines to the parametric [x(theta), y(theta)] representation
  of the bow shock. `kspline` is the order of the splines (default:
  cubic). `Rmax` is the maximum radius to be included in the spline fit.
  `smooth` is the spline smoothing condition (see docs for
  `scipy.interpolate.splprep`).

          """
          mgood = np.isfinite(self.Rgrid) & (self.Rgrid <= Rmax)
          x = self.Rgrid[mgood]*np.cos(self.thgrid[mgood])
          y = self.Rgrid[mgood]*np.sin(self.thgrid[mgood])
          self.spline_tck, u = scipy.interpolate.splprep(
              [x, y], u=self.thgrid[mgood], k=kspline, s=smooth)

      def __call__(self, theta):
          """Evaluate R(theta) from spline interpolation"""
          theta = np.atleast_1d(theta)
          x, y = scipy.interpolate.splev(theta, self.spline_tck, ext=1)
          # The ext=1 option to splev return 0 for points outside range of theta
          R = np.hypot(x, y)
          # Then we set those out-of-bound points to NaN
          R[(x == 0.0) & (y == 0.0)] = np.nan
          return R

      def __init__(self, ngrid=100, kspline=3, Rmax=100, smooth=0, **shape_kwds):
          """"""
          # Set up grids of theta and R
          self._init_grid(ngrid, **shape_kwds)
          # Set up spline interpolation
          self._init_spline(kspline, Rmax, smooth)


  class Spline_R_theta_from_function(_Spline_R_theta):
      """Spline-interpolated bow shock shape from explicit function

  Extra parameters for initialization: `shape_func` and
  `shape_func_pars`. THIS IS FOR TESTING ONLY!!! It checks that the
  interpolation machinery works for simple shapes. Outside of such
  tests, there is really no need to use the spline interpolation for
  these cases.

      """

      def _init_grid(self, ngrid,
                     shape_func=paraboloid_R_theta,
                     shape_func_pars=()):
          # Include the negative branch so the spline will have the
          # right gradient on the axis
          self.th_inf = theta_infinity(shape_func, *shape_func_pars)
          self.thgrid = np.linspace(0.0, self.th_inf, ngrid)
          self.Rgrid = shape_func(self.thgrid, *shape_func_pars)


  class Spline_R_theta_from_grid(_Spline_R_theta):
      """Spline-interpolated bow shock shape from user-specified arrays

  Extra parameters for initialization: `theta_grid` and `R_grid`.  This
  is the main way that the spline fits will be used.

      """
      def _init_grid(self, ngrid, theta_grid=None, R_grid=None):
          # Note that ngrid is ignored in this implementation
          if theta_grid is not None and R_grid is not None:
              self.thgrid = theta_grid
              self.Rgrid = R_grid
          else:
              raise ValueError("Both theta_grid and R_grid must be specified")


  # * Basic tests of functionality
  #

  if __name__ == "__main__":
      import sys
      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')

      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(0.0, np.pi, 501)
      th_dg = np.degrees(th)
      ax.plot(th_dg, omega(th, paraboloid_R_theta),
              label="paraboloid")
      ax.plot(th_dg, omega(th, wilkinoid_R_theta),
              label="wilkinoid")
      for beta in 0.001, 0.01, 0.1:
          ax.plot(th_dg, omega(th, cantoid_R_theta, beta),
                  label=fr"cantoid $\beta = {beta:.3f}$")
      ax.legend(title=r"Analytic $R(\theta)$ functions")
      ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
      ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
      ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
      ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
          xlim=[0, 180],
          ylim=[0.0, 2e2],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      figfile = f"test_{lib_name}_omega.pdf"
      fig.savefig(figfile)
      print(figfile, end='')
#+END_SRC


** Test the ~bow_projection~ library

*** Tests of analytic shapes
**** Basic test of omega(theta) for analytic shape
This is included in the module itself.  Note the ~symlog~ y-axis, which is linear from 0 \to 1 and then logarithmic from 1 \to 200
#+BEGIN_SRC sh :results file
  python bow_projection.py
#+END_SRC

#+RESULTS:
[[file:test_bow_projection_omega.pdf]]

**** Test of \phi_t
#+BEGIN_SRC python :eval no :tangle test_phi_t.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import sin_phi_t, paraboloid_R_theta, theta_infinity, theta_0_90

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(5, 5))

  inclinations = [0, 15, 30, 45, 60, 75]
  colors = sns.color_palette(n_colors=len(inclinations))
  th_inf = theta_infinity(paraboloid_R_theta)
  for inc_dg, color in zip(inclinations, colors):
      inc = np.radians(inc_dg)
      th0, th90 = theta_0_90(inc, paraboloid_R_theta)
      th = np.linspace(th0, th_inf, 501)
      th_dg = np.degrees(th)
      print("theta:", th_dg, file=sys.stderr)
      sphit = sin_phi_t(th, inc, paraboloid_R_theta)
      print("sphit:", sphit, file=sys.stderr)
      phit_dg = np.degrees(np.arcsin(sphit))
      print("phi:", phit_dg, file=sys.stderr)
      ax.plot(th_dg, phit_dg, label=f"inc = {inc_dg:d}", color=color)

  ax.legend(title="paraboloid")
  ax.set(
      xlabel=r"$\theta$",
      ylabel=r"$\phi_t$",
      xlim=[0, 180],
      ylim=[-90, 90],
      xticks=[0, 30, 60, 90, 120, 150, 180],
      yticks=[-90, -60, -30, 0, 30, 60, 90],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_phi_t.py
#+END_SRC

#+RESULTS:
[[file:test_phi_t.pdf]]

**** Test of plane-of-sky shape
#+BEGIN_SRC python :eval no :tangle test_xyprime.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              paraboloid_R_theta, wilkinoid_R_theta,
                              cantoid_R_theta)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  inclinations = [0, 15, 30, 45, 60.1, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for shape_name, ax, R_theta, extra_pars in [
          ["Paraboloid", axes[0, 0], paraboloid_R_theta, ()],
          ["Wilkinoid", axes[0, 1], wilkinoid_R_theta, ()],
          ["Cantoid\n" r"$\beta = 0.001$", axes[1, 0], cantoid_R_theta, (0.001,)],
          ["Cantoid\n" r"$\beta = 0.01$", axes[1, 1], cantoid_R_theta, (0.01,)],
  ]:
      th_inf = theta_infinity(R_theta, *extra_pars)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, R_theta, *extra_pars)
          th = np.linspace(th0, th_inf, 101)
          xp, yp = xyprime_t(th, inc, R_theta, *extra_pars)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          R0p = xxp.max()
          ax.plot(xxp/R0p, yyp/R0p, label=fr"$i = {int(inc_dg):d}^\circ$", lw=1.5*lw, color=color)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=shape_name, ncol=2, fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )
  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime.pdf]]


*** Test of spline fits to analytic shapes

**** R(\theta) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_spline_radius.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (omega, paraboloid_R_theta,
                              wilkinoid_R_theta, cantoid_R_theta,
                              Spline_R_theta_from_function)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)

  for label, func, pars, ngrid, s in [
          ["paraboloid", paraboloid_R_theta, (), 101, 1.0],
          ["Wilkinoid", wilkinoid_R_theta, (), 101, 0],
          [r"Cantoid $\beta = 0.001$", cantoid_R_theta, (0.001,), 101, 0],
          [r"Cantoid $\beta = 0.01$", cantoid_R_theta, (0.01,), 101, 0],
          [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 101, 0],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      ax.plot(th_dg, func(th, *pars), color='b', alpha=0.2, lw=2, label='_nolabel_')
      ax.plot(th_dg, spline_func(th), lw=0.8, label=label)

  ax.legend(title=r"Spline approximations")
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$R$",
      xlim=[0, 180],
      yscale='log',
      ylim=[0.9, 200.0],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python test_spline_radius.py
#+END_SRC

#+RESULTS:
[[file:test_spline_radius.pdf]]


**** \omega(\theta) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_spline.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (omega, paraboloid_R_theta,
                              wilkinoid_R_theta, cantoid_R_theta,
                              Spline_R_theta_from_function)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(0, np.pi, 10001)
  th_dg = np.degrees(th)

  for label, func, pars, ngrid, s in [
          ["paraboloid", paraboloid_R_theta, (), 1001, 0],
          ["Wilkinoid", wilkinoid_R_theta, (), 1001, 0],
          [r"Cantoid $\beta = 0.001$", cantoid_R_theta, (0.001,), 1001, 0],
          [r"Cantoid $\beta = 0.01$", cantoid_R_theta, (0.01,), 1001, 0],
          [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 1001, 0],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      ax.plot(th_dg, omega(th, func, *pars), color='b', alpha=0.2, lw=2, label='_nolabel_')
      ax.plot(th_dg, omega(th, spline_func), lw=0.8, label=label)

  ax.legend(title=r"Spline approximations")
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
  ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
  ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
      xlim=[0, 180],
      ylim=[0.0, 2e2],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python test_spline.py
#+END_SRC

#+RESULTS:
[[file:test_spline.pdf]]

**** (x_tâ€™, y_tâ€™) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_xyprime_spline.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected,
                              Spline_R_theta_from_function,
                              paraboloid_R_theta, wilkinoid_R_theta,
                              cantoid_R_theta)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for label, ax, func, pars, ngrid, s in [
          ["paraboloid", axes[0, 0], paraboloid_R_theta, (), 1001, 0],
          ["Wilkinoid", axes[0, 1], wilkinoid_R_theta, (), 1001, 0],
          [r"Cantoid $\beta = 0.001$", axes[1, 0], cantoid_R_theta, (0.001,), 1001, 0],
          [r"Cantoid $\beta = 0.01$", axes[1, 1], cantoid_R_theta, (0.01,), 1001, 0],
          # [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 101, 1e-10],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      th_inf = theta_infinity(spline_func)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, spline_func)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, spline_func)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, spline_func)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_spline.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_spline.pdf]]



** Dragoid application of ~bow_projection~ library

#+BEGIN_SRC python :eval no :tangle dragoid_shape.py
  import sys
  import numpy as np
  from astropy.table import Table
  import statsmodels.api as sm
  from bow_projection import Spline_R_theta_from_grid

  class Dragoid(object):
      def __init__(self, alpha, mu=None, lowess_frac=None):
          if mu is None:
              astring = 'dust-couple-stream'
          else:
              astring = 'dust-couple-div-stream'
          astring += f'-alpha{int(100*alpha):03d}'
          if mu is not None:
              astring += f'-mu{int(100*mu):03d}'
          astring += '.tab'
          self.label = fr"$\alpha_\mathrm{{drag}} =  {alpha:.02f}$"
          if mu is not None:
              self.label += ', ' + fr"$\mu =  {mu:.02f}$"
          t = Table.read(astring, format='ascii.tab')
          dth = np.pi/len(t)
          self.thgrid = t['theta'] + 0.5*dth
          self.Rgrid = t['R']/t['R'][0]
          self.thgrid = np.concatenate([-self.thgrid[::-1], self.thgrid])
          self.Rgrid = np.concatenate([self.Rgrid[::-1], self.Rgrid])
          if lowess_frac is not None:
              # Optionally smooth the shape before fitting spline
              self.Rgrid = sm.nonparametric.lowess(
                  self.Rgrid, self.thgrid, frac=lowess_frac,
                  is_sorted=True, return_sorted=False)
          self.splinefit = Spline_R_theta_from_grid(
                theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the spline fitted result
          return self.splinefit(theta)

  if __name__ == "__main__":

      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')
      figfile = f"test_{lib_name}_radius.pdf"

      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(-np.pi, np.pi, 1001)
      th_dg = np.degrees(th)

      alphas = [0.25, 0.5, 1.0, 2.0] + [4.0, 4.0]
      mus = [None]*4 + [0.2, 0.8]
      for alpha, mu in zip(alphas, mus):
          shape = Dragoid(alpha=alpha, mu=mu, lowess_frac=None)
          ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
                  color='b', alpha=0.2, lw=2, label='_nolabel_')
          ax.plot(th_dg, shape(th), lw=0.8, label=shape.label)

      ax.legend(title=r"Dragoid shapes")
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$R$",
          xlim=[0, 180],
          yscale='log',
          ylim=[0.9, 200.0],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      fig.savefig(figfile)
      print(figfile, end='')

#+END_SRC

**** Test R(\theta) spline fit to dragoid
#+BEGIN_SRC sh :results file
python dragoid_shape.py
#+END_SRC

#+RESULTS:
[[file:test_dragoid_shape_radius.pdf]]
**** Test (x_tâ€™, y_tâ€™) for dragoid
#+BEGIN_SRC python :eval no :tangle test_xyprime_dragoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from dragoid_shape import Dragoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  # For some reason, exactly 30.0 had problems with R0p
  inclinations = [0.0, 15.0, 30.01, 45.0, 60.0, 75.01]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for alpha, ax in zip([0.25, 0.5, 1.0, 2.0], axes.flat):
      shape = Dragoid(alpha=alpha)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)        
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:.0f}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title="Dragoid " + shape.label,
                fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                ncol=2, loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )

  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_dragoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_dragoid.pdf]]

#+BEGIN_SRC python :eval no :tangle test_xyprime_div_dragoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from dragoid_shape import Dragoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  # For some reason, exactly 30.0 had problems with R0p
  inclinations = [0.0, 15.0, 30.01, 45.0, 60.0, 75.01]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  # alphas = [1.0, 1.0, 2.0, 2.0]
  # mus = [0.05, 0.2, 0.05, 0.2]
  alphas = [1.0, 1.0, 4.0, 4.0]
  mus = [0.05, 0.2, 0.2, 0.8]
  for alpha, mu, ax in zip(alphas, mus, axes.flat):
      shape = Dragoid(alpha=alpha, mu=mu)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)        
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:.0f}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title="Dragoid\n" + shape.label,
                fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                ncol=2, loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')
  axes[-1, 0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )

  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_div_dragoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_div_dragoid.pdf]]

** Ancantoid application of ~bow_projection~ library

*** Spline fit to ancantoid shape

+ [ ] Cache the shape to a file 

#+BEGIN_SRC python :eval no :tangle ancantoid_shape.py
  import sys
  import json
  import numpy as np
  from bow_projection import Spline_R_theta_from_grid
  sys.path.append("../CRW-shapes")
  import equation6

  DEBUG = False


  class Ancantoid(object):
      def __init__(self, xi, beta, n=101):
          if DEBUG:
              print("Initialising Ancantoid(xi={xi:.2g}, beta={beta:.2g}, n={n})",
                    file=sys.stderr)
          self.xi = xi
          self.beta = beta
          self.n = n
          self.thgrid = np.linspace(0.0, np.pi, n)
          try:
              # First, look for cached file
              self._load_Rgrid_from_cache()
          except:
              # Failing that, use equation6 to find grid of R, theta
              self.shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
              self.Rgrid = self.shell.radius(self.thgrid) / self.shell.R0
              self._save_Rgrid_to_cache()

          if DEBUG:
              print("thgrid =", self.thgrid, file=sys.stderr)
              print("Rgrid = ", self.Rgrid, file=sys.stderr)
          # Then set up the spline fit to the grid points
          self.splinefit = Spline_R_theta_from_grid(
              theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the spline fitted result
           return self.splinefit(theta)

      def _load_Rgrid_from_cache(self):
          with open(self._cache_filename()) as f:
              data = json.load(f)
          self.thgrid = np.array(data['theta'])
          self.Rgrid = np.array(data['R'])

      def _save_Rgrid_to_cache(self):
          data = {'theta': list(self.thgrid), 'R': list(self.Rgrid)}
          with open(self._cache_filename(), 'w') as f:
              json.dump(data, f, indent=4)

      def _cache_filename(self, suffix=".json"):
          fn = "ancantoid"
          fn += f"-xi{int(100*self.xi):03d}"
          fn += f"-beta{int(100000*self.beta):06d}"
          fn += f"-n{self.n:05d}"
          fn += suffix
          return fn


  if __name__ == "__main__":

      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')
      figfile = f"test_{lib_name}_radius.pdf"


      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(-np.pi, np.pi, 1001)
      th_dg = np.degrees(th)

      for xi, beta in [[0.8, 0.001],
                       [0.8, 0.01],
                       [0.8, 0.1],
                       [0.4, 0.001],
                       [0.4, 0.01],
                       [0.4, 0.1],]:
          label = fr"$\beta = {beta:.3f}$, $\xi = {xi:.1f}$"
          shape = Ancantoid(xi=xi, beta=beta)
          ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
                  color='b', alpha=0.2, lw=2, label='_nolabel_')
          ax.plot(th_dg, shape(th), lw=0.8, label=label)

      ax.legend(title=r"Ancantoid shapes")
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$R$",
          xlim=[0, 180],
          yscale='log',
          ylim=[0.9, 200.0],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      fig.savefig(figfile)
      print(figfile, end='')

#+END_SRC


**** Test R(\theta) spline fit to ancantoid
#+BEGIN_SRC sh :results file
python ancantoid_shape.py
#+END_SRC

#+RESULTS:
[[file:test_ancantoid_shape_radius.pdf]]


**** Test (x_tâ€™, y_tâ€™) for ancantoid

***** \xi = 0.8, 0.4
#+BEGIN_SRC python :eval no :tangle test_xyprime_ancantoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from ancantoid_shape import Ancantoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for xi, beta, ax in [[0.8, 0.001, axes[0, 0]],
                       [0.8, 0.1, axes[0, 1]],
                       [0.4, 0.001, axes[1, 0]],
                       [0.4, 0.1, axes[1, 1]],]:

      label = "Ancantoid\n" fr"$\beta = {beta:.3f}$, $k = {2/xi - 2:.1f}$"
      shape = Ancantoid(xi=xi, beta=beta)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )
  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_ancantoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_ancantoid.pdf]]


***** \xi = 1.0
+ This behaves strangely because of the discontinuity in the slope at \theta = \pi/2
#+BEGIN_SRC python :eval no :tangle test_xyprime_ancantoid_xi10.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from ancantoid_shape import Ancantoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for xi, beta, ax in [[1.0, 0.001, axes[0, 0]],
                       [1.0, 0.02, axes[0, 1]],
                       [1.0, 0.05, axes[1, 0]],
                       [1.0, 0.1, axes[1, 1]],]:

      label = fr"Ancantoid $\beta = {beta:.3f}$, $\xi = {xi:.1f}$"
      shape = Ancantoid(xi=xi, beta=beta, n=301)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_ancantoid_xi10.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_ancantoid_xi10.pdf]]


** Diagnostic plots with the ~bow_projection~ library
This is what we have been working towards


*** Library ~bow_diagnostic.py~ for finding (R_c, R_90)

#+BEGIN_SRC python :eval yes :return result :tangle bow_diagnostic.py
  import numpy as np
  from astropy.table import Table
  import bow_projection as bp

  def parameter_table(inclinations, shape, *shape_args):
      """Diagnostic parameters for `inclinations` from `shape`

  Input argument `inclinations` should be a vector of angles (in
  radians) and input argument `shape` should be callable to give
  R(theta), optionally with additional arguments `shape_args`.  Example
  functions suitable for passing as `shape` can be found in the
  `bow_projection` module.

  Returns an `astropy.table.Table` of characteristic angles and radii.

      """
      rows = [bp.characteristic_radii_projected(inc, shape, *shape_args)
              for inc in inclinations]
      tab = Table(rows=rows)
      tab['inc'] = inclinations
      # Number formatting in output
      for k in tab.colnames:
          if 'theta' in k or 'inc' in k:
              # Angle columns: convert to degrees, give to 1 decimal place
              tab[k] = np.degrees(tab[k]).round(decimals=1)
          else:
              # Radii columns: give to 4 decimal places
              tab[k] = tab[k].round(decimals=4)
      return tab


  if __name__ == '__main__':
      bp.DEBUG = True
      th_inf = bp.theta_infinity(bp.cantoid_R_theta, 0.001)
      inclinations = np.linspace(0.0, th_inf - np.pi/2, 30)
      tab = parameter_table(inclinations, bp.cantoid_R_theta, 0.001)
      Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
      tab_s = parameter_table(inclinations,
                              bp.Spline_R_theta_from_function(
                                  ngrid=1000,
                                  shape_func=bp.cantoid_R_theta,
                                  shape_func_pars=(0.001,)))
      Rc_s, R90_s = tab_s['tilde R_c prime'], tab_s['tilde R_90 prime']

      result = [['inc', 'R_c', 'R_c spline', 'R_90', 'R_90 spline'], None]
      result += list(zip(np.degrees(inclinations).astype(int),
                         Rc, Rc_s, R90, R90_s))
#+END_SRC

#+RESULTS:
| inc |     R_c | R_c spline |    R_90 | R_90 spline |
|-----+--------+-----------+--------+------------|
|   0 | 1.7894 |    1.7894 | 1.7892 |     1.7892 |
|   2 | 1.8088 |    1.8078 | 1.7899 |     1.7898 |
|   5 | 1.8258 |    1.8258 | 1.7904 |     1.7904 |
|   8 | 1.8432 |    1.8433 | 1.7911 |     1.7911 |
|  10 | 1.8627 |    1.8603 | 1.7921 |     1.7918 |
|  13 | 1.8767 |    1.8796 | 1.7926 |     1.7929 |
|  16 |  1.896 |     1.896 | 1.7937 |     1.7937 |
|  18 | 1.9117 |    1.9078 | 1.7945 |      1.794 |
|  21 | 1.9267 |    1.9222 | 1.7953 |     1.7948 |
|  24 | 1.9409 |    1.9359 | 1.7962 |     1.7955 |
|  26 | 1.9488 |    1.9488 | 1.7963 |     1.7963 |
|  29 | 1.9667 |    1.9608 | 1.7979 |     1.7971 |
|  32 | 1.9719 |    1.9719 |  1.798 |      1.798 |
|  34 |  1.989 |     1.989 |    1.8 |        1.8 |
|  37 | 1.9915 |    1.9915 | 1.8002 |     1.8002 |
|  40 | 2.0076 |    2.0076 | 1.8027 |     1.8027 |
|  43 | 2.0158 |    2.0158 | 1.8045 |     1.8045 |
|  45 | 2.0151 |    2.0151 | 1.8056 |     1.8056 |
|  48 | 2.0307 |    2.0221 | 1.8099 |     1.8086 |
|  51 | 2.0293 |    2.0382 | 1.8127 |      1.814 |
|  53 | 2.0373 |    2.0465 | 1.8184 |     1.8197 |
|  56 | 2.0473 |    2.0473 | 1.8263 |     1.8263 |
|  59 | 2.0707 |    2.0707 |  1.839 |      1.839 |
|  61 | 2.0813 |    2.0813 | 1.8542 |     1.8542 |
|  64 | 2.1136 |    2.1243 | 1.8794 |     1.8809 |
|  67 |  2.169 |    2.1807 | 1.9195 |     1.9211 |
|  69 |  2.288 |    2.2742 | 1.9902 |     1.9886 |
|  72 | 2.5353 |    2.5353 | 2.1268 |     2.1268 |
|  75 | 3.4723 |    3.4723 | 2.4906 |     2.4906 |
|  77 |    nan |       nan |    nan |        nan |

+ So there are two problems here:
  1. The direct function has problems for inc = 1, 2, 3 degrees, while the spline fit is fine there
     - (not apparent any more with this particular list of incs)
     - But we get occasional unbracketed roots errors if we use slightly different lists
  2. The spline fit doesnâ€™t quite get to the asymptotic angle




*** Test ~bow_diagnostic.py~ for the wilkinoid

#+name: test-wilkinoid-diagnostic
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.2
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = bp.Spline_R_theta_from_function(ngrid=1000,
                                          shape_func=bp.wilkinoid_R_theta)
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-wilkinoid-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    174.2 |           1.732 |         1.6652 |    0 |
|   1.0003 |    2.9 |      90 |    174.2 |           1.732 |         1.6647 |  1.7 |
|   1.0012 |    5.7 |    90.2 |    174.2 |          1.7319 |         1.6639 |  3.4 |
|   1.0027 |    8.6 |    90.4 |    174.2 |          1.7317 |         1.6631 |  5.2 |
|   1.0048 |   11.5 |    90.6 |    174.2 |          1.7314 |         1.6622 |  6.9 |
|   1.0076 |   14.3 |      91 |    174.2 |           1.731 |         1.6611 |  8.6 |
|   1.0109 |   17.2 |    91.4 |    174.2 |          1.7306 |         1.6599 | 10.3 |
|   1.0149 |   20.1 |      92 |    174.2 |            1.73 |         1.6586 |   12 |
|   1.0196 |     23 |    92.6 |    174.2 |          1.7294 |         1.6568 | 13.8 |
|   1.0249 |   25.9 |    93.2 |    174.2 |          1.7287 |         1.6555 | 15.5 |
|   1.0309 |   28.8 |      94 |    174.2 |           1.728 |         1.6538 | 17.2 |
|   1.0376 |   31.7 |    94.8 |    174.2 |          1.7271 |         1.6521 | 18.9 |
|   1.0451 |   34.6 |    95.7 |    174.2 |          1.7261 |         1.6497 | 20.6 |
|   1.0532 |   37.5 |    96.7 |    174.2 |          1.7251 |         1.6476 | 22.3 |
|   1.0622 |   40.4 |    97.7 |    174.2 |           1.724 |         1.6455 | 24.1 |
|    1.072 |   43.4 |    98.8 |    174.2 |          1.7228 |         1.6439 | 25.8 |
|   1.0826 |   46.3 |     100 |    174.2 |          1.7214 |         1.6409 | 27.5 |
|   1.0941 |   49.3 |   101.2 |    174.2 |          1.7201 |         1.6392 | 29.2 |
|   1.1066 |   52.2 |   102.5 |    174.2 |          1.7186 |         1.6368 | 30.9 |
|   1.1201 |   55.2 |   103.9 |    174.2 |          1.7169 |         1.6334 | 32.7 |
|   1.1347 |   58.2 |   105.3 |    174.2 |          1.7152 |         1.6307 | 34.4 |
|   1.1503 |   61.3 |   106.8 |    174.2 |          1.7134 |         1.6279 | 36.1 |
|   1.1672 |   64.3 |   108.3 |    174.2 |          1.7115 |          1.625 | 37.8 |
|   1.1853 |   67.4 |   109.9 |    174.2 |          1.7095 |          1.622 | 39.5 |
|   1.2047 |   70.4 |   111.6 |    174.2 |          1.7074 |         1.6199 | 41.3 |
|   1.2257 |   73.5 |   113.3 |    174.2 |          1.7051 |         1.6158 |   43 |
|   1.2482 |   76.7 |   115.1 |    174.2 |          1.7029 |         1.6135 | 44.7 |
|   1.2726 |   79.8 |   116.9 |    174.2 |          1.7003 |         1.6091 | 46.4 |
|   1.2987 |     83 |   118.8 |    174.2 |          1.6977 |         1.6056 | 48.1 |
|    1.327 |   86.2 |   120.7 |    174.2 |           1.695 |          1.602 | 49.9 |
|   1.3574 |   89.5 |   122.7 |    174.2 |          1.6922 |         1.5994 | 51.6 |
|   1.3904 |   92.7 |   124.8 |    174.2 |          1.6892 |         1.5955 | 53.3 |
|   1.4261 |   96.1 |   126.8 |    174.2 |          1.6861 |         1.5915 |   55 |
|   1.4651 |   99.4 |     129 |    174.2 |          1.6828 |         1.5863 | 56.7 |
|   1.5075 |  102.8 |   131.2 |    174.2 |          1.6794 |          1.582 | 58.4 |
|   1.5537 |  106.3 |   133.4 |    174.2 |           1.676 |         1.5787 | 60.2 |
|   1.6046 |  109.8 |   135.7 |    174.2 |          1.6722 |          1.573 | 61.9 |
|   1.6606 |  113.4 |   138.1 |    174.2 |          1.6684 |         1.5682 | 63.6 |
|   1.7226 |    117 |   140.5 |    174.2 |          1.6644 |         1.5632 | 65.3 |
|   1.7916 |  120.7 |   142.9 |    174.2 |          1.6603 |         1.5581 |   67 |
|   1.8689 |  124.4 |   145.4 |    174.2 |          1.6562 |         1.5537 | 68.8 |
|   1.9565 |  128.3 |     148 |    174.2 |          1.6518 |         1.5473 | 70.5 |
|   2.0564 |  132.2 |   150.6 |    174.2 |          1.6474 |         1.5416 | 72.2 |
|   2.1718 |  136.3 |   153.2 |    174.2 |           1.643 |         1.5357 | 73.9 |
|   2.3068 |  140.4 |   155.9 |    174.2 |          1.6386 |         1.5305 | 75.6 |
|   2.4683 |  144.7 |   158.7 |    174.2 |           1.634 |         1.5236 | 77.4 |
|   2.6655 |  149.1 |   161.5 |    174.2 |          1.6296 |         1.5175 | 79.1 |
|   2.9142 |  153.6 |   164.3 |    174.2 |          1.6254 |         1.5122 | 80.8 |
|   3.2427 |  158.3 |   167.2 |    174.2 |          1.6214 |         1.5057 | 82.5 |
|   3.7057 |  163.1 |   170.1 |    174.2 |          1.6179 |         1.5009 | 84.2 |


*** Test ~bow_diagnostic.py~ for the cantoids
+ \beta = 0.1 â€“ R_90 starts going up immediately, but R_c drops about 1% and then back again over inc = 0 \to 23 deg. Bow is gone by 37 deg.  Strange reduction in R_c near the end
+ \beta = 0.01 â€“ As for \beta = 0.1 but over 0 \to 37 deg and gone by 63 deg
+ \beta = 0.001 â€“ For inc = 0 \to 45 deg, almost nothing happens. R_c goes down monotonically by about 3%.  R_90 goes down and then up, but only varies by about 0.1%. From 45 \to 60, both go up but only by a few percent. R_c regains its initial value at 66 deg.  Then from 66 \to 75 deg, they go up faster
+ \beta = 0.0001 â€“ This is very similar to the wilkinoid, except for the highest inclinations. Both radii decline until 60â€“70 deg, but only by 2% for R_90 and 5% for R_c.  Then they start to go up again


#+name: test-cantoid-diagnostic
#+header: :var beta=0.001
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.2
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = bp.Spline_R_theta_from_function(ngrid=1000,
                                          shape_func=bp.cantoid_R_theta,
                                          shape_func_pars=(beta,))
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-cantoid-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    165.4 |          1.7884 |         1.7192 |    0 |
|   1.0003 |    2.6 |      90 |    165.4 |          1.7884 |         1.7186 |  1.5 |
|   1.0011 |    5.3 |    90.1 |    165.4 |          1.7884 |         1.7179 |  3.1 |
|   1.0024 |      8 |    90.3 |    165.4 |          1.7883 |         1.7171 |  4.6 |
|   1.0042 |   10.6 |    90.6 |    165.4 |          1.7883 |         1.7163 |  6.2 |
|   1.0066 |   13.3 |    90.9 |    165.4 |          1.7882 |         1.7152 |  7.7 |
|   1.0095 |   15.9 |    91.2 |    165.4 |          1.7881 |         1.7143 |  9.2 |
|    1.013 |   18.6 |    91.7 |    165.4 |          1.7879 |          1.713 | 10.8 |
|    1.017 |   21.2 |    92.2 |    165.4 |          1.7878 |         1.7118 | 12.3 |
|   1.0216 |   23.9 |    92.8 |    165.4 |          1.7877 |         1.7109 | 13.9 |
|   1.0268 |   26.6 |    93.4 |    165.4 |          1.7875 |         1.7091 | 15.4 |
|   1.0325 |   29.3 |    94.1 |    165.4 |          1.7873 |         1.7083 | 16.9 |
|    1.039 |     32 |    94.9 |    165.4 |          1.7871 |         1.7063 | 18.5 |
|    1.046 |   34.7 |    95.8 |    165.4 |           1.787 |         1.7049 |   20 |
|   1.0537 |   37.4 |    96.7 |    165.4 |          1.7868 |         1.7034 | 21.6 |
|   1.0621 |   40.1 |    97.6 |    165.4 |          1.7866 |         1.7018 | 23.1 |
|   1.0712 |   42.8 |    98.6 |    165.4 |          1.7864 |         1.7002 | 24.6 |
|   1.0811 |   45.6 |    99.7 |    165.4 |          1.7863 |         1.6987 | 26.2 |
|   1.0917 |   48.3 |   100.9 |    165.4 |          1.7862 |          1.698 | 27.7 |
|   1.1032 |   51.1 |   102.1 |    165.4 |           1.786 |         1.6955 | 29.3 |
|   1.1154 |   53.8 |   103.3 |    165.4 |           1.786 |         1.6949 | 30.8 |
|   1.1287 |   56.6 |   104.6 |    165.4 |           1.786 |         1.6934 | 32.3 |
|   1.1429 |   59.4 |     106 |    165.4 |          1.7859 |         1.6907 | 33.9 |
|   1.1581 |   62.3 |   107.4 |    165.4 |          1.7861 |         1.6904 | 35.4 |
|   1.1745 |   65.1 |   108.8 |    165.4 |          1.7861 |         1.6877 |   37 |
|    1.192 |     68 |   110.4 |    165.4 |          1.7864 |         1.6863 | 38.5 |
|   1.2107 |   70.8 |   111.9 |    165.4 |          1.7868 |         1.6863 |   40 |
|   1.2309 |   73.7 |   113.6 |    165.4 |          1.7872 |         1.6836 | 41.6 |
|   1.2525 |   76.7 |   115.2 |    165.4 |          1.7879 |         1.6824 | 43.1 |
|   1.2757 |   79.6 |   116.9 |    165.4 |          1.7887 |         1.6813 | 44.6 |
|   1.3006 |   82.6 |   118.7 |    165.4 |          1.7898 |         1.6804 | 46.2 |
|   1.3274 |   85.7 |   120.5 |    165.4 |          1.7912 |         1.6796 | 47.7 |
|   1.3562 |   88.7 |   122.4 |    165.4 |          1.7931 |         1.6807 | 49.3 |
|   1.3873 |   91.8 |   124.3 |    165.4 |          1.7952 |         1.6805 | 50.8 |
|   1.4212 |   94.9 |   126.3 |    165.4 |          1.7977 |         1.6788 | 52.3 |
|   1.4578 |   98.1 |   128.3 |    165.4 |           1.801 |         1.6792 | 53.9 |
|   1.4976 |  101.3 |   130.4 |    165.4 |           1.805 |         1.6801 | 55.4 |
|    1.541 |  104.6 |   132.6 |    165.4 |          1.8102 |         1.6834 |   57 |
|   1.5886 |    108 |   134.7 |    165.4 |          1.8164 |         1.6856 | 58.5 |
|   1.6411 |  111.4 |     137 |    165.4 |          1.8242 |         1.6888 |   60 |
|   1.6992 |  114.9 |   139.3 |    165.4 |          1.8339 |         1.6932 | 61.6 |
|   1.7642 |  118.5 |   141.7 |    165.4 |          1.8461 |         1.6972 | 63.1 |
|    1.837 |  122.1 |   144.1 |    165.4 |          1.8619 |         1.7052 | 64.7 |
|   1.9197 |  125.9 |   146.6 |    165.4 |          1.8826 |         1.7162 | 66.2 |
|   2.0147 |  129.8 |   149.1 |    165.4 |          1.9101 |         1.7314 | 67.7 |
|   2.1254 |  133.9 |   151.7 |    165.4 |          1.9481 |         1.7552 | 69.3 |
|    2.258 |  138.2 |   154.4 |    165.4 |          2.0019 |         1.7834 | 70.8 |
|   2.4205 |  142.7 |   157.2 |    165.4 |          2.0842 |         1.8334 | 72.4 |
|   2.6299 |  147.6 |   160.1 |    165.4 |           2.221 |           1.91 | 73.9 |
|   2.9224 |    153 |     163 |    165.4 |          2.4926 |         2.0492 | 75.4 |


#+call: test-cantoid-diagnostic(beta=0.1)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    127.6 |          2.5087 |         2.4246 |    0 |
|   1.0002 |    1.9 |      90 |    127.6 |          2.5089 |         2.4219 |  0.8 |
|   1.0006 |    3.7 |    90.1 |    127.6 |          2.5095 |          2.419 |  1.5 |
|   1.0012 |    5.6 |    90.1 |    127.6 |          2.5105 |         2.4165 |  2.3 |
|   1.0021 |    7.5 |    90.3 |    127.6 |           2.512 |         2.4141 |  3.1 |
|   1.0033 |    9.4 |    90.4 |    127.6 |          2.5139 |         2.4119 |  3.8 |
|   1.0048 |   11.2 |    90.6 |    127.6 |          2.5163 |         2.4111 |  4.6 |
|   1.0065 |   13.1 |    90.8 |    127.6 |          2.5191 |          2.408 |  5.4 |
|   1.0085 |     15 |      91 |    127.6 |          2.5225 |         2.4079 |  6.1 |
|   1.0108 |   16.9 |    91.3 |    127.6 |          2.5263 |         2.4066 |  6.9 |
|   1.0133 |   18.8 |    91.6 |    127.6 |          2.5306 |         2.4055 |  7.7 |
|   1.0162 |   20.7 |    91.9 |    127.6 |          2.5353 |         2.4021 |  8.4 |
|   1.0193 |   22.6 |    92.3 |    127.6 |          2.5407 |         2.4039 |  9.2 |
|   1.0228 |   24.5 |    92.7 |    127.6 |          2.5465 |         2.4003 |   10 |
|   1.0266 |   26.4 |    93.1 |    127.6 |           2.553 |         2.3996 | 10.7 |
|   1.0306 |   28.3 |    93.6 |    127.6 |          2.5601 |         2.3992 | 11.5 |
|    1.035 |   30.3 |      94 |    127.6 |          2.5679 |         2.3989 | 12.3 |
|   1.0397 |   32.2 |    94.6 |    127.6 |          2.5765 |         2.4037 | 13.1 |
|   1.0448 |   34.2 |    95.1 |    127.6 |          2.5858 |         2.4043 | 13.8 |
|   1.0503 |   36.1 |    95.7 |    127.6 |          2.5956 |         2.3996 | 14.6 |
|   1.0561 |   38.1 |    96.3 |    127.6 |          2.6064 |         2.4002 | 15.4 |
|   1.0624 |   40.1 |    96.9 |    127.6 |          2.6182 |         2.4011 | 16.1 |
|   1.0688 |   42.1 |    97.6 |    127.6 |          2.6313 |         2.4096 | 16.9 |
|    1.076 |   44.1 |    98.3 |    127.6 |          2.6448 |         2.4037 | 17.7 |
|   1.0834 |   46.1 |      99 |    127.6 |          2.6603 |         2.4139 | 18.4 |
|   1.0915 |   48.2 |    99.7 |    127.6 |          2.6761 |         2.4072 | 19.2 |
|      1.1 |   50.2 |   100.5 |    127.6 |          2.6939 |         2.4093 |   20 |
|    1.109 |   52.3 |   101.3 |    127.6 |          2.7131 |         2.4116 | 20.7 |
|   1.1186 |   54.4 |   102.2 |    127.6 |          2.7341 |         2.4141 | 21.5 |
|   1.1285 |   56.5 |     103 |    127.6 |          2.7578 |         2.4293 | 22.3 |
|   1.1396 |   58.7 |   103.9 |    127.6 |          2.7821 |         2.4195 |   23 |
|   1.1507 |   60.9 |   104.9 |    127.6 |          2.8105 |          2.437 | 23.8 |
|   1.1629 |   63.1 |   105.8 |    127.6 |          2.8408 |          2.441 | 24.6 |
|   1.1764 |   65.3 |   106.8 |    127.6 |          2.8732 |         2.4274 | 25.3 |
|   1.1899 |   67.6 |   107.8 |    127.6 |          2.9114 |         2.4484 | 26.1 |
|   1.2048 |   69.9 |   108.8 |    127.6 |          2.9527 |         2.4514 | 26.9 |
|   1.2214 |   72.3 |   109.9 |    127.6 |          2.9974 |          2.431 | 27.6 |
|   1.2386 |   74.7 |     111 |    127.6 |          3.0492 |         2.4295 | 28.4 |
|   1.2563 |   77.1 |   112.1 |    127.6 |          3.1101 |         2.4526 | 29.2 |
|   1.2773 |   79.6 |   113.3 |    127.6 |          3.1751 |         2.4176 | 29.9 |
|   1.2981 |   82.2 |   114.5 |    127.6 |          3.2554 |         2.4374 | 30.7 |
|   1.3233 |   84.9 |   115.7 |    127.6 |           3.343 |         2.3824 | 31.5 |
|   1.3483 |   87.7 |   116.9 |    127.6 |          3.4539 |         2.3893 | 32.2 |
|   1.3778 |   90.6 |   118.2 |    127.6 |          3.5833 |         2.3406 |   33 |
|   1.4112 |   93.6 |   119.5 |    127.6 |          3.7423 |         2.2625 | 33.8 |
|   1.4534 |   96.8 |   120.8 |    127.6 |          3.9338 |         2.0801 | 34.5 |
|   1.4977 |  100.2 |   122.2 |    127.6 |          4.2028 |         1.9343 | 35.3 |
|   1.5614 |    104 |   123.6 |    127.6 |          4.5519 |         1.6066 | 36.1 |
|   1.6703 |  108.2 |     125 |    127.6 |          5.0121 |         1.0941 | 36.9 |
|   2.1507 |  113.1 |   126.5 |    127.6 |          4.9983 |         0.4141 | 37.6 |

#+call: test-cantoid-diagnostic(beta=0.01)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    152.7 |          1.9226 |         1.8488 |    0 |
|   1.0002 |    2.4 |      90 |    152.7 |          1.9226 |         1.8479 |  1.3 |
|   1.0009 |    4.7 |    90.1 |    152.7 |          1.9227 |         1.8471 |  2.6 |
|   1.0019 |    7.1 |    90.3 |    152.7 |          1.9229 |         1.8462 |  3.8 |
|   1.0034 |    9.5 |    90.4 |    152.7 |          1.9233 |         1.8453 |  5.1 |
|   1.0054 |   11.9 |    90.7 |    152.7 |          1.9237 |         1.8447 |  6.4 |
|   1.0078 |   14.2 |      91 |    152.7 |          1.9242 |         1.8439 |  7.7 |
|   1.0106 |   16.6 |    91.4 |    152.7 |          1.9248 |          1.843 |    9 |
|   1.0139 |     19 |    91.8 |    152.7 |          1.9255 |         1.8418 | 10.2 |
|   1.0176 |   21.4 |    92.2 |    152.7 |          1.9263 |         1.8409 | 11.5 |
|   1.0218 |   23.8 |    92.8 |    152.7 |          1.9273 |         1.8401 | 12.8 |
|   1.0265 |   26.2 |    93.3 |    152.7 |          1.9284 |           1.84 | 14.1 |
|   1.0317 |   28.6 |      94 |    152.7 |          1.9296 |         1.8394 | 15.4 |
|   1.0374 |     31 |    94.6 |    152.7 |          1.9309 |         1.8378 | 16.6 |
|   1.0436 |   33.4 |    95.4 |    152.7 |          1.9324 |         1.8382 | 17.9 |
|   1.0504 |   35.8 |    96.1 |    152.7 |           1.934 |         1.8366 | 19.2 |
|   1.0577 |   38.3 |      97 |    152.7 |          1.9359 |         1.8374 | 20.5 |
|   1.0656 |   40.7 |    97.9 |    152.7 |          1.9379 |         1.8371 | 21.7 |
|   1.0741 |   43.2 |    98.8 |    152.7 |          1.9402 |          1.837 |   23 |
|   1.0833 |   45.7 |    99.8 |    152.7 |          1.9425 |         1.8354 | 24.3 |
|   1.0931 |   48.1 |   100.8 |    152.7 |          1.9453 |         1.8371 | 25.6 |
|   1.1037 |   50.6 |   101.8 |    152.7 |          1.9482 |         1.8356 | 26.9 |
|   1.1149 |   53.1 |     103 |    152.7 |          1.9516 |         1.8378 | 28.1 |
|   1.1269 |   55.7 |   104.1 |    152.7 |          1.9552 |         1.8385 | 29.4 |
|   1.1399 |   58.2 |   105.3 |    152.7 |           1.959 |         1.8372 | 30.7 |
|   1.1536 |   60.8 |   106.6 |    152.7 |          1.9634 |         1.8382 |   32 |
|   1.1682 |   63.4 |   107.9 |    152.7 |          1.9684 |         1.8419 | 33.3 |
|    1.184 |     66 |   109.2 |    152.7 |          1.9736 |         1.8411 | 34.5 |
|   1.2007 |   68.6 |   110.6 |    152.7 |          1.9796 |         1.8431 | 35.8 |
|   1.2185 |   71.2 |   112.1 |    152.7 |          1.9865 |         1.8484 | 37.1 |
|   1.2376 |   73.9 |   113.5 |    152.7 |          1.9939 |         1.8514 | 38.4 |
|   1.2581 |   76.6 |   115.1 |    152.7 |          2.0022 |         1.8549 | 39.7 |
|     1.28 |   79.4 |   116.6 |    152.7 |          2.0116 |         1.8591 | 40.9 |
|   1.3036 |   82.1 |   118.3 |    152.7 |          2.0221 |          1.864 | 42.2 |
|   1.3291 |     85 |   119.9 |    152.7 |          2.0338 |          1.866 | 43.5 |
|   1.3562 |   87.8 |   121.6 |    152.7 |          2.0477 |         1.8764 | 44.8 |
|   1.3859 |   90.7 |   123.4 |    152.7 |          2.0629 |         1.8801 | 46.1 |
|   1.4178 |   93.7 |   125.2 |    152.7 |          2.0808 |          1.889 | 47.3 |
|   1.4522 |   96.7 |     127 |    152.7 |          2.1021 |         1.9041 | 48.6 |
|   1.4904 |   99.8 |   128.9 |    152.7 |          2.1262 |         1.9118 | 49.9 |
|   1.5316 |  102.9 |   130.9 |    152.7 |          2.1556 |         1.9319 | 51.2 |
|   1.5773 |  106.2 |   132.9 |    152.7 |          2.1905 |         1.9499 | 52.5 |
|   1.6285 |  109.5 |   134.9 |    152.7 |          2.2324 |         1.9653 | 53.7 |
|   1.6851 |    113 |     137 |    152.7 |          2.2858 |         1.9981 |   55 |
|   1.7495 |  116.6 |   139.2 |    152.7 |           2.353 |         2.0306 | 56.3 |
|   1.8236 |  120.4 |   141.4 |    152.7 |          2.4414 |         2.0709 | 57.6 |
|   1.9104 |  124.4 |   143.7 |    152.7 |          2.5628 |          2.121 | 58.8 |
|   2.0152 |  128.7 |     146 |    152.7 |          2.7404 |          2.181 | 60.1 |
|   2.1495 |  133.5 |   148.4 |    152.7 |          3.0259 |         2.2153 | 61.4 |
|   2.3352 |  139.1 |   150.9 |    152.7 |          3.5901 |         2.1653 | 62.7 |

#+call: test-cantoid-diagnostic(beta=0.0001)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    171.1 |          1.7495 |         1.6819 |    0 |
|   1.0003 |    2.8 |      90 |    171.1 |          1.7495 |         1.6814 |  1.7 |
|   1.0012 |    5.6 |    90.2 |    171.1 |          1.7494 |         1.6807 |  3.3 |
|   1.0026 |    8.4 |    90.3 |    171.1 |          1.7492 |         1.6798 |    5 |
|   1.0046 |   11.1 |    90.6 |    171.1 |           1.749 |          1.679 |  6.6 |
|   1.0072 |   13.9 |      91 |    171.1 |          1.7488 |         1.6778 |  8.3 |
|   1.0104 |   16.7 |    91.4 |    171.1 |          1.7484 |         1.6766 |  9.9 |
|   1.0142 |   19.5 |    91.9 |    171.1 |           1.748 |         1.6753 | 11.6 |
|   1.0186 |   22.3 |    92.4 |    171.1 |          1.7476 |         1.6742 | 13.2 |
|   1.0236 |   25.1 |    93.1 |    171.1 |          1.7471 |         1.6728 | 14.9 |
|   1.0293 |     28 |    93.8 |    171.1 |          1.7465 |         1.6708 | 16.5 |
|   1.0357 |   30.8 |    94.6 |    171.1 |          1.7459 |         1.6692 | 18.2 |
|   1.0427 |   33.6 |    95.4 |    171.1 |          1.7452 |         1.6679 | 19.9 |
|   1.0505 |   36.4 |    96.3 |    171.1 |          1.7444 |         1.6656 | 21.5 |
|   1.0589 |   39.3 |    97.3 |    171.1 |          1.7437 |         1.6643 | 23.2 |
|   1.0682 |   42.1 |    98.4 |    171.1 |          1.7428 |         1.6623 | 24.8 |
|   1.0782 |     45 |    99.5 |    171.1 |          1.7419 |         1.6603 | 26.5 |
|   1.0891 |   47.9 |   100.7 |    171.1 |          1.7409 |         1.6582 | 28.1 |
|   1.1009 |   50.8 |   101.9 |    171.1 |          1.7399 |         1.6561 | 29.8 |
|   1.1136 |   53.7 |   103.2 |    171.1 |          1.7388 |         1.6539 | 31.4 |
|   1.1273 |   56.6 |   104.6 |    171.1 |          1.7377 |         1.6517 | 33.1 |
|    1.142 |   59.5 |     106 |    171.1 |          1.7365 |         1.6493 | 34.7 |
|   1.1578 |   62.5 |   107.5 |    171.1 |          1.7352 |          1.646 | 36.4 |
|   1.1748 |   65.5 |     109 |    171.1 |          1.7339 |         1.6435 | 38.1 |
|   1.1931 |   68.5 |   110.6 |    171.1 |          1.7326 |          1.641 | 39.7 |
|   1.2126 |   71.5 |   112.2 |    171.1 |          1.7313 |         1.6396 | 41.4 |
|   1.2338 |   74.5 |   113.9 |    171.1 |          1.7298 |         1.6359 |   43 |
|   1.2563 |   77.6 |   115.7 |    171.1 |          1.7285 |         1.6344 | 44.7 |
|   1.2808 |   80.7 |   117.5 |    171.1 |           1.727 |         1.6306 | 46.3 |
|    1.307 |   83.8 |   119.3 |    171.1 |          1.7255 |         1.6279 |   48 |
|   1.3353 |   86.9 |   121.2 |    171.1 |          1.7241 |         1.6252 | 49.6 |
|   1.3657 |   90.1 |   123.2 |    171.1 |          1.7228 |         1.6237 | 51.3 |
|   1.3988 |   93.3 |   125.2 |    171.1 |          1.7213 |         1.6198 | 52.9 |
|   1.4345 |   96.6 |   127.3 |    171.1 |          1.7201 |         1.6183 | 54.6 |
|   1.4735 |   99.9 |   129.4 |    171.1 |          1.7188 |         1.6144 | 56.3 |
|   1.5158 |  103.2 |   131.5 |    171.1 |          1.7179 |         1.6131 | 57.9 |
|   1.5621 |  106.6 |   133.8 |    171.1 |          1.7171 |         1.6105 | 59.6 |
|   1.6129 |  110.1 |     136 |    171.1 |          1.7165 |         1.6081 | 61.2 |
|   1.6691 |  113.6 |   138.4 |    171.1 |          1.7162 |         1.6046 | 62.9 |
|   1.7313 |  117.2 |   140.7 |    171.1 |          1.7166 |         1.6027 | 64.5 |
|   1.8005 |  120.9 |   143.2 |    171.1 |          1.7179 |         1.6024 | 66.2 |
|   1.8784 |  124.6 |   145.7 |    171.1 |            1.72 |         1.6014 | 67.8 |
|   1.9668 |  128.5 |   148.2 |    171.1 |          1.7234 |         1.6012 | 69.5 |
|   2.0681 |  132.4 |   150.8 |    171.1 |          1.7289 |         1.6023 | 71.1 |
|   2.1861 |  136.5 |   153.5 |    171.1 |          1.7371 |         1.6038 | 72.8 |
|   2.3252 |  140.7 |   156.2 |    171.1 |          1.7498 |         1.6105 | 74.5 |
|   2.4939 |    145 |   159.1 |    171.1 |          1.7694 |         1.6205 | 76.1 |
|   2.7047 |  149.6 |   161.9 |    171.1 |          1.8008 |         1.6367 | 77.8 |
|   2.9805 |  154.4 |   164.9 |    171.1 |          1.8552 |         1.6687 | 79.4 |
|   3.3697 |  159.5 |   167.9 |    171.1 |          1.9632 |         1.7355 | 81.1 |


*** Test ~bow_diagnostic.py~ for the dragoids
+ Something strange is going on with these
+ R_0â€™ is fine and R_90â€™ is mostly fine too, but R_câ€™ is all over the place, especially for low inclinations
+ This turned out to be because of the small value of ~bp.SCALE_NEIGHBORHOOD~, which meant it was trying to fit small fluctuations in the radius close to the axis
  + These are really there in the data, and must be due to the discretization in the impact parameter of the drag models
+ So, if I use ~bp.SCALE_NEIGHBORHOOD = 0.2~, which corresponds to 36 degrees, then things are much better
+ Results are:
  + R_c increases slightly at constant R_90 for i = 0 \to 20 deg, but this is hardly noticeable: for instance, 1.89 \to 1.92 for \alpha_drag = 0.25
  + Then R_c goes back again, and then keeps on decreasing, while R_90 starts decreasing also, maintaining R_90 \approx 1.03 R_c
#+name: test-dragoid-diagnostic
#+header: :var alpha=0.25 mu=0
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import dragoid_shape
  import bow_diagnostic

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.2
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = dragoid_shape.Dragoid(alpha=alpha, mu=None if mu == 0 else mu)

  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-dragoid-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   0.9999 |      0 |      90 |    163.3 |          1.9583 |           1.89 |    0 |
|   1.0001 |    3.9 |      90 |    163.3 |          1.9586 |         1.9048 |  1.5 |
|   1.0008 |    6.5 |    90.1 |    163.3 |          1.9591 |         1.9221 |    3 |
|   1.0023 |   11.2 |    90.3 |    163.3 |          1.9591 |         1.9228 |  4.5 |
|   1.0045 |    9.3 |    90.6 |    163.3 |          1.9592 |         1.9299 |    6 |
|   1.0073 |   11.6 |    90.9 |    163.3 |          1.9594 |         1.9354 |  7.5 |
|   1.0109 |   16.1 |    91.4 |    163.3 |          1.9593 |          1.929 |    9 |
|   1.0152 |   20.3 |    91.8 |    163.3 |          1.9594 |         1.9257 | 10.5 |
|   1.0202 |   23.5 |    92.3 |    163.3 |           1.959 |         1.9235 |   12 |
|   1.0259 |   26.4 |      93 |    163.3 |          1.9587 |         1.9237 | 13.5 |
|   1.0323 |   28.6 |    93.7 |    163.3 |          1.9586 |         1.9222 |   15 |
|   1.0395 |     32 |    94.4 |    163.3 |          1.9583 |         1.9226 | 16.4 |
|   1.0475 |   35.4 |    95.3 |    163.3 |          1.9577 |         1.9199 | 17.9 |
|   1.0561 |   37.4 |    96.2 |    163.3 |          1.9583 |         1.9244 | 19.4 |
|   1.0658 |   40.3 |      97 |    163.3 |          1.9578 |         1.9242 | 20.9 |
|   1.0765 |   43.8 |    98.1 |    163.3 |          1.9569 |         1.9133 | 22.4 |
|   1.0879 |   47.3 |    99.1 |    163.3 |          1.9562 |         1.9154 | 23.9 |
|   1.1002 |   49.6 |   100.2 |    163.3 |          1.9557 |         1.9172 | 25.4 |
|   1.1136 |   52.1 |   101.5 |    163.3 |          1.9552 |         1.9196 | 26.9 |
|   1.1284 |   55.5 |   102.6 |    163.3 |           1.954 |         1.9118 | 28.4 |
|   1.1441 |   58.2 |     104 |    163.3 |          1.9533 |         1.9105 | 29.9 |
|   1.1615 |     62 |   105.4 |    163.3 |          1.9516 |         1.8947 | 31.4 |
|   1.1793 |   64.5 |   106.5 |    163.3 |          1.9518 |         1.8993 | 32.9 |
|   1.1988 |   66.6 |     108 |    163.3 |          1.9509 |         1.9008 | 34.4 |
|   1.2198 |     70 |   109.7 |    163.3 |          1.9488 |         1.8953 | 35.9 |
|   1.2423 |   73.1 |   110.8 |    163.3 |          1.9475 |          1.894 | 37.4 |
|   1.2665 |     75 |   112.4 |    163.3 |          1.9457 |         1.8949 | 38.9 |
|   1.2922 |   77.6 |     114 |    163.3 |          1.9446 |         1.8972 | 40.4 |
|   1.3209 |   82.6 |   115.7 |    163.3 |          1.9417 |         1.8793 | 41.9 |
|   1.3514 |   85.3 |   117.1 |    163.3 |          1.9392 |         1.8702 | 43.4 |
|   1.3827 |   87.3 |   118.9 |    163.3 |          1.9383 |         1.8876 | 44.9 |
|   1.4182 |   90.2 |   120.5 |    163.3 |          1.9349 |         1.8711 | 46.4 |
|   1.4555 |   93.8 |   122.2 |    163.3 |           1.933 |         1.8727 | 47.8 |
|   1.4963 |   96.4 |   123.9 |    163.3 |          1.9297 |         1.8697 | 49.3 |
|   1.5402 |   99.5 |   125.7 |    163.3 |          1.9263 |         1.8647 | 50.8 |
|   1.5879 |  102.3 |   127.5 |    163.3 |          1.9225 |         1.8542 | 52.3 |
|   1.6402 |  106.1 |   129.4 |    163.3 |          1.9174 |         1.8383 | 53.8 |
|   1.6953 |  107.9 |   131.1 |    163.3 |           1.914 |         1.8462 | 55.3 |
|   1.7555 |  110.4 |     133 |    163.3 |          1.9099 |          1.849 | 56.8 |
|   1.8219 |  113.9 |   134.8 |    163.3 |          1.9046 |         1.8405 | 58.3 |
|   1.8947 |  116.8 |   136.7 |    163.3 |          1.8989 |         1.8343 | 59.8 |
|   1.9743 |  119.6 |   138.6 |    163.3 |           1.892 |         1.8285 | 61.3 |
|   2.0618 |  122.3 |   140.4 |    163.3 |          1.8845 |         1.8229 | 62.8 |
|   2.1587 |  125.3 |   142.3 |    163.3 |          1.8762 |         1.8127 | 64.3 |
|   2.2657 |    128 |   144.3 |    163.3 |           1.867 |         1.8063 | 65.8 |
|   2.3856 |  131.1 |   146.2 |    163.3 |          1.8561 |          1.794 | 67.3 |
|   2.5192 |  133.8 |   148.1 |    163.3 |           1.844 |         1.7834 | 68.8 |
|   2.6708 |  136.8 |     150 |    163.3 |          1.8293 |         1.7603 | 70.3 |
|   2.8384 |  139.4 |     152 |    163.3 |           1.815 |         1.7601 | 71.8 |
|   3.0316 |  142.3 |   153.9 |    163.3 |          1.7967 |         1.7417 | 73.3 |

#+call: test-dragoid-diagnostic(alpha=0.5)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   0.9999 |      0 |      90 |    168.7 |          1.9188 |         1.8572 |    0 |
|   1.0002 |    5.6 |      90 |    168.7 |           1.919 |         1.8679 |  1.6 |
|   1.0011 |      6 |    90.2 |    168.7 |          1.9191 |         1.8723 |  3.2 |
|   1.0027 |    7.6 |    90.4 |    168.7 |          1.9191 |         1.8795 |  4.8 |
|   1.0051 |   10.5 |    90.7 |    168.7 |           1.919 |         1.8834 |  6.4 |
|   1.0083 |     14 |      91 |    168.7 |          1.9187 |          1.885 |    8 |
|   1.0122 |   17.5 |    91.5 |    168.7 |          1.9184 |         1.8864 |  9.6 |
|   1.0169 |   20.9 |      92 |    168.7 |           1.918 |         1.8848 | 11.2 |
|   1.0223 |   23.8 |    92.6 |    168.7 |          1.9175 |         1.8883 | 12.8 |
|   1.0285 |   26.7 |    93.3 |    168.7 |          1.9168 |         1.8918 | 14.5 |
|   1.0358 |     32 |    94.1 |    168.7 |           1.916 |         1.8855 | 16.1 |
|   1.0437 |   34.1 |    94.9 |    168.7 |          1.9155 |         1.8876 | 17.7 |
|   1.0526 |   36.8 |    95.7 |    168.7 |          1.9143 |         1.8839 | 19.3 |
|   1.0624 |   39.5 |    96.9 |    168.7 |          1.9133 |         1.8814 | 20.9 |
|   1.0731 |   42.8 |    97.7 |    168.7 |          1.9124 |          1.882 | 22.5 |
|   1.0852 |   47.3 |    98.8 |    168.7 |          1.9096 |         1.8667 | 24.1 |
|    1.098 |   49.7 |   100.1 |    168.7 |           1.908 |         1.8674 | 25.7 |
|   1.1115 |   51.7 |   101.3 |    168.7 |          1.9071 |         1.8753 | 27.3 |
|   1.1266 |   55.6 |   102.5 |    168.7 |          1.9048 |         1.8707 | 28.9 |
|   1.1431 |   58.4 |   103.9 |    168.7 |          1.9028 |          1.865 | 30.5 |
|   1.1606 |   60.6 |   105.2 |    168.7 |          1.9004 |         1.8638 | 32.1 |
|   1.1797 |   64.3 |   106.5 |    168.7 |          1.8974 |          1.855 | 33.7 |
|   1.2003 |   67.5 |   108.4 |    168.7 |          1.8955 |         1.8468 | 35.3 |
|   1.2226 |     71 |   109.2 |    168.7 |          1.8915 |         1.8368 | 36.9 |
|   1.2454 |   72.5 |   111.3 |    168.7 |          1.8891 |         1.8543 | 38.5 |
|   1.2717 |   77.3 |   112.8 |    168.7 |           1.884 |         1.8311 | 40.1 |
|   1.2984 |   79.2 |   114.3 |    168.7 |          1.8812 |          1.841 | 41.8 |
|   1.3282 |   82.8 |   116.2 |    168.7 |          1.8765 |         1.8308 | 43.4 |
|   1.3607 |   85.4 |   117.8 |    168.7 |          1.8709 |         1.8161 |   45 |
|   1.3944 |   88.1 |   119.5 |    168.7 |          1.8663 |         1.8175 | 46.6 |
|   1.4313 |   91.8 |   121.3 |    168.7 |          1.8607 |         1.8076 | 48.2 |
|   1.4711 |   95.1 |   123.2 |    168.7 |          1.8549 |         1.8051 | 49.8 |
|   1.5141 |   97.6 |   124.9 |    168.7 |          1.8479 |          1.801 | 51.4 |
|   1.5609 |  101.3 |   126.8 |    168.7 |          1.8403 |         1.7873 |   53 |
|   1.6112 |  103.9 |   128.6 |    168.7 |          1.8325 |         1.7806 | 54.6 |
|   1.6678 |  108.1 |   130.4 |    168.7 |          1.8213 |         1.7511 | 56.2 |
|   1.7245 |    109 |   132.2 |    168.7 |          1.8146 |         1.7747 | 57.8 |
|   1.7896 |  112.8 |   134.2 |    168.7 |          1.8032 |         1.7558 | 59.4 |
|   1.8608 |  116.1 |   136.1 |    168.7 |          1.7908 |         1.7367 |   61 |
|   1.9371 |  118.5 |     138 |    168.7 |          1.7788 |         1.7314 | 62.6 |
|   2.0212 |  121.5 |   139.8 |    168.7 |          1.7644 |         1.7193 | 64.2 |
|   2.1132 |  123.9 |   141.9 |    168.7 |          1.7491 |          1.711 | 65.8 |
|   2.2158 |  127.2 |   143.8 |    168.7 |           1.731 |         1.6889 | 67.4 |
|   2.3289 |  130.4 |   145.8 |    168.7 |          1.7112 |         1.6664 | 69.1 |
|   2.4533 |  133.1 |   147.7 |    168.7 |          1.6899 |         1.6506 | 70.7 |
|   2.5925 |    136 |   149.7 |    168.7 |          1.6658 |         1.6263 | 72.3 |
|   2.7479 |  138.7 |   151.7 |    168.7 |          1.6389 |          1.601 | 73.9 |
|   2.9228 |  141.7 |   153.7 |    168.7 |          1.6086 |         1.5695 | 75.5 |
|   3.1194 |  144.4 |   155.6 |    168.7 |          1.5749 |         1.5372 | 77.1 |
|   3.3429 |  147.3 |   157.6 |    168.7 |           1.537 |         1.5002 | 78.7 |


#+call: test-dragoid-diagnostic(alpha=1.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    174.1 |          1.8309 |         1.7709 |    0 |
|   1.0003 |    3.3 |      90 |    174.1 |          1.8308 |         1.7735 |  1.7 |
|   1.0012 |      7 |    90.2 |    174.1 |          1.8309 |         1.7872 |  3.4 |
|   1.0029 |    8.2 |    90.4 |    174.1 |          1.8308 |         1.7967 |  5.2 |
|   1.0054 |   12.4 |    90.7 |    174.1 |          1.8302 |         1.7976 |  6.9 |
|   1.0088 |   15.9 |    91.1 |    174.1 |          1.8294 |         1.7938 |  8.6 |
|   1.0128 |   18.8 |    91.5 |    174.1 |          1.8284 |         1.7909 | 10.3 |
|   1.0175 |   21.1 |    92.1 |    174.1 |          1.8275 |         1.7965 |   12 |
|    1.023 |   24.6 |    92.7 |    174.1 |          1.8263 |         1.8011 | 13.7 |
|   1.0295 |   27.8 |    93.5 |    174.1 |          1.8248 |          1.801 | 15.5 |
|   1.0369 |   31.1 |    94.3 |    174.1 |          1.8233 |          1.794 | 17.2 |
|   1.0451 |   34.7 |      95 |    174.1 |          1.8211 |         1.7905 | 18.9 |
|   1.0541 |   37.2 |    96.1 |    174.1 |          1.8188 |          1.791 | 20.6 |
|   1.0641 |   41.3 |    97.1 |    174.1 |          1.8169 |         1.7864 | 22.3 |
|    1.075 |     42 |      98 |    174.1 |          1.8142 |         1.7847 |   24 |
|   1.0873 |   46.5 |    99.3 |    174.1 |            1.81 |         1.7742 | 25.8 |
|   1.1003 |     50 |   100.3 |    174.1 |          1.8069 |         1.7704 | 27.5 |
|    1.114 |   54.6 |   101.7 |    174.1 |          1.8038 |         1.7723 | 29.2 |
|   1.1295 |   55.3 |   102.9 |    174.1 |          1.7997 |         1.7664 | 30.9 |
|    1.146 |   57.6 |   104.4 |    174.1 |          1.7954 |         1.7639 | 32.6 |
|   1.1637 |   62.8 |   105.5 |    174.1 |          1.7908 |         1.7602 | 34.3 |
|   1.1839 |   67.2 |   107.3 |    174.1 |          1.7842 |         1.7357 | 36.1 |
|   1.2041 |   67.5 |   108.6 |    174.1 |          1.7791 |         1.7405 | 37.8 |
|   1.2261 |     71 |   110.4 |    174.1 |          1.7751 |         1.7391 | 39.5 |
|   1.2502 |   74.5 |   111.4 |    174.1 |          1.7679 |         1.7273 | 41.2 |
|   1.2757 |   77.9 |   113.5 |    174.1 |          1.7601 |         1.7203 | 42.9 |
|   1.3024 |   80.9 |   115.2 |    174.1 |          1.7536 |         1.7252 | 44.6 |
|   1.3339 |   86.2 |   116.7 |    174.1 |          1.7426 |         1.6916 | 46.4 |
|   1.3651 |   88.2 |   118.4 |    174.1 |          1.7347 |         1.6906 | 48.1 |
|   1.3985 |   89.1 |   120.3 |    174.1 |          1.7259 |         1.6912 | 49.8 |
|    1.435 |   92.7 |   121.8 |    174.1 |          1.7161 |         1.6803 | 51.5 |
|   1.4744 |     95 |   123.9 |    174.1 |          1.7051 |         1.6638 | 53.2 |
|   1.5161 |     98 |   125.6 |    174.1 |          1.6938 |         1.6606 | 54.9 |
|   1.5617 |  102.2 |   127.2 |    174.1 |          1.6813 |         1.6449 | 56.7 |
|   1.6105 |  104.9 |   129.3 |    174.1 |          1.6673 |         1.6309 | 58.4 |
|   1.6654 |  109.7 |   131.3 |    174.1 |          1.6507 |         1.5969 | 60.1 |
|    1.721 |  110.8 |   133.2 |    174.1 |          1.6361 |         1.5907 | 61.8 |
|   1.7817 |  113.7 |   135.2 |    174.1 |          1.6199 |         1.5806 | 63.5 |
|   1.8477 |  116.2 |     137 |    174.1 |          1.6022 |         1.5686 | 65.2 |
|     1.92 |  119.4 |   139.1 |    174.1 |          1.5822 |         1.5488 |   67 |
|   1.9996 |  123.1 |   140.8 |    174.1 |            1.56 |         1.5192 | 68.7 |
|   2.0843 |  125.2 |   143.1 |    174.1 |          1.5377 |         1.5012 | 70.4 |
|   2.1777 |  128.6 |   145.1 |    174.1 |          1.5128 |         1.4767 | 72.1 |
|   2.2803 |  131.4 |   147.1 |    174.1 |          1.4855 |         1.4477 | 73.8 |
|   2.3926 |  134.3 |   149.4 |    174.1 |          1.4558 |         1.4192 | 75.5 |
|   2.5166 |  137.1 |   150.8 |    174.1 |          1.4234 |         1.3875 | 77.3 |
|   2.6544 |  140.2 |   153.3 |    174.1 |          1.3877 |          1.353 |   79 |
|   2.8084 |  143.3 |   155.4 |    174.1 |          1.3489 |         1.3163 | 80.7 |
|   2.9825 |  146.9 |   157.7 |    174.1 |           1.305 |         1.2738 | 82.4 |
|   3.1805 |  149.9 |     160 |    174.1 |          1.2559 |         1.2248 | 84.1 |

#+call: test-dragoid-diagnostic(alpha=2.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0004 |      0 |      90 |    176.8 |          1.7144 |         1.6534 |    0 |
|        1 |    3.9 |      90 |    176.8 |          1.7155 |         1.6887 |  1.8 |
|   1.0005 |    1.5 |    90.2 |    176.8 |          1.7158 |         1.7118 |  3.5 |
|   1.0024 |    9.6 |    90.4 |    176.8 |          1.7147 |         1.6838 |  5.3 |
|   1.0045 |    9.8 |    90.6 |    176.8 |          1.7143 |         1.6931 |  7.1 |
|   1.0075 |   18.2 |      91 |    176.8 |           1.713 |         1.6882 |  8.9 |
|   1.0113 |   20.3 |    91.4 |    176.8 |          1.7115 |         1.6827 | 10.6 |
|   1.0158 |   22.3 |      92 |    176.8 |          1.7096 |         1.6738 | 12.4 |
|   1.0209 |     23 |    92.5 |    176.8 |          1.7077 |         1.6719 | 14.2 |
|   1.0266 |   26.8 |    93.2 |    176.8 |          1.7057 |         1.6741 | 15.9 |
|    1.033 |   28.6 |    93.9 |    176.8 |          1.7033 |         1.6732 | 17.7 |
|   1.0402 |   32.1 |    94.9 |    176.8 |          1.7011 |         1.6751 | 19.5 |
|   1.0486 |   35.7 |    95.5 |    176.8 |          1.6977 |         1.6603 | 21.3 |
|   1.0574 |     36 |    96.8 |    176.8 |          1.6939 |          1.657 |   23 |
|    1.067 |   42.1 |    97.4 |    176.8 |           1.691 |         1.6541 | 24.8 |
|   1.0776 |     44 |    98.9 |    176.8 |          1.6869 |         1.6487 | 26.6 |
|   1.0887 |   46.6 |    99.7 |    176.8 |          1.6834 |          1.651 | 28.4 |
|   1.1014 |   51.6 |   100.7 |    176.8 |          1.6781 |         1.6407 | 30.1 |
|   1.1141 |   58.2 |   102.3 |    176.8 |          1.6731 |         1.6451 | 31.9 |
|   1.1289 |   58.4 |   103.4 |    176.8 |          1.6675 |         1.6334 | 33.7 |
|   1.1441 |   58.5 |   104.8 |    176.8 |          1.6615 |         1.6357 | 35.4 |
|   1.1606 |   63.5 |   106.2 |    176.8 |          1.6558 |         1.6348 | 37.2 |
|   1.1794 |   67.5 |   107.6 |    176.8 |          1.6478 |         1.6137 |   39 |
|    1.199 |   72.6 |   108.6 |    176.8 |          1.6393 |         1.5924 | 40.8 |
|   1.2192 |   72.8 |   111.3 |    176.8 |          1.6317 |         1.5831 | 42.5 |
|   1.2404 |   74.6 |   111.7 |    176.8 |          1.6249 |         1.5781 | 44.3 |
|   1.2626 |   79.6 |   113.5 |    176.8 |          1.6159 |         1.5782 | 46.1 |
|   1.2873 |   80.2 |   115.4 |    176.8 |          1.6084 |         1.5695 | 47.8 |
|   1.3153 |   82.7 |     117 |    176.8 |          1.5963 |         1.5405 | 49.6 |
|   1.3431 |     89 |   118.8 |    176.8 |          1.5837 |         1.5429 | 51.4 |
|   1.3731 |   89.5 |   119.8 |    176.8 |          1.5721 |         1.5302 | 53.2 |
|   1.4045 |   92.1 |     122 |    176.8 |          1.5613 |         1.5221 | 54.9 |
|   1.4384 |   95.3 |   124.2 |    176.8 |          1.5484 |         1.5125 | 56.7 |
|   1.4752 |   99.1 |     125 |    176.8 |          1.5343 |         1.4943 | 58.5 |
|   1.5139 |  100.5 |   127.2 |    176.8 |          1.5197 |         1.4759 | 60.3 |
|   1.5548 |  103.5 |   129.3 |    176.8 |          1.5046 |         1.4664 |   62 |
|   1.5985 |  106.8 |   131.2 |    176.8 |          1.4893 |         1.4531 | 63.8 |
|   1.6453 |  108.5 |     132 |    176.8 |           1.472 |           1.44 | 65.6 |
|   1.6978 |  111.7 |   134.9 |    176.8 |          1.4519 |         1.4072 | 67.3 |
|   1.7537 |  115.4 |   136.4 |    176.8 |          1.4314 |         1.3821 | 69.1 |
|   1.8101 |  117.2 |   138.5 |    176.8 |          1.4126 |         1.3756 | 70.9 |
|   1.8746 |  121.8 |   140.6 |    176.8 |          1.3895 |         1.3515 | 72.7 |
|   1.9434 |  124.5 |   143.2 |    176.8 |          1.3651 |         1.3275 | 74.4 |
|   2.0175 |  127.3 |   144.3 |    176.8 |          1.3394 |          1.303 | 76.2 |
|   2.0992 |  131.2 |   146.6 |    176.8 |          1.3113 |         1.2731 |   78 |
|   2.1869 |  133.6 |   149.4 |    176.8 |          1.2816 |         1.2516 | 79.7 |
|   2.2864 |  137.8 |     152 |    176.8 |          1.2478 |         1.2161 | 81.5 |
|   2.3954 |  140.6 |   154.2 |    176.8 |          1.2115 |         1.1847 | 83.3 |
|   2.5197 |  144.1 |   157.2 |    176.8 |            1.17 |         1.1474 | 85.1 |
|   2.6646 |  149.4 |   159.8 |    176.8 |          1.1222 |          1.105 | 86.8 |

#+call: test-dragoid-diagnostic(alpha=1.0, mu=0.2)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0001 |      0 |      90 |    152.4 |          2.0699 |         1.9984 |    0 |
|   1.0002 |    2.2 |      90 |    152.4 |          2.0703 |         2.0111 |  1.3 |
|   1.0008 |    4.9 |    90.1 |    152.4 |           2.071 |         2.0239 |  2.5 |
|    1.002 |    5.1 |    90.3 |    152.4 |          2.0715 |         2.0278 |  3.8 |
|   1.0033 |   13.6 |    90.5 |    152.4 |          2.0729 |         2.0542 |  5.1 |
|    1.006 |   13.8 |    90.7 |    152.4 |          2.0725 |         2.0349 |  6.4 |
|   1.0088 |   16.7 |    91.1 |    152.4 |           2.073 |         2.0388 |  7.6 |
|   1.0121 |   19.9 |    91.4 |    152.4 |          2.0736 |         2.0531 |  8.9 |
|   1.0162 |   22.8 |    91.9 |    152.4 |          2.0737 |         2.0511 | 10.2 |
|   1.0207 |   23.2 |    92.4 |    152.4 |          2.0745 |         2.0605 | 11.5 |
|   1.0259 |     26 |      93 |    152.4 |          2.0755 |         2.0634 | 12.7 |
|   1.0319 |   29.4 |    93.6 |    152.4 |          2.0765 |         2.0528 |   14 |
|   1.0382 |   31.2 |    94.2 |    152.4 |          2.0774 |         2.0586 | 15.3 |
|   1.0454 |   31.5 |      95 |    152.4 |          2.0779 |          2.056 | 16.6 |
|   1.0536 |     38 |    95.8 |    152.4 |          2.0784 |         2.0334 | 17.8 |
|   1.0622 |     41 |    96.6 |    152.4 |          2.0799 |         2.0308 | 19.1 |
|   1.0717 |   43.8 |    97.3 |    152.4 |          2.0805 |         2.0126 | 20.4 |
|   1.0817 |     46 |    98.5 |    152.4 |          2.0814 |         2.0126 | 21.7 |
|   1.0918 |   47.6 |    99.4 |    152.4 |          2.0852 |         2.0339 | 22.9 |
|   1.1032 |   48.7 |   100.1 |    152.4 |          2.0867 |         2.0391 | 24.2 |
|   1.1156 |   54.7 |   101.5 |    152.4 |          2.0884 |         2.0397 | 25.5 |
|   1.1289 |     53 |   102.2 |    152.4 |          2.0898 |         2.0497 | 26.7 |
|   1.1435 |   57.5 |   103.6 |    152.4 |          2.0915 |         2.0464 |   28 |
|   1.1593 |   61.6 |   104.5 |    152.4 |          2.0919 |         2.0277 | 29.3 |
|   1.1759 |   63.7 |   105.9 |    152.4 |          2.0926 |         2.0282 | 30.6 |
|    1.194 |   65.6 |   107.3 |    152.4 |          2.0944 |         2.0222 | 31.8 |
|   1.2132 |   69.8 |   108.3 |    152.4 |          2.0962 |          2.013 | 33.1 |
|   1.2328 |   70.9 |   109.7 |    152.4 |          2.0993 |         2.0314 | 34.4 |
|   1.2539 |   74.3 |     111 |    152.4 |          2.1018 |         2.0411 | 35.7 |
|   1.2776 |   76.6 |   112.5 |    152.4 |          2.1037 |         2.0326 | 36.9 |
|   1.3032 |     80 |   113.8 |    152.4 |          2.1049 |         2.0139 | 38.2 |
|     1.33 |   82.9 |   115.3 |    152.4 |          2.1079 |         2.0095 | 39.5 |
|   1.3589 |   85.9 |   116.6 |    152.4 |          2.1099 |         2.0071 | 40.8 |
|   1.3878 |   86.3 |   118.1 |    152.4 |          2.1156 |         2.0527 |   42 |
|   1.4219 |   90.3 |   119.7 |    152.4 |          2.1167 |         2.0308 | 43.3 |
|   1.4577 |   93.5 |   121.1 |    152.4 |          2.1196 |         2.0174 | 44.6 |
|   1.4963 |   96.7 |   122.8 |    152.4 |          2.1232 |         2.0098 | 45.9 |
|   1.5384 |   99.3 |   124.3 |    152.4 |           2.126 |         1.9958 | 47.1 |
|   1.5821 |  101.6 |   126.1 |    152.4 |          2.1325 |         2.0069 | 48.4 |
|   1.6302 |  103.7 |   127.4 |    152.4 |          2.1376 |         2.0096 | 49.7 |
|   1.6832 |    107 |   129.3 |    152.4 |          2.1426 |          1.998 | 50.9 |
|   1.7394 |  109.2 |   130.9 |    152.4 |          2.1511 |         2.0081 | 52.2 |
|   1.8002 |    112 |   132.7 |    152.4 |          2.1613 |         2.0199 | 53.5 |
|   1.8715 |  114.8 |   134.4 |    152.4 |          2.1688 |         1.9724 | 54.8 |
|    1.942 |    117 |   136.3 |    152.4 |          2.1863 |         2.0263 |   56 |
|   2.0246 |  119.7 |   138.2 |    152.4 |          2.2039 |         2.0167 | 57.3 |
|   2.1165 |  122.5 |   140.1 |    152.4 |          2.2267 |          2.006 | 58.6 |
|   2.2172 |  125.6 |   142.3 |    152.4 |          2.2612 |         2.0094 | 59.9 |
|   2.3261 |  127.5 |   144.6 |    152.4 |          2.3171 |           2.08 | 61.1 |
|   2.4591 |  130.7 |     147 |    152.4 |          2.3945 |         2.0424 | 62.4 |

#+call: test-dragoid-diagnostic(alpha=4.0, mu=0.2)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   0.9999 |      0 |      90 |    172.3 |          1.6506 |            1.6 |    0 |
|   1.0001 |      3 |      90 |    172.3 |          1.6507 |         1.6038 |  1.7 |
|   1.0008 |    4.9 |    90.2 |    172.3 |          1.6508 |         1.6097 |  3.4 |
|    1.002 |    7.7 |    90.4 |    172.3 |          1.6509 |         1.6119 |    5 |
|    1.004 |   10.9 |    90.6 |    172.3 |          1.6509 |         1.6047 |  6.7 |
|   1.0064 |   13.6 |    90.9 |    172.3 |          1.6504 |         1.6003 |  8.4 |
|   1.0093 |   16.3 |    91.1 |    172.3 |           1.649 |         1.5986 | 10.1 |
|   1.0126 |   18.9 |    91.4 |    172.3 |          1.6469 |         1.6058 | 11.8 |
|   1.0166 |   23.9 |    92.4 |    172.3 |          1.6452 |         1.6003 | 13.4 |
|   1.0211 |   24.2 |    92.7 |    172.3 |          1.6443 |         1.6047 | 15.1 |
|   1.0266 |   27.6 |      93 |    172.3 |          1.6412 |         1.5901 | 16.8 |
|   1.0323 |   29.1 |    94.3 |    172.3 |          1.6389 |         1.5855 | 18.5 |
|   1.0382 |   31.5 |    94.6 |    172.3 |          1.6375 |         1.5932 | 20.2 |
|   1.0439 |   37.2 |    94.9 |    172.3 |          1.6357 |         1.6245 | 21.8 |
|   1.0519 |   37.6 |    96.6 |    172.3 |          1.6327 |         1.6118 | 23.5 |
|   1.0613 |   40.8 |    97.1 |    172.3 |          1.6279 |          1.585 | 25.2 |
|   1.0697 |   42.9 |    97.6 |    172.3 |          1.6239 |         1.5912 | 26.9 |
|   1.0796 |   43.1 |    99.4 |    172.3 |          1.6197 |         1.5821 | 28.6 |
|   1.0898 |   44.9 |   100.2 |    172.3 |          1.6159 |         1.5839 | 30.2 |
|   1.1009 |   46.8 |   101.3 |    172.3 |          1.6114 |         1.5824 | 31.9 |
|   1.1133 |   53.7 |   103.1 |    172.3 |          1.6056 |         1.5682 | 33.6 |
|   1.1266 |   56.5 |   103.7 |    172.3 |          1.6005 |         1.5576 | 35.3 |
|   1.1397 |     61 |   105.1 |    172.3 |          1.5955 |         1.5608 |   37 |
|   1.1546 |   63.6 |   106.1 |    172.3 |           1.589 |          1.548 | 38.6 |
|   1.1697 |   61.4 |   107.6 |    172.3 |          1.5836 |         1.5503 | 40.3 |
|   1.1871 |   69.1 |   109.1 |    172.3 |          1.5757 |         1.5249 |   42 |
|   1.2042 |   67.8 |   110.3 |    172.3 |          1.5697 |         1.5208 | 43.7 |
|   1.2227 |   72.7 |     112 |    172.3 |          1.5627 |         1.5071 | 45.4 |
|   1.2416 |   75.3 |   113.6 |    172.3 |          1.5564 |         1.5047 |   47 |
|   1.2621 |   78.3 |   114.4 |    172.3 |          1.5488 |         1.4944 | 48.7 |
|   1.2833 |   82.8 |   116.6 |    172.3 |          1.5418 |         1.4907 | 50.4 |
|   1.3074 |   85.6 |   118.8 |    172.3 |          1.5321 |         1.4725 | 52.1 |
|   1.3327 |   85.8 |   120.6 |    172.3 |          1.5226 |         1.4539 | 53.8 |
|   1.3584 |   90.9 |   121.1 |    172.3 |          1.5143 |         1.4549 | 55.4 |
|   1.3862 |     91 |   123.6 |    172.3 |          1.5043 |         1.4461 | 57.1 |
|   1.4172 |   96.7 |   125.1 |    172.3 |          1.4931 |         1.4292 | 58.8 |
|   1.4478 |   97.1 |     127 |    172.3 |          1.4839 |         1.4246 | 60.5 |
|   1.4811 |  100.3 |   128.9 |    172.3 |          1.4738 |         1.4182 | 62.2 |
|   1.5171 |  103.6 |   130.9 |    172.3 |          1.4621 |         1.4041 | 63.8 |
|   1.5553 |  105.7 |     134 |    172.3 |          1.4512 |         1.3911 | 65.5 |
|   1.5971 |  109.7 |   135.1 |    172.3 |          1.4392 |         1.3679 | 67.2 |
|   1.6407 |  112.4 |   137.9 |    172.3 |          1.4285 |         1.3535 | 68.9 |
|   1.6869 |  116.3 |   140.7 |    172.3 |          1.4186 |         1.3458 | 70.6 |
|   1.7394 |  120.5 |   144.2 |    172.3 |          1.4076 |         1.3265 | 72.2 |
|   1.7943 |  121.1 |   147.1 |    172.3 |          1.4001 |         1.3187 | 73.9 |
|   1.8563 |  125.4 |     151 |    172.3 |          1.3946 |         1.2966 | 75.6 |
|   1.9239 |  128.9 |   155.4 |    172.3 |          1.3981 |         1.2851 | 77.3 |
|   2.0022 |  134.3 |   160.4 |    172.3 |          1.4178 |         1.2637 | 78.9 |
|   2.0908 |  137.9 |   165.4 |    172.3 |          1.4858 |           1.26 | 80.6 |
|   2.2011 |  144.6 |   170.1 |    172.3 |          1.7237 |         1.2706 | 82.3 |

#+call: test-dragoid-diagnostic(alpha=4.0, mu=0.8)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    155.1 |          1.8645 |         1.8116 |    0 |
|   1.0001 |    2.2 |      90 |    155.1 |          1.8646 |         1.8273 |  1.3 |
|   1.0006 |    2.4 |    90.1 |    155.1 |          1.8648 |         1.8389 |  2.7 |
|   1.0017 |    6.3 |    90.2 |    155.1 |          1.8647 |         1.8411 |    4 |
|   1.0033 |   10.9 |    90.4 |    155.1 |          1.8643 |         1.8393 |  5.3 |
|   1.0053 |   11.3 |    90.7 |    155.1 |          1.8638 |         1.8392 |  6.6 |
|   1.0077 |   15.2 |      91 |    155.1 |          1.8636 |         1.8507 |    8 |
|   1.0109 |   18.5 |    91.3 |    155.1 |          1.8627 |         1.8317 |  9.3 |
|   1.0143 |   18.8 |    91.7 |    155.1 |          1.8622 |         1.8297 | 10.6 |
|   1.0186 |   23.8 |    92.1 |    155.1 |          1.8608 |         1.8144 |   12 |
|   1.0231 |     24 |    92.6 |    155.1 |          1.8596 |         1.8079 | 13.3 |
|   1.0278 |   26.7 |    93.3 |    155.1 |          1.8595 |         1.8096 | 14.6 |
|   1.0328 |   29.2 |    93.8 |    155.1 |          1.8593 |         1.8231 | 15.9 |
|   1.0377 |   33.1 |    94.5 |    155.1 |          1.8601 |         1.8658 | 17.3 |
|   1.0438 |   34.6 |    95.2 |    155.1 |          1.8602 |          1.881 | 18.6 |
|   1.0526 |   35.2 |    95.7 |    155.1 |          1.8557 |         1.8343 | 19.9 |
|   1.0605 |   39.4 |    97.1 |    155.1 |          1.8556 |         1.8324 | 21.3 |
|   1.0693 |   42.9 |    97.4 |    155.1 |          1.8542 |         1.8205 | 22.6 |
|   1.0777 |   44.9 |    97.9 |    155.1 |          1.8525 |         1.8288 | 23.9 |
|   1.0876 |   45.1 |    99.7 |    155.1 |          1.8504 |         1.8156 | 25.3 |
|   1.0981 |   46.4 |   100.1 |    155.1 |          1.8488 |         1.8037 | 26.6 |
|   1.1089 |   52.2 |   101.3 |    155.1 |          1.8464 |         1.8081 | 27.9 |
|   1.1196 |   48.7 |     102 |    155.1 |           1.846 |         1.8298 | 29.2 |
|   1.1332 |   56.4 |   103.5 |    155.1 |          1.8422 |         1.7977 | 30.6 |
|   1.1458 |   60.7 |   104.7 |    155.1 |          1.8414 |         1.8032 | 31.9 |
|   1.1602 |   58.6 |   105.5 |    155.1 |           1.839 |         1.7964 | 33.2 |
|   1.1755 |   68.1 |     107 |    155.1 |          1.8361 |         1.7822 | 34.6 |
|   1.1913 |   63.2 |   107.9 |    155.1 |          1.8335 |         1.7792 | 35.9 |
|    1.208 |   66.6 |   109.7 |    155.1 |          1.8334 |         1.7775 | 37.2 |
|   1.2254 |   68.5 |   110.2 |    155.1 |          1.8315 |         1.7814 | 38.5 |
|   1.2436 |   71.3 |   112.1 |    155.1 |          1.8306 |         1.7943 | 39.9 |
|    1.264 |   74.6 |   114.2 |    155.1 |          1.8287 |         1.7806 | 41.2 |
|   1.2865 |   79.1 |   114.6 |    155.1 |          1.8258 |         1.7467 | 42.5 |
|    1.309 |     81 |   116.4 |    155.1 |          1.8244 |         1.7351 | 43.9 |
|   1.3335 |   84.5 |   118.1 |    155.1 |          1.8246 |         1.7142 | 45.2 |
|   1.3574 |   86.2 |   119.9 |    155.1 |          1.8261 |         1.7231 | 46.5 |
|   1.3832 |   88.1 |   121.9 |    155.1 |          1.8306 |          1.727 | 47.8 |
|   1.4104 |   90.1 |   123.2 |    155.1 |          1.8346 |          1.737 | 49.2 |
|   1.4402 |     92 |   125.4 |    155.1 |          1.8402 |         1.7416 | 50.5 |
|   1.4733 |   97.3 |   127.6 |    155.1 |          1.8446 |         1.7153 | 51.8 |
|   1.5093 |   99.9 |   129.7 |    155.1 |          1.8535 |         1.6872 | 53.2 |
|   1.5427 |   97.8 |     132 |    155.1 |          1.8709 |         1.7357 | 54.5 |
|   1.5825 |  102.1 |   134.4 |    155.1 |          1.8908 |         1.7163 | 55.8 |
|   1.6246 |  106.9 |   136.2 |    155.1 |          1.9198 |          1.704 | 57.1 |
|   1.6718 |  109.8 |   139.3 |    155.1 |          1.9603 |         1.6767 | 58.5 |
|   1.7198 |    112 |   142.2 |    155.1 |          2.0235 |         1.7101 | 59.8 |
|   1.7741 |  114.5 |   144.9 |    155.1 |          2.1169 |         1.7455 | 61.1 |
|   1.8383 |  119.8 |   147.7 |    155.1 |          2.2647 |         1.7245 | 62.5 |
|   1.9079 |    123 |   150.6 |    155.1 |          2.5366 |         1.7744 | 63.8 |
|    1.993 |  129.8 |   153.3 |    155.1 |          3.1556 |         1.8812 | 65.1 |


*** Reproduce paper fig of R_c-R_90 for cantoid and ancantoid 

#+BEGIN_SRC python :eval no :tangle ancantoid-R90-vs-Rc.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import bow_projection as bp
  import ancantoid_shape
  import bow_diagnostic

  try: 
      xiset = sys.argv[1]
      plotfile = sys.argv[0].replace('.py', f'-{xiset}.pdf')
      assert xiset in 'ab'
      istart = -2 if xiset == 'a' else -1
  except:
      sys.exit(f"Usage: {sys.argv[0]} a|b")

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.3, 0.1, 0.03, 0.01, 1e-3]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = np.linspace(0.0, 1.0, 20)
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")


  cols = sns.color_palette('magma', n_colors=nxi)
  annot_pars_list = [right_annotate_pars]*2 + [left_annotate_pars]*2 
  for beta in BETA_LIST[::-1]:
      for xi, col, annot_pars in list(zip(XI_LIST, cols, annot_pars_list))[istart::-2]:
          k = None if xi is None else 2/xi - 2
          if beta == BETA_LIST[0]:
              label = "Cantoid" if k is None else fr"Ancantoid $k = {k:.1f}$"
          else:
              label = "_nolabel_"

          if xi is None:
              shape = bp.Spline_R_theta_from_function(
                  ngrid=1000,
                  shape_func=bp.cantoid_R_theta,
                  shape_func_pars=(beta,))
          else:
              shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)

          th_inf = bp.theta_infinity(shape)
          inc = np.linspace(0.0, th_inf - np.pi/2, 200)
          tab = bow_diagnostic.parameter_table(inc, shape)
          Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
          ax.plot(Rc, R90, '-', c=col, label=label, lw=0.7, alpha=0.9)

          # Get points evenly spaced in sin i
          sini = np.linspace(0.0, 1.0, 20)
          inc_e = np.arcsin(sini)
          inc_e = inc_e[inc_e < th_inf - np.pi/2]
          tab_e = bow_diagnostic.parameter_table(inc_e, shape)
          Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
          ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
                     linewidths=0.1, edgecolors='none',
                     c=col, alpha=0.5, label="_nolabel_")

          # Put a dot at the i=0 case
          ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)
          # Label the dot with the cross-over inclination
          beta_label = rf'$\beta = \mathrm{{{beta:g}}}$'
          if beta_label.endswith('1}$'):
              # But only for some of them
              ax.annotate(beta_label, xy=(Rc[0], R90[0]),
                          textcoords='offset points',
                          fontsize='x-small', color=col, **annot_pars)


  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

**** Make ancantoid graphs for two parameter sets 

#+BEGIN_SRC sh :results file
python ancantoid-R90-vs-Rc.py a
#+END_SRC

#+RESULTS:
[[file:ancantoid-R90-vs-Rc-a.pdf]]

#+BEGIN_SRC sh :results file
python ancantoid-R90-vs-Rc.py b
#+END_SRC

#+RESULTS:
[[file:ancantoid-R90-vs-Rc-b.pdf]]



**** Same but for very small beta

#+BEGIN_SRC python :eval no :tangle ancantoid-R90-vs-Rc-lobeta.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import bow_projection as bp
  import ancantoid_shape
  import bow_diagnostic

  try: 
      xiset = sys.argv[1]
      plotfile = sys.argv[0].replace('.py', f'-{xiset}.pdf')
      assert xiset in 'ab'
      istart = -2 if xiset == 'a' else -1
  except:
      sys.exit(f"Usage: {sys.argv[0]} a|b")

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [1e-3, 1e-4, 1e-5]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = np.linspace(0.0, 1.0, 20)
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")


  cols = sns.color_palette('magma', n_colors=nxi)
  annot_pars_list = [right_annotate_pars]*4 
  for beta in BETA_LIST[::-1]:
      for xi, col, annot_pars in list(zip(XI_LIST, cols, annot_pars_list))[istart::-2]:
          k = None if xi is None else 2/xi - 2
          if beta == BETA_LIST[0]:
              label = "Cantoid" if k is None else fr"Ancantoid $k = {k:.1f}$"
          else:
              label = "_nolabel_"

          if xi is None:
              shape = bp.Spline_R_theta_from_function(
                  ngrid=1000,
                  shape_func=bp.cantoid_R_theta,
                  shape_func_pars=(beta,))
          else:
              shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)

          th_inf = bp.theta_infinity(shape)
          inc = np.linspace(0.0, th_inf - np.pi/2, 200)
          tab = bow_diagnostic.parameter_table(inc, shape)
          Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
          ax.plot(Rc, R90, '-', c=col, label=label, lw=0.7, alpha=0.9)

          # Get points evenly spaced in sin i
          sini = np.linspace(0.0, 1.0, 20)
          inc_e = np.arcsin(sini)
          inc_e = inc_e[inc_e < th_inf - np.pi/2]
          tab_e = bow_diagnostic.parameter_table(inc_e, shape)
          Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
          ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
                     linewidths=0.1, edgecolors='none',
                     c=col, alpha=0.5, label="_nolabel_")

          # Put a dot at the i=0 case
          ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)
          # Label the dot with the cross-over inclination
          beta_label = rf'$\beta = 10^{{{int(np.log10(beta)):d}}}$'
          # But only for some of them
          ax.annotate(beta_label, xy=(Rc[0], R90[0]),
                      textcoords='offset points',
                      fontsize='x-small', color=col, **annot_pars)


  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[1.3, 2.0],
      ylim=[1.3, 2.0],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python ancantoid-R90-vs-Rc-lobeta.py a
#+END_SRC

#+RESULTS:
[[file:ancantoid-R90-vs-Rc-lobeta-a.pdf]]

*** Figure of R_c-R_90 for the dragoids
This is something I never got finished for the multi-quadric fits

#+BEGIN_SRC python :eval no :tangle dragoid-R90-vs-Rc.py
  import sys
  import numpy as np
  from scipy.interpolate import interp1d
  import statsmodels.api as sm
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import bow_projection as bp
  import dragoid_shape
  import bow_diagnostic


  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = np.linspace(0.0, 1.0, 20)
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")

  # For dragoids, widen the region for fitting R_c
  bp.SCALE_NEIGHBORHOOD = 0.08

  ALPHA_LIST = [0.25, 1.0, 1.0, 1.0, 4.0, 4.0]
  MU_LIST = [None, None, 0.05, 0.2, 0.2, 0.8]
  nalpha = len(ALPHA_LIST)
  cols = sns.color_palette(n_colors=nalpha)
  for alpha, mu, col in list(zip(ALPHA_LIST, MU_LIST, cols))[::-1]:
      shape = dragoid_shape.Dragoid(alpha=alpha, mu=mu)
      th_inf = bp.theta_infinity(shape)
      inc = np.linspace(0.0, th_inf - np.pi/2, 50)
      tab = bow_diagnostic.parameter_table(inc, shape)
      Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']

      Rcs = sm.nonparametric.lowess(Rc, inc, frac=0.3,
                                    is_sorted=True, return_sorted=False)
      # Rcs = Rc
      Rcs[0] = Rc[0]
      ax.plot(Rcs, R90, '-', c=col, label=shape.label, lw=0.7, alpha=0.9)

      # Get points evenly spaced in sin i
      sini = np.linspace(0.0, 1.0, 20)
      inc_e = np.arcsin(sini)
      inc_e = inc_e[inc_e < th_inf - np.pi/2]
      # Interpolate to get the even probability points
      Rc_e = interp1d(inc, Rcs)(inc_e)
      R90_e = interp1d(inc, R90)(inc_e)

      ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
                 linewidths=0.1, edgecolors='none',
                 c=col, alpha=0.5, label="_nolabel_")

      # Put a dot at the i=0 case
      ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)


  ax.legend(ncol=1, fontsize='small', title='Dragoids',
            frameon=True, loc="lower right")
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.9, 2.7],
      ylim=[0.9, 2.7],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python dragoid-R90-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:dragoid-R90-vs-Rc.pdf]]




** Standing wave perturbations


*** ~standing_wave.py~: class for perturbed shell 
#+BEGIN_SRC python :eval no :tangle standing_wave.py
  import numpy as np

  class StandingWave(object):

      def __init__(self, base_shape, amplitude, wavenumber, phase=0.0, **base_shape_kwds):
          """
          Constant amplitude standing wave with antinode on x-axis (theta = 0)

          Parameters
          ----------
          base_shape : callable
              Underlying R(theta) shape to be perturbed
          amplitude
              Relative amplitude of radial oscillation
          wavenumber
              Angular wavenumber of oscillation. With `wavenumber = 1.0` there will
              be a node on the y-axis (theta = pi/2). With `wavenumber = 2.0` there
              will be an anti-node on the y-axis that is out of phase with the
              node on the x-axis.
          phase : optional
              Temporal phase of the oscillation. The amplitude is multiplied
              by `cos(2 pi phase)`, so that When `phase = 0` the radial perturbation
              is positive at `theta = 0`, whereas when `phase = 0.5` the radial
              perturbation is negative at `theta = 0`.  For `phase = 0.25, 0.75`
              the perturbation is zero for all `theta`.
          ,**base_shape_kwds : optional
              Any unrecognised args are passed on to the unperturbed radius
              function: `base_shape(theta, **base_shape_kwds)` 


          """
          self.base_shape = base_shape
          self.amplitude = amplitude
          self.wavenumber = wavenumber
          self.phase = phase
          self.base_shape_kwds = base_shape_kwds

      def __call__(self, theta):
          """
          Radius as function of `theta` for standing wave
          """
          return ((1.0 + self.perturbation(theta)) *
                  self.base_shape(theta, **self.base_shape_kwds))

      def perturbation(self, theta):
          """
          Fractional perturbation of `base_shape` radius at each angle `theta`
          """
          return (self.amplitude *
                  np.cos(2*np.pi*self.phase) *
                  np.cos(self.wavenumber*theta))

#+END_SRC

*** Test the xy shapes for standing waves
#+BEGIN_SRC python :eval no :tangle test_xyprime_wave.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  import standing_wave

  try:
      amplitude = float(sys.argv[1])
      wavenumber = float(sys.argv[2])
  except:
      sys.exit(f"Usage: {sys.argv[0]} AMPLITUDE WAVENUMBER")


  figfile = sys.argv[0].replace(
      '.py', f'-A{int(100*amplitude):03d}-N{int(10*wavenumber):02d}.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette(palette="magma_r", n_colors=len(inclinations))


  shape = standing_wave.StandingWave(
      bp.wilkinoid_R_theta, amplitude=amplitude, wavenumber=wavenumber)

  phases = np.linspace(0.0, 0.5, len(axes.flat))
  for phase, ax in zip(phases, axes.flat):
      shape.phase = phase
      label = f"Phase = ${phase:.2f}$"
      th_inf = bp.theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = bp.theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=1, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

**** Wilkinoid, Wavenumber 1.0, Amplitude 0.1
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.1 1.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A010-N10.pdf]]

Note that for phase = 0.12, the effect of the perturbation is to push the shape closer to the paraboloid, with the result that varying the inclination makes no difference

#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.3 1.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A030-N10.pdf]]


**** Wilkinoid, Wavenumber 2.0, Amplitude 0.05
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.05 2.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A005-N20.pdf]]

#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.15 2.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A015-N20.pdf]]

**** Wilkinoid, Wavenumber 1.5, Amplitude 0.1
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.1 1.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A010-N15.pdf]]

This one more clearly shows the difference between 
1. phase = 0, where the i = 0 shape is pointy, becoming flatter as inc increases
2. phase = 0.5, where the i = 0 shapes is flat, and it becomes pointier as inc increases

**** Wilkinoid, Wavenumber 2.5, Amplitude 0.07
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.07 2.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A007-N25.pdf]]



**** Wilkinoid, Wavenumber 4.5, Amplitude 0.05
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.05 4.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A005-N45.pdf]]

Having such a high wave number is a bit silly, but it does show new behaviour: we can get the perturbations in R_c and R_90 having opposite signs

**** Wilkinoid, Wavenumber 5, Amplitude 0.01
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.01 5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A001-N50.pdf]]

**** Wilkinoid, Wavenumber 5.5, Amplitude 0.3
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.3 5.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A030-N55.pdf]]

This one is very silly. For phase = 0.5 it looks like a duck





*** Same again, but zooming in and allowing different shapes

#+BEGIN_SRC python :eval no :tangle wave_xyprime.py
  import sys
  import scanf
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  import ancantoid_shape
  import dragoid_shape
  import standing_wave

  try:
      AMPLITUDE = float(sys.argv[1])
      WAVENUMBER = float(sys.argv[2])
      BASE_SHAPE_ID = sys.argv[3]
  except:
      sys.exit(f"Usage: {sys.argv[0]} AMPLITUDE WAVENUMBER BASE_SHAPE_ID")


  figfile = sys.argv[0].replace(
      '.py', f'-A{int(100*AMPLITUDE):03d}-N{int(10*WAVENUMBER):02d}'
      f'-{BASE_SHAPE_ID}.pdf')

  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"


  sns.set_style('ticks')
  fig, axes = plt.subplots(1, 3, figsize=(9, 4))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette(palette="magma_r", n_colors=len(inclinations))


  shape = standing_wave.StandingWave(
      base_shape, amplitude=AMPLITUDE, wavenumber=WAVENUMBER)

  phases = np.linspace(0.0, 0.5, len(axes.flat))
  for phase, ax in zip(phases, axes.flat):
      shape.phase = phase
      label = f"Phase = ${phase:.2f}$"
      th_inf = bp.theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = bp.theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=1, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-2.5, 1.2],
          ylim=[-3, 3],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.05 2.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.1 1.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A010-N10-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.05 2.0 dragoid-alpha100
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A005-N20-dragoid-alpha100.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.4 2.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A040-N20-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.1 6.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A010-N60-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.04 10.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A004-N100-ancantoid-xi080-beta000500.pdf]]


*** Zoom and compare different waves in (x, y) shape @ inc=0 

#+BEGIN_SRC python :eval no :tangle compare_xyprime_wave.py
  import sys
  import scanf
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  import standing_wave

  try:
      BASE_SHAPE_ID = sys.argv[1]
  except:
      sys.exit(f"Usage: {sys.argv[0]} BASE_SHAPE_ID")


  figfile = sys.argv[0].replace(
      '.py', f'-{BASE_SHAPE_ID}.pdf')

  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"

  sns.set_style('ticks')
  fig, axes = plt.subplots(1, 3, figsize=(8, 4))

  # Different phases are different lines on same graph
  phases = [0.0, 0.25, 0.5]
  phase_labels = ["phase = 0.0, 1.0", "phase = 0.25, 0.75", "phase = 0.5"]
  colors = 'b', 'k', 'r'
  linewidths = [2, 1, 2]
  # Different (amplitude, wavenumber) are different panels
  amplitudes = [0.1, 0.05, 0.02]
  wavenumbers = [1.0, 2.0, 5.0]

  # All are for zero inclination
  inclination = 0.0

  for amplitude, wavenumber, ax in zip(amplitudes, wavenumbers, axes.flat):
      shape = standing_wave.StandingWave(
          base_shape, amplitude=amplitude, wavenumber=wavenumber)
      wave_label = fr"$A = {amplitude}$, $N = {wavenumber}$"
      th_inf = bp.theta_infinity(shape)
      for phase, phase_label, color, lw in zip(phases, phase_labels, colors, linewidths):
          shape.phase = phase
          th0, th90 = bp.theta_0_90(inclination, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inclination, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inclination, shape)
          R0p = radii['R_0 prime']
          R0p = 1.0
          ax.plot(xxp/R0p, yyp/R0p, label=phase_label, color=color, lw=lw)

      ax.plot([0], [0], 'o', color='k')
      ax.axhline(0, color='k', lw=0.8)
      ax.legend(title=wave_label, ncol=1, loc="upper right")
      ax.set(
          xlabel=r"$x / R_0$",
          ylabel=r"$y / R_0$",
          xlim=[-2.5, 1.5],
          ylim=[-0.5, 4.8],
          xticks=[-2, -1, 0, 1],
          yticks=[0, 1, 2, 3],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine(bottom=True)
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python compare_xyprime_wave.py wilkinoid
#+END_SRC

#+RESULTS:
[[file:compare_xyprime_wave-wilkinoid.pdf]]

#+BEGIN_SRC sh :results file
python compare_xyprime_wave.py cantoid-beta010000
#+END_SRC

#+RESULTS:
[[file:compare_xyprime_wave-cantoid-beta010000.pdf]]


*** Animate the waves @ inc = 0
#+BEGIN_SRC python :eval no :tangle animate_xyprime_wave.py
  import sys
  import scanf
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib import animation
  import seaborn as sns
  import bow_projection as bp
  import standing_wave

  try:
      BASE_SHAPE_ID = sys.argv[1]
  except:
      sys.exit(f"Usage: {sys.argv[0]} BASE_SHAPE_ID")


  fileroot = sys.argv[0].replace('.py', f'-{BASE_SHAPE_ID}')

  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"

  sns.set_style('ticks')
  fig, axes = plt.subplots(1, 3, figsize=(8, 4))

  # Different (amplitude, wavenumber) are different panels
  amplitudes = [0.1, 0.05, 0.02]
  wavenumbers = [1.0, 2.0, 5.0]

  # All are for zero inclination
  inclination = 0.0

  th_inf = bp.theta_infinity(base_shape)

  line_artists = {}
  for amplitude, wavenumber, ax in zip(amplitudes, wavenumbers, axes.flat):
      wave_label = fr"$A = {amplitude}$, $N = {wavenumber}$"
      # artist that will get animated for the different phases
      line_artists[(amplitude, wavenumber)], = ax.plot([], [],
                                                       lw=2, alpha=0.7,
                                                       color='r', label='perturbed')
      # plot the bsse shape
      th = np.linspace(0.0, th_inf, 301)
      xp, yp = bp.xyprime_t(th, inclination, base_shape)
      m = np.isfinite(xp) & np.isfinite(yp)
      xxp = np.concatenate((xp[m][::-1], xp[m]))
      yyp = np.concatenate((-yp[m][::-1], yp[m]))
      ax.plot(xxp, yyp, 'k', lw=1, label='base')
      # 
      ax.plot([0], [0], 'o', color='k')
      ax.axhline(0, color='k', lw=0.8)
      ax.legend(title=wave_label, ncol=1, loc="upper right")
      ax.set(
          xlabel=r"$x / R_0$",
          ylabel=r"$y / R_0$",
          xlim=[-2.5, 1.5],
          ylim=[-0.5, 4.8],
          xticks=[-2, -1, 0, 1],
          yticks=[0, 1, 2, 3],
      )
      ax.set_aspect('equal', adjustable='box')


  def animate_bows(phase):
      for amplitude, wavenumber, ax in zip(amplitudes, wavenumbers, axes.flat):
          shape = standing_wave.StandingWave(base_shape,
                                             amplitude=amplitude,
                                             wavenumber=wavenumber)
          th_inf = bp.theta_infinity(shape)
          shape.phase = phase
          th0, th90 = bp.theta_0_90(inclination, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inclination, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inclination, shape)
          R0p = radii['R_0 prime']
          R0p = 1.0
          x = xxp/R0p
          y = yyp/R0p
          line_artists[(amplitude, wavenumber)].set_data(x, y)
      return line_artists.values()

  sns.despine(bottom=True)
  fig.tight_layout()

  anim = animation.FuncAnimation(fig, animate_bows,
                                 frames=np.linspace(0, 1.0, 50),
                                 blit=True)
  moviefile = fileroot + '.mp4'
  anim.save(moviefile, writer='ffmpeg', fps=60, dpi=200)
  print(moviefile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python animate_xyprime_wave.py wilkinoid
#+END_SRC

#+RESULTS:
[[file:animate_xyprime_wave-wilkinoid.mp4]]

*** Characteristic radii for standing wave

**** Wilkinoid
#+name: test-wave-diagnostic
#+header: :var phase=0.0 amplitude=0.1 wavenumber=1.0
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic
  import standing_wave

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = standing_wave.StandingWave(
      bp.wilkinoid_R_theta, amplitude=amplitude, wavenumber=wavenumber, phase=phase)
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 19)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-wave-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|      1.1 |      0 |      90 |      180 |          1.5746 |         1.4474 |   0 |
|   1.1019 |    7.2 |    90.3 |      180 |          1.5747 |         1.4475 |   5 |
|   1.1076 |   14.5 |    91.2 |      180 |          1.5751 |         1.4479 |  10 |
|   1.1172 |   21.9 |    92.7 |      180 |          1.5758 |         1.4487 |  15 |
|   1.1311 |   29.3 |    94.8 |      180 |          1.5768 |         1.4497 |  20 |
|   1.1497 |   36.9 |    97.4 |      180 |          1.5781 |         1.4511 |  25 |
|   1.1736 |   44.7 |   100.7 |      180 |          1.5797 |         1.4528 |  30 |
|   1.2036 |   52.7 |   104.5 |      180 |          1.5817 |         1.4549 |  35 |
|    1.241 |     61 |   108.9 |      180 |          1.5841 |         1.4575 |  40 |
|   1.2875 |   69.7 |   113.8 |      180 |           1.587 |         1.4606 |  45 |
|   1.3455 |     79 |   119.3 |      180 |          1.5904 |         1.4644 |  50 |
|    1.419 |   88.8 |   125.4 |      180 |          1.5944 |          1.469 |  55 |
|    1.514 |   99.4 |     132 |      180 |          1.5989 |         1.4747 |  60 |
|   1.6408 |  110.9 |   139.1 |      180 |          1.6036 |         1.4816 |  65 |
|   1.8184 |  123.4 |   146.7 |      180 |          1.6081 |         1.4892 |  70 |
|   2.0864 |  136.6 |   154.6 |      180 |          1.6117 |         1.4963 |  75 |
|   2.5463 |  150.6 |   162.9 |      180 |          1.6133 |         1.5009 |  80 |
|   3.5983 |  165.1 |   171.4 |      180 |          1.6129 |         1.5014 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |


***** Tables for amplitude=0.1 wavenumber=1.0
#+call: test-wave-diagnostic(phase=0.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|      1.1 |      0 |      90 |      180 |          1.5746 |         1.4465 |   0 |
|   1.1019 |    7.2 |    90.3 |      180 |          1.5747 |         1.4458 |   5 |
|   1.1076 |   14.5 |    91.2 |      180 |          1.5751 |         1.4452 |  10 |
|   1.1173 |   21.9 |    92.7 |      180 |          1.5757 |         1.4448 |  15 |
|   1.1312 |   29.3 |    94.8 |      180 |          1.5767 |         1.4448 |  20 |
|   1.1498 |   36.9 |    97.4 |      180 |          1.5779 |         1.4451 |  25 |
|   1.1738 |   44.7 |   100.7 |      180 |          1.5795 |         1.4453 |  30 |
|   1.2038 |   52.7 |   104.5 |      180 |          1.5815 |         1.4468 |  35 |
|   1.2412 |     61 |   108.9 |      180 |          1.5838 |         1.4485 |  40 |
|   1.2877 |   69.7 |   113.8 |      180 |          1.5867 |         1.4504 |  45 |
|   1.3458 |     79 |   119.3 |      180 |          1.5901 |         1.4538 |  50 |
|   1.4194 |   88.8 |   125.4 |      180 |           1.594 |         1.4583 |  55 |
|   1.5143 |   99.4 |     132 |      180 |          1.5986 |         1.4647 |  60 |
|   1.6412 |  110.9 |   139.1 |      180 |          1.6033 |         1.4712 |  65 |
|   1.8187 |  123.4 |   146.7 |      180 |          1.6079 |         1.4796 |  70 |
|   2.0867 |  136.6 |   154.6 |      180 |          1.6114 |         1.4868 |  75 |
|   2.5469 |  150.6 |   162.9 |      180 |           1.613 |         1.4909 |  80 |
|   3.5989 |  165.1 |   171.4 |      180 |          1.6126 |         1.4922 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.5)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|      0.9 |      0 |      90 |      180 |          1.9245 |         2.0427 |   0 |
|   0.9036 |   10.2 |    90.4 |      180 |          1.9225 |          2.034 |   5 |
|   0.9145 |   20.3 |    91.5 |      180 |          1.9168 |         2.0153 |  10 |
|   0.9327 |   30.1 |    93.4 |      180 |          1.9078 |         1.9887 |  15 |
|   0.9585 |   39.6 |    95.9 |      180 |          1.8958 |         1.9577 |  20 |
|   0.9926 |   48.8 |    99.1 |      180 |          1.8811 |         1.9213 |  25 |
|   1.0356 |   57.8 |   102.8 |      180 |          1.8647 |         1.8861 |  30 |
|   1.0888 |   66.7 |     107 |      180 |          1.8463 |         1.8472 |  35 |
|   1.1535 |   75.3 |   111.6 |      180 |          1.8267 |         1.8123 |  40 |
|   1.2326 |     84 |   116.7 |      180 |          1.8057 |         1.7741 |  45 |
|    1.329 |   92.6 |   122.1 |      180 |          1.7839 |         1.7407 |  50 |
|   1.4482 |  101.4 |   127.9 |      180 |           1.761 |         1.7057 |  55 |
|    1.598 |  110.4 |   134.1 |      180 |          1.7371 |         1.6711 |  60 |
|   1.7914 |  119.8 |   140.7 |      180 |          1.7123 |         1.6349 |  65 |
|   2.0512 |  129.7 |   147.7 |      180 |          1.6873 |         1.6017 |  70 |
|   2.4258 |  140.3 |   155.1 |      180 |          1.6621 |         1.5667 |  75 |
|   3.0374 |  152.1 |   163.1 |      180 |          1.6385 |          1.532 |  80 |
|   4.3695 |  165.3 |   171.4 |      180 |          1.6197 |          1.504 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.25)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|        1 |      0 |      90 |      180 |          1.7321 |         1.6667 |   0 |
|   1.0025 |    8.3 |    90.3 |      180 |          1.7317 |         1.6663 |   5 |
|   1.0102 |   16.7 |    91.4 |      180 |          1.7307 |          1.665 |  10 |
|   1.0233 |   25.1 |      93 |      180 |          1.7291 |         1.6629 |  15 |
|   1.0421 |   33.5 |    95.4 |      180 |          1.7267 |           1.66 |  20 |
|   1.0672 |     42 |    98.3 |      180 |          1.7236 |         1.6561 |  25 |
|   1.0994 |   50.6 |   101.8 |      180 |          1.7197 |         1.6513 |  30 |
|   1.1398 |   59.3 |   105.8 |      180 |          1.7151 |         1.6454 |  35 |
|     1.19 |   68.2 |   110.4 |      180 |          1.7095 |         1.6384 |  40 |
|    1.252 |   77.2 |   115.4 |      180 |           1.703 |         1.6302 |  45 |
|    1.329 |   86.5 |   120.9 |      180 |          1.6954 |         1.6205 |  50 |
|   1.4254 |     96 |   126.8 |      180 |          1.6867 |         1.6093 |  55 |
|   1.5485 |  105.9 |   133.2 |      180 |          1.6769 |         1.5964 |  60 |
|   1.7097 |  116.3 |     140 |      180 |          1.6658 |         1.5816 |  65 |
|   1.9302 |  127.2 |   147.2 |      180 |          1.6536 |         1.5647 |  70 |
|   2.2533 |  138.9 |   154.9 |      180 |          1.6407 |         1.5461 |  75 |
|   2.7906 |  151.5 |     163 |      180 |          1.6277 |         1.5264 |  80 |
|   3.9834 |  165.2 |   171.4 |      180 |          1.6168 |         1.5086 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |


***** Tables for wavenumber=2
#+call: test-wave-diagnostic(phase=0.0, wavenumber=2.0, amplitude=0.05)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|     1.05 |      0 |      90 |      180 |          1.5671 |         1.2643 |   0 |
|   1.0511 |    6.3 |    90.3 |      180 |          1.5692 |         1.2658 |   5 |
|   1.0544 |   12.8 |    91.4 |      180 |          1.5755 |         1.2712 |  10 |
|   1.0601 |   19.4 |    93.1 |      180 |          1.5861 |         1.2812 |  15 |
|   1.0687 |   26.2 |    95.5 |      180 |          1.6011 |          1.296 |  20 |
|   1.0808 |   33.5 |    98.6 |      180 |          1.6206 |         1.3173 |  25 |
|   1.0974 |   41.5 |   102.3 |      180 |          1.6442 |         1.3473 |  30 |
|   1.1204 |   50.4 |   106.5 |      180 |          1.6712 |         1.3887 |  35 |
|   1.1523 |   60.6 |   111.4 |      180 |          1.6995 |         1.4456 |  40 |
|   1.1978 |   72.4 |   116.6 |      180 |          1.7253 |         1.5171 |  45 |
|   1.2633 |   85.3 |   122.2 |      180 |          1.7432 |         1.5869 |  50 |
|   1.3566 |   97.8 |   128.2 |      180 |          1.7495 |         1.6327 |  55 |
|   1.4858 |  109.3 |   134.5 |      180 |          1.7441 |         1.6493 |  60 |
|   1.6631 |    120 |     141 |      180 |          1.7289 |         1.6442 |  65 |
|   1.9109 |  130.5 |     148 |      180 |           1.706 |         1.6201 |  70 |
|    2.274 |  141.2 |   155.3 |      180 |          1.6782 |         1.5877 |  75 |
|   2.8696 |  152.6 |   163.1 |      180 |          1.6486 |         1.5476 |  80 |
|   4.1579 |  165.5 |   171.4 |      180 |          1.6229 |         1.5093 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.5, wavenumber=2.0, amplitude=0.05)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|     0.95 |      0 |      90 |      180 |          1.9144 |         2.5635 |   0 |
|   0.9556 |   12.5 |    90.3 |      180 |          1.9076 |         2.5025 |   5 |
|   0.9716 |   23.7 |    91.4 |      180 |          1.8894 |         2.3745 |  10 |
|   0.9966 |   33.5 |      93 |      180 |          1.8637 |         2.2348 |  15 |
|   1.0295 |   42.2 |    95.3 |      180 |          1.8338 |         2.1047 |  20 |
|   1.0698 |   50.2 |    98.1 |      180 |           1.802 |         1.9902 |  25 |
|   1.1175 |   57.8 |   101.4 |      180 |          1.7697 |         1.8899 |  30 |
|   1.1729 |   65.1 |   105.2 |      180 |          1.7382 |         1.8046 |  35 |
|   1.2367 |   72.4 |   109.5 |      180 |           1.708 |         1.7311 |  40 |
|   1.3102 |   79.7 |   114.2 |      180 |            1.68 |         1.6692 |  45 |
|   1.3957 |   87.1 |   119.5 |      180 |          1.6541 |         1.6131 |  50 |
|   1.4962 |     95 |   125.3 |      180 |          1.6316 |         1.5664 |  55 |
|   1.6166 |  103.4 |   131.7 |      180 |          1.6133 |         1.5284 |  60 |
|   1.7665 |  112.7 |   138.7 |      180 |             1.6 |         1.4962 |  65 |
|   1.9627 |  123.3 |   146.3 |      180 |          1.5937 |          1.476 |  70 |
|   2.2445 |  135.7 |   154.4 |      180 |           1.595 |         1.4677 |  75 |
|    2.718 |    150 |   162.8 |      180 |          1.6021 |          1.475 |  80 |
|   3.8111 |    165 |   171.4 |      180 |          1.6092 |         1.4865 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

***** Tables for wavenumber=4
#+call: test-wave-diagnostic(phase=0.0, wavenumber=4, amplitude=0.02)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|   1.0199 |      0 |      90 |      180 |          1.7322 |         1.1054 |   0 |
|   1.0202 |    5.5 |    90.3 |      180 |          1.7358 |         1.1209 |   5 |
|   1.0214 |   11.3 |    91.4 |      180 |           1.746 |         1.1584 |  10 |
|   1.0244 |   17.9 |      93 |      180 |          1.7611 |          1.228 |  15 |
|   1.0306 |   26.1 |    95.2 |      180 |          1.7785 |         1.3769 |  20 |
|   1.0458 |     39 |    97.9 |      180 |          1.7887 |          1.664 |  25 |
|   1.0799 |   54.9 |   101.2 |      180 |          1.7751 |         1.8569 |  30 |
|   1.1318 |   65.5 |   104.9 |      180 |          1.7437 |         1.8506 |  35 |
|   1.1961 |   73.5 |   109.2 |      180 |          1.7072 |         1.7804 |  40 |
|   1.2707 |   80.6 |   114.1 |      180 |          1.6725 |         1.6962 |  45 |
|   1.3557 |   87.4 |   119.7 |      180 |          1.6447 |         1.6183 |  50 |
|   1.4531 |   94.5 |   126.1 |      180 |          1.6272 |         1.5494 |  55 |
|   1.5666 |  102.3 |   133.1 |      180 |          1.6246 |         1.5008 |  60 |
|   1.7061 |    112 |   140.3 |      180 |          1.6381 |         1.4832 |  65 |
|    1.899 |  125.1 |   147.8 |      180 |          1.6593 |         1.5114 |  70 |
|   2.2107 |  139.5 |   155.4 |      180 |          1.6668 |         1.5509 |  75 |
|   2.7705 |  152.5 |   163.2 |      180 |           1.652 |         1.5471 |  80 |
|   4.0259 |  165.5 |   171.4 |      180 |          1.6261 |         1.5139 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.5, wavenumber=4, amplitude=0.02)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|   0.9801 |      0 |      90 |      180 |          1.7319 |           3.52 |   0 |
|   0.9889 |   14.9 |    90.3 |      180 |          1.7206 |         2.8721 |   5 |
|   1.0079 |     24 |    91.4 |      180 |          1.7002 |         2.3291 |  10 |
|   1.0322 |     31 |    93.1 |      180 |          1.6807 |         1.9907 |  15 |
|   1.0599 |   37.2 |    95.5 |      180 |          1.6662 |         1.7661 |  20 |
|   1.0896 |     43 |    98.7 |      180 |          1.6603 |         1.6242 |  25 |
|   1.1216 |   48.8 |   102.4 |      180 |          1.6634 |         1.5252 |  30 |
|   1.1563 |   54.9 |   106.8 |      180 |          1.6765 |         1.4631 |  35 |
|    1.195 |   61.9 |   111.5 |      180 |          1.6987 |          1.437 |  40 |
|    1.241 |   70.9 |   116.5 |      180 |          1.7264 |         1.4634 |  45 |
|   1.3036 |   84.2 |   121.8 |      180 |          1.7485 |         1.5771 |  50 |
|   1.4008 |   98.8 |   127.4 |      180 |          1.7457 |         1.6658 |  55 |
|   1.5394 |  109.9 |   133.3 |      180 |          1.7202 |         1.6672 |  60 |
|   1.7231 |  119.3 |   139.7 |      180 |          1.6841 |         1.6283 |  65 |
|   1.9649 |  128.5 |   146.7 |      180 |          1.6462 |         1.5739 |  70 |
|   2.2977 |  138.4 |   154.4 |      180 |          1.6153 |         1.5194 |  75 |
|    2.816 |  150.3 |   162.7 |      180 |          1.6013 |         1.4821 |  80 |
|   3.9439 |  164.9 |   171.3 |      180 |          1.6061 |         1.4816 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |


**** Cantoid
#+name: test-wave-diagnostic-cantoid
#+header: :var beta=0.01 phase=0.0 amplitude=0.1 wavenumber=1.0
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic
  import standing_wave

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = standing_wave.StandingWave(
      bp.cantoid_R_theta,
      amplitude=amplitude, wavenumber=wavenumber, phase=phase,
      beta=beta)
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 19)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC


***** Tables for \beta = 0.1, amplitude=0.1 wavenumber=1.0
#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.0)
#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|      1.1 |      0 |      90 |    128.8 |          2.2807 |         1.9953 |    0 |
|   1.1008 |    4.3 |    90.1 |    128.8 |          2.2825 |         1.9965 |  2.2 |
|   1.1031 |    8.6 |    90.5 |    128.8 |          2.2879 |         2.0001 |  4.3 |
|    1.107 |     13 |    91.1 |    128.8 |          2.2971 |         2.0063 |  6.5 |
|   1.1126 |   17.4 |    91.9 |    128.8 |          2.3104 |         2.0153 |  8.6 |
|     1.12 |   21.8 |    92.9 |    128.8 |          2.3282 |         2.0274 | 10.8 |
|   1.1291 |   26.4 |    94.2 |    128.8 |          2.3513 |          2.043 | 12.9 |
|   1.1404 |   31.1 |    95.8 |    128.8 |          2.3806 |         2.0627 | 15.1 |
|   1.1538 |   35.9 |    97.6 |    128.8 |          2.4174 |         2.0877 | 17.2 |
|   1.1698 |   40.9 |    99.6 |    128.8 |          2.4636 |          2.119 | 19.4 |
|   1.1886 |   46.1 |   101.8 |    128.8 |           2.522 |         2.1586 | 21.5 |
|   1.2109 |   51.7 |   104.4 |    128.8 |          2.5967 |         2.2094 | 23.7 |
|   1.2373 |   57.6 |   107.1 |    128.8 |          2.6944 |         2.2764 | 25.9 |
|   1.2689 |   64.1 |   110.1 |    128.8 |          2.8261 |         2.3672 |   28 |
|   1.3075 |   71.2 |   113.4 |    128.8 |          3.0122 |         2.4971 | 30.2 |
|   1.3559 |   79.4 |   116.9 |    128.8 |          3.2956 |         2.6981 | 32.3 |
|     1.42 |   89.2 |   120.6 |    128.8 |           3.788 |         3.0543 | 34.5 |
|   1.5153 |  101.9 |   124.6 |    128.8 |          4.9353 |         3.9022 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.25)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    128.8 |          2.5088 |         2.4375 |    0 |
|    1.001 |    5.3 |    90.1 |    128.8 |          2.5105 |         2.4389 |  2.2 |
|   1.0041 |   10.5 |    90.5 |    128.8 |          2.5156 |         2.4435 |  4.3 |
|   1.0093 |   15.8 |    91.1 |    128.8 |          2.5244 |         2.4512 |  6.5 |
|   1.0166 |   21.1 |      92 |    128.8 |          2.5372 |         2.4625 |  8.6 |
|   1.0263 |   26.5 |    93.1 |    128.8 |          2.5543 |         2.4776 | 10.8 |
|   1.0384 |   31.9 |    94.5 |    128.8 |          2.5764 |         2.4972 | 12.9 |
|   1.0532 |   37.4 |    96.1 |    128.8 |          2.6045 |          2.522 | 15.1 |
|    1.071 |     43 |    97.9 |    128.8 |          2.6398 |         2.5532 | 17.2 |
|   1.0922 |   48.7 |    99.9 |    128.8 |          2.6841 |         2.5925 | 19.4 |
|   1.1173 |   54.5 |   102.2 |    128.8 |          2.7401 |         2.6422 | 21.5 |
|    1.147 |   60.6 |   104.7 |    128.8 |          2.8119 |         2.7057 | 23.7 |
|   1.1824 |   66.8 |   107.5 |    128.8 |          2.9058 |         2.7885 | 25.9 |
|   1.2249 |   73.4 |   110.4 |    128.8 |          3.0328 |         2.9004 |   28 |
|   1.2768 |   80.4 |   113.6 |    128.8 |          3.2127 |         3.0592 | 30.2 |
|   1.3419 |     88 |     117 |    128.8 |           3.488 |         3.2997 | 32.3 |
|    1.428 |   96.5 |   120.7 |    128.8 |          3.9692 |         3.7177 | 34.5 |
|   1.5546 |  106.9 |   124.6 |    128.8 |          5.1001 |         4.6823 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.5)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|      0.9 |      0 |      90 |    128.8 |          2.7875 |         3.3428 |    0 |
|   0.9015 |    7.2 |    90.1 |    128.8 |          2.7882 |         3.3379 |  2.2 |
|    0.906 |   14.2 |    90.5 |    128.8 |          2.7906 |         3.3247 |  4.3 |
|   0.9134 |   21.1 |    91.2 |    128.8 |          2.7949 |         3.3056 |  6.5 |
|   0.9239 |   27.7 |    92.1 |    128.8 |          2.8016 |          3.284 |  8.6 |
|   0.9375 |   34.1 |    93.3 |    128.8 |          2.8116 |         3.2632 | 10.8 |
|   0.9544 |   40.2 |    94.7 |    128.8 |          2.8255 |         3.2458 | 12.9 |
|   0.9747 |   46.2 |    96.3 |    128.8 |          2.8446 |         3.2341 | 15.1 |
|   0.9987 |     52 |    98.2 |    128.8 |          2.8703 |         3.2302 | 17.2 |
|    1.027 |   57.7 |   100.3 |    128.8 |          2.9046 |         3.2368 | 19.4 |
|     1.06 |   63.4 |   102.6 |    128.8 |          2.9503 |         3.2552 | 21.5 |
|   1.0986 |     69 |   105.1 |    128.8 |          3.0114 |         3.2916 | 23.7 |
|    1.144 |   74.7 |   107.8 |    128.8 |          3.0944 |         3.3502 | 25.9 |
|   1.1979 |   80.6 |   110.7 |    128.8 |            3.21 |         3.4415 |   28 |
|    1.263 |   86.8 |   113.8 |    128.8 |          3.3783 |         3.5826 | 30.2 |
|    1.344 |   93.3 |   117.2 |    128.8 |          3.6415 |         3.8144 | 32.3 |
|   1.4497 |  100.7 |   120.8 |    128.8 |          4.1096 |         4.2377 | 34.5 |
|   1.6036 |  109.6 |   124.6 |    128.8 |          5.2251 |         5.2052 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

***** Tables for \beta = 0.1, amplitude=0.02 wavenumber=4.0
#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.0, amplitude=0.02, wavenumber=4.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|     1.02 |      0 |      90 |    128.8 |          2.5088 |         1.3812 |    0 |
|   1.0203 |      3 |    90.1 |    128.8 |          2.5123 |         1.3856 |  2.2 |
|   1.0211 |      6 |    90.5 |    128.8 |          2.5231 |         1.3991 |  4.3 |
|   1.0226 |    9.2 |    91.1 |    128.8 |          2.5411 |         1.4231 |  6.5 |
|   1.0249 |   12.6 |      92 |    128.8 |          2.5666 |         1.4608 |  8.6 |
|   1.0281 |   16.4 |    93.1 |    128.8 |          2.5995 |         1.5183 | 10.8 |
|   1.0326 |   20.9 |    94.4 |    128.8 |            2.64 |         1.6097 | 12.9 |
|   1.0393 |   26.9 |      96 |    128.8 |          2.6875 |         1.7771 | 15.1 |
|   1.0503 |   38.3 |    97.8 |    128.8 |          2.7379 |         2.2461 | 17.2 |
|   1.0721 |   53.7 |    99.8 |    128.8 |          2.7765 |         2.9468 | 19.4 |
|   1.1037 |   61.8 |     102 |    128.8 |          2.8108 |         3.1394 | 21.5 |
|    1.142 |   67.8 |   104.5 |    128.8 |          2.8538 |         3.1957 | 23.7 |
|   1.1868 |     73 |   107.2 |    128.8 |          2.9155 |         3.2116 | 25.9 |
|   1.2385 |     78 |   110.2 |    128.8 |          3.0086 |         3.2242 |   28 |
|   1.2983 |     83 |   113.4 |    128.8 |           3.155 |         3.2551 | 30.2 |
|   1.3686 |   88.5 |   116.9 |    128.8 |          3.3991 |         3.3399 | 32.3 |
|   1.4543 |   94.9 |   120.6 |    128.8 |          3.8553 |         3.5479 | 34.5 |
|   1.5693 |    104 |   124.6 |    128.8 |          4.9769 |         4.1857 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.5, amplitude=0.02, wavenumber=4.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|     0.98 |      0 |      90 |    128.8 |          2.5088 |         11.942 |    0 |
|    0.985 |   14.6 |    90.1 |    128.8 |          2.5002 |         6.9256 |  2.2 |
|   0.9949 |     21 |    90.5 |    128.8 |          2.4882 |         5.0329 |  4.3 |
|   1.0072 |   25.8 |    91.1 |    128.8 |          2.4792 |         4.1256 |  6.5 |
|   1.0213 |   29.9 |      92 |    128.8 |          2.4754 |         3.5804 |  8.6 |
|    1.037 |   33.6 |    93.1 |    128.8 |          2.4784 |         3.2153 | 10.8 |
|   1.0541 |     37 |    94.5 |    128.8 |          2.4897 |         2.9526 | 12.9 |
|   1.0725 |   40.4 |    96.2 |    128.8 |           2.511 |         2.7569 | 15.1 |
|   1.0923 |   43.8 |      98 |    128.8 |          2.5443 |         2.6091 | 17.2 |
|   1.1136 |   47.2 |   100.1 |    128.8 |          2.5922 |          2.498 | 19.4 |
|   1.1366 |   50.9 |   102.4 |    128.8 |          2.6584 |         2.4192 | 21.5 |
|   1.1618 |   54.8 |     105 |    128.8 |           2.748 |         2.3718 | 23.7 |
|   1.1897 |   59.4 |   107.7 |    128.8 |          2.8686 |         2.3622 | 25.9 |
|   1.2216 |     65 |   110.7 |    128.8 |          3.0326 |         2.4141 |   28 |
|   1.2605 |   73.3 |   113.8 |    128.8 |          3.2596 |         2.6121 | 30.2 |
|   1.3155 |   86.6 |   117.2 |    128.8 |          3.5805 |          3.197 | 32.3 |
|   1.4033 |   98.7 |   120.8 |    128.8 |          4.0829 |         3.9949 | 34.5 |
|   1.5453 |  109.3 |   124.6 |    128.8 |          5.2074 |           5.15 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |





*** Write files of (R_c, R_90) versus inclination and phase
+ It takes a long time to run a large number of models, so I want to decouple the calculations from the graphing
+ This will allow me to experiment more with the graphs

#+BEGIN_SRC python :eval no :tangle save-wave-data.py
  import sys
  import json
  import numpy as np
  import scanf

  import bow_projection as bp
  import bow_diagnostic
  import dragoid_shape
  import ancantoid_shape
  import standing_wave


  # Parse command line arguments
  try:
      BASE_SHAPE_ID = sys.argv[1]
      AMPLITUDE = float(sys.argv[2])
      WAVENUMBER = float(sys.argv[3])
  except:
      sys.exit(f"Usage: {sys.argv[0]} BASE_SHAPE_ID AMPLITUDE WAVENUMBER")

  # Sensible defaults for the poly fitting to get R_c and R_90
  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01


  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"
      bp.SCALE_NEIGHBORHOOD = 0.2

  # Create perturbed shape
  shape = standing_wave.StandingWave(base_shape,
                                     amplitude=AMPLITUDE,
                                     wavenumber=WAVENUMBER)


  # Create arrays of inclinations and phases
  nphase, ninc = 21, 50
  phases = np.linspace(0.0, 0.5, nphase)
  # Uniform distribution in sin inc
  inclinations = np.arcsin(np.linspace(0.0, 1.0, ninc))
  # Allocate arrays to hold the (R_c, R_90) results
  Rc = np.empty((ninc, nphase))
  R90 = np.empty((ninc, nphase))
  # Loop over inclinations and phases and save the radii
  for i, inclination in enumerate(inclinations):
      for j, phase in enumerate(phases):
          shape.phase = phase
          radii = bp.characteristic_radii_projected(inclination, shape)
          Rc[i, j] = radii['tilde R_c prime']
          R90[i, j] = radii['tilde R_90 prime']


  # Save the results
  shape_id = f"{BASE_SHAPE_ID}-wave-A{int(100*AMPLITUDE):03d}-N{int(10*WAVENUMBER):02d}"

  # Save Rc, R90 arrays in binary format
  # To retrieve:
  #
  # >>> arrays = np.load(FILE.npz)
  # >>> Rc = arrays['Rc']
  #
  # Etcetera
  np.savez(shape_id, Rc=Rc, R90=R90)

  # Save metadata as JSON 
  metadata = {
      'shape_id': shape_id,
      'shape_label': shape_label,
      'wave_label': f"Perturbation $A = {AMPLITUDE}$, $N = {WAVENUMBER}$",
      'ninc': ninc,
      'nphase': nphase,
      'inclinations': list(np.round(np.degrees(inclinations), 1)),
      'phases': list(np.round(phases, 4)),
  }
  jsonfile = shape_id + ".json"
  with open(jsonfile, 'w') as f:
      json.dump(metadata, f, indent=4)

  print(jsonfile, end='')
#+END_SRC


**** Generate the data for different shapes and waves

#+name: run-save-wave
#+header: :var A=0.1 N=1.5
#+BEGIN_SRC sh :results verbatim
  for shape in wilkinoid cantoid-beta002000 ancantoid-xi080-beta000500 dragoid-alpha100; do
      python save-wave-data.py $shape $A $N
      echo
  done
#+END_SRC

#+RESULTS: run-save-wave
: wilkinoid-wave-A010-N15.jsoncantoid-beta002000-wave-A010-N15.jsonancantoid-xi080-beta000500-wave-A010-N15.jsondragoid-alpha100-wave-A010-N15.json

#+call: run-save-wave(A=0.1, N=1)

#+RESULTS:
: wilkinoid-wave-A010-N10.json
: cantoid-beta002000-wave-A010-N10.json
: ancantoid-xi080-beta000500-wave-A010-N10.json
: dragoid-alpha100-wave-A010-N10.json

#+call: run-save-wave(A=0.05, N=2)

#+RESULTS:
: wilkinoid-wave-A005-N20.json
: cantoid-beta002000-wave-A005-N20.json
: ancantoid-xi080-beta000500-wave-A005-N20.json
: dragoid-alpha100-wave-A005-N20.json


#+call: run-save-wave(A=0.01, N=5)

#+RESULTS:
: wilkinoid-wave-A001-N50.json
: cantoid-beta002000-wave-A001-N50.json
: ancantoid-xi080-beta000500-wave-A001-N50.json
: dragoid-alpha100-wave-A001-N50.json

*** Figure of R_c-R_90 for the standing wave
This is something I never got finished for the multi-quadric fits

#+BEGIN_SRC python :eval no :tangle wave-R90-vs-Rc.py
  import sys
  import json
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns

  try:
      WAVE_ID = sys.argv[1]
      BASE_SHAPE_IDS = sys.argv[2:]
  except:
      sys.exit(f"Usage: {sys.argv[0]} WAVE_ID SHAPE_ID [SHAPE_ID ...]")

  plotfile = sys.argv[0].replace('.py', f'-{WAVE_ID}.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(5, 5))

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)

  nshapes = len(BASE_SHAPE_IDS)
  colors = sns.color_palette(n_colors=nshapes)
  for base_shape_id, color in zip(BASE_SHAPE_IDS, colors):
      prefix = f"{base_shape_id}-wave-{WAVE_ID}"
      metadata = json.load(open(prefix + '.json'))
      data = np.load(prefix + '.npz')
      Rc, R90 = data['Rc'], data['R90']
      for x, y in zip(Rc, R90):
          ax.plot(x, y, '-', lw=2, c=color, label="_nolabel_", alpha=0.3)
      ax.plot(Rc[0], R90[0], '-', lw=3, c=color,
              label=metadata['shape_label'], alpha=0.8)

  ax.legend(title=metadata['wave_label'])

  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        

  sns.despine()
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A010-N15 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A010-N15.pdf]]


#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A010-N10 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A010-N10.pdf]]

#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A005-N20 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A005-N20.pdf]]

#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A001-N50 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A001-N50.pdf]]


*** Slope of Rc-R90 graph from analytic estimate
|    N | (1 - cos(N\pi/2))/N |
|------+-------------------|
| 0.25 |              0.30 |
|  0.5 |              0.59 |
|  1.0 |              1.00 |
|  1.5 |              1.14 |
|  2.0 |              1.00 |
|  2.5 |              0.68 |
|  3.0 |              0.33 |
#+TBLFM: $2=(1 - cos($1 90))/$1 ; f2


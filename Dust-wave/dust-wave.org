* Bow waves vs dust waves vs bow shocks
+ For the dust wave case, we have distance of closest approach
  \[
  R_{0} = (\sigma Q / m) (L / 2 \pi c v^{2})
  \]
+ For the bow shock case, we have
  \[
  \dot{M} V / 4 \pi R_{0}^{2} = \rho (v^{2} + c^{2}) \Rightarrow R_{0} = \left( \frac{\dot{M} V} {4\pi \rho (v^{2} + c^{2})}\right)^{1/2}
  \]
+ Difference is that with dust wave, we have an extra R_0 in the \tau, which gives the fraction of the radiation pressure absorbed in the bow
+ The ratio of ram pressure to radiation pressure is \(\eta_\mathrm{mom} = \dot{M} V / (L / c)\)
+ I have solved the general case (see iPad notes)
  + Characteristic radius for opaque radiative bow shock \(R_{*}^{2} = L / 4\pi c \rho v^{2}\)
  + Characteristic optical depth \(\tau_{*} = \rho \kappa R_{*}\)
  + Define \(x = R_{0} / R_{*}\) for actual radius in terms of fiducial one
  + Then we have the following transcendental equation for x
    \[
    x^{2} - \left( 1 - e^{-2\tau_{*} x} \right) - \eta = 0
    \]
    + For \(\tau_* \gg 1\), the solution is \(x = (1 + \eta)^{1/2}\)
      + /Radiation bow shock/ 
    + For \(x \tau_{*} \ll 1\), the solution is \(x = \tau_{*} + (\tau_{*}^{2} + \eta)^{1/2}\)
      + \(\eta \ll \tau_{*}^{2}\) then \(x = 2 \tau_{*}\)
        + /Radiation bow wave/
        + In this case R_0 is independent of n
      + \(\eta \gg \tau_{*}^{2}\) then \(x = \eta^{1/2}\)
        + /Wind bow shock/
  + Also, we have the following in fiducial units
    + \(\eta = 0.495 \dot{M}_{-7} V_{3} / L_4\)
    + \(R_* = \SI{2.21}{pc}\ L_{4}^{1/2} n^{-1/2} v_{10}^{-1}\)
    + \(\tau_{*} = 0.0089 \kappa_{600} L_{4}^{1/2} n^{1/2} v_{10}^{-1}\)
+ Table of stars from Meyer 2016
  |  M |   L_4 | \dot{M}_{-7} |    V_{3} |      \eta |
  |----+------+-----------+-------+--------|
  | 10 | 0.63 |     0.003 | 1.082 | 0.0026 |
  | 20 |  5.5 |      0.42 | 1.167 | 0.0446 |
  | 40 |   22 |       5.1 | 1.451 | 0.1682 |
  #+TBLFM: $5=0.5 $3 $4 / $2 ;f4
  + So looks like I forgot the factor of 0.5 when I did it by hand
+ Corrected Table of stars wit the good velocities
  |  M |    L_4 | \dot{M}_{-7} |    V_{3} |      \eta |
  |----+-------+-----------+-------+--------|
  | 10 |  0.63 | 3.3884e-3 | 2.467 | 0.0066 |
  | 20 | 5.453 |     0.492 | 2.657 | 0.1199 |
  | 40 | 22.19 |         6 | 3.305 | 0.4468 |
  #+TBLFM: $5=0.5 $3 $4 / $2 ;f4

** Diagrams of v--n plane
*** Strong coupling case
+ [X] Add in the i-front trapping
  + Column density of shell: \(\frac34 R n\)
  + Shell thickness: \(h = \frac34 R (c_{s} / v)^{2} \simeq \frac34 R v_{10}^{-2}\)
  + Shell EM: \( (\frac34 R n)^{2} / h = \frac34 v_{10}^{2} n^{2} R\)
  + Compare recombinations in shell with ionizing flux: \( f = \alpha_{B} . EM . 4\pi r^{2} / S_{*}\)
  + \( f = 3\pi v_{10}^{2} n^{2} R^{3} (\alpha_{B} /  S_{*})\) 
    + => \( f = 8.42\times 10^{-6} v_{10}^{2} n^{2} R_{pc}^{3} /  S_{49}\)
  + Alternatively, write
    + \(\mathcal{R} = \alpha \frac34 n^{2} R_{0} \mathcal{M}_{0}^{2}\)
    + \(\mathcal{F} = S / 4 \pi R_{0}^{2}\)
    + \(\mathcal{R}/\mathcal{F} = 3\pi \mathcal{M}_{0}^{2} n^{2} R_{0}^{3} \alpha / S \)
    + Where \(R_0  = x R_{*}\) and \(R_{*}^{2} = L / 4 \pi c n m \mathcal{M}_{0}^{2} c_{s}^{2}\)
    + So \(\mathcal{R}/\mathcal{F} = \frac34 x^{3} n R_{*} \alpha L / m c_{s}^{2} c S = \frac34 x^{3} \tau_{*} \alpha L / m^{2} \kappa c_{s}^{2} c S \)
      + where \(\alpha = 2.6\times 10^{-13} (T/10^{4}\,\mathrm{K})^{-0.7}\)
    + So, the ratio term is \(\alpha L / m^{2} \kappa c_{s}^{2} c S = 0.01365 L_{4} / S_{49} \kappa_{600} T_{8k}^{1.7}\)
    + Whereas \(\tau_{*} = 0.0089 \kappa_{600} L_{4}^{1/2} n^{1/2} / v_{10}\)
    + So for \(\mathcal{R} / \mathcal{F} \ge 1\) we have
      + \(9.111 \times 10^{-5}\, x^{3} \, L_{4}^{3/2} n^{1/2} / v_{10} S_{49} T_{8k}^{1.7} \ge 1\)
      + => \( n \ge 1.2046 \times 10^{8} v_{10}^{2} S_{49}^{2} T_{8k}^{3.4} / x^{6} L_{4}^{3} \)
      + Note the steep dependence on x
    + Value of x depends on the regime
      + RBS :: \(x^6 = (1 + \eta)^{3}\) which is 3 for the 40 Msun star
      + RBW :: \(x^6 = 64 \tau_{*}^{6}\) - but \(\tau_{*}\) depends on n, so we need to do more work to get n on the LHS again
        + \(x^{6} = 3.181\times 10^{-11} \kappa_{600}^{6} L_{4}^{3} n^{3} / v_{10}^{6} \)
  + Find ionization parameter \(U\) in shell
    + At inner edge
    + And at outer edge, after post-shock cooling
  + Then find ionization fraction \(y^{2} / (1 - y) = (c \sigma / \alpha_{B}) U\)
    + But we should also include hardening, which will reduce the \sigma, which means that y = 0.5 can be achieved at a larger U, so smaller tau_g
    + Red contour at y_out = 0.5 for outer shell (y_out = 0 or 0.9 would be at the same place)
      + to show the ionization front trapping by the bow
      + This is caused by gas opacity always, even when it is in a zone with dust \tau > 1
    + Various green contours of y_in = 0.99 ... 0.999 ... 0.9999 for the inside of shell
      + I am not too happy with the placement of the labels in the green contours, but I am fed up with fiddling with them
    + y_in seems not to vary in the bits that are pure bow shock - there must be a reason for this
      + Add text showing the minimum and maximum y_in
+ [ ] Also the rad pressure in the gas
+ [X] And the cooling length
  + We have the ur-table in [[id:8254B015-2CF3-412E-98D0-20B9EA47BA2E][llobjects.org]] that lists all the post-shock parameters as a function of Mach number
  + This seems to use the following cooling function
    + \(\Lambda = 3.3\times 10^{-24} (T_{1}/T_{0})^{2.3}\) for \(T_{1} < 10^{5}\)
    + \(\Lambda = 10^{-20} (T_{1}/T_{0})^{-1}\) for \(T_{1} > 10^{5}\)
    + At 1e5 K we get 6.5844e-22 from first and 1e-21 from second
    + We could either
      + take minimum of the two, which is what we did before
      + Or say \(\Lambda = (\Lambda_{1}^{-1} + \Lambda_{2}^{-1})^{-1}\), which would give 3.97e-22 at 1e5 K
      + Or even \(\Lambda = (\Lambda_{1}^{-k} + \Lambda_{2}^{-k})^{-(1/k)}\), which is equivalent to the min method as \(k \to \infty\)
  + We should also add in the heating coefficient:
    + Assume \Gamma = A T_4^{-1/2} and \Lambda = B T_4^{2.3} such that \Gamma = \Lambda at T_4 = 0.8
    + A/B = T_4^{2.8} = 0.536 
  + Cooling length is then given by
    + \(3 v_{1} k T_{1} / n_{1} \Lambda(T_{1})\)
    + where v_1, T_1, n_1 can be found in terms of n_0 and Mach number M
    + We should really be more precise about the T and sound speed
    + n m c^2 = 2 n k T => c = (2 k T / m)^{1/2} = 11.27 sqrt(T_4) km/s
      + So, 8000 K gives c = 10 km/s => we should use that
      + Would be slightly higher c if He is ionized, but never mind
    + Immediate post-shock values
      + Post-shock Mach number: \(M_{1} = [(M_{0}^{2} + 3) / (5 M_{0}^{2} - 1)]^{1/2}\)
      + Post-shock density: \(n_{1} / n_{0} = 4 M_{0}^{2}/ (M_{0}^{2} + 3) \)
      + Post-shock temperature: \(T_{1}/T_{0} = \frac1{16} (5 M_{0}^{2} - 1) (1 + 3/M_{0}^{2}) \)
      + Post-shock velocity: \( v_{1} / c_{0} = M_{1} c_{1}/c_{0} =  M_{1} (T_{1}/T_{0})^{1/2} \), assuming no significant changes in mean mass per particle.
      + Alternatively, we can say \( v_{1} / c_{0} = M_{0} n_{0} / n_{1}\), which is probably easier.
  + We need to compare cooling length with h, which we can get two versions of
    + Cooled shell \(h/R = 3/4 M^2\) with a correction at small M
    + Non-radiative shell. In [[id:E81CAB9A-D093-406F-99ED-74FFF75738B7][llobjects.org]] I derived \(h/R = \frac12 \sqrt{(\gamma - 1)/[2(\gamma + 1)]}\), which is equal to 0.177 for \(\gamma = 5/3\).
      + There is an alternative way of deriving this
      + Use h n_sh = 3/4 n_0 R_0
      + And then put n_sh = n_1 for the non-radiative shell
      + This gives h / R_0 = (3/4) (M_0^2 + 3) / 4 M_0^2
      + Which is h / R_0 = 3/16 = 0.1875 in high M_0 limit
      + However, this ignores that n_sh will increase from n_1 to make the pressure gradient that decelerates the gas from v_1 to 0
      + Assume constant acceleration from v_1 to 0 over length h:
        + v_1^2 = 2 a h => a = v_1^2 / 2 h
        + Subsonic, so d P / d s = -\rho a => a = \rho^-1 d P / d s
        + Adiabatic, so P = k \rho^\gamma - this means it will actually heat rather than cool as it slows down (assuming radiation is inefficient).
      + Better way, we can write P_cd = P_1 (1 + M_1^2)
        + n_cd = n_1 (1 + M_1^2)^{1/\gamma} and say n_sh \approx 1/2 (n_1 + n_cd)
        + Easier, suppose n_sh = n_1 (1 + \frac12 M_1^2)^{1/\gamma } 
        + Then, h / R = 3/4 n / n_sh = 3/4 / (n_1/n_0 (1 + \frac12 M_1^2)^{1/\gamma })
          + where M_1^2 = (M_0^2 + 3) / (5M_0^2 - 1)
          + and n_1 / n_0 = 4M_0^2 / (M_0^2 + 3)
      + Table of this
        |   M_0 | n_1/n_0 |   M_1^2 | n_sh/n_1 | h_ad / R_0 |   n_2/n_0 |   M_2^2 | n_sh/n_2 | h_c / R_0 |
        |------+-------+-------+--------+----------+---------+-------+--------+---------|
        |  1.5 | 1.714 | 0.512 |   1.15 |    0.380 |   2.250 | 0.444 |  1.222 |   0.273 |
        |  2.0 | 2.286 | 0.368 |   1.11 |    0.296 |   4.000 | 0.250 |  1.125 |   0.167 |
        |  3.0 | 3.000 | 0.273 |   1.08 |    0.231 |   9.000 | 0.111 |  1.056 |   0.079 |
        |  4.0 | 3.368 | 0.241 |   1.07 |    0.208 |  16.000 | 0.063 |  1.032 |   0.045 |
        |  5.0 | 3.571 | 0.226 |   1.07 |    0.196 |  25.000 | 0.040 |  1.020 |   0.029 |
        | 10.0 | 3.883 | 0.206 |   1.06 |    0.182 | 100.000 | 0.010 |  1.005 |   0.007 |
        | 20.0 | 3.970 | 0.202 |   1.06 |    0.178 | 400.000 | 0.003 |  1.002 |   0.002 |
        #+TBLFM: $2=4 $1**2 / ($1**2 + 3) ;f3::$3=($1**2 + 3)/(5 $1**2 - 1);f3::$4=(1 + 0.5 $3)**(3/5);f2::$5=(3/4) / ($2 $4);f3::$6=$1**2;f3::$7=1/$1**2;f3::$8=(1 + 0.5 $-1);f3::$9=(3/4) / ($-3 $-1);f3
      + Formally, the answer is 
        \[\frac{h}{R_{0}} = \frac{3}{16} (1 + 3/M_0^2) \left(1 + \frac{1 + 3/M_0^2} {2(5 - 1/M_0^2)}\right)^{-3/5} \]
      + This is remarkably close to my previous answer of 0.177 in M_0 \to \infty case
    + Although, to be fair the gas slows from v_1 as it moves from shock towards CD, so "residence time" in the stagnation area is longer than naive estimate of h/v_1
    + Maybe it would be more appropriate to compare cooling length with R_0
  + We can also find the radiation pressure scale height
    + \(H = c^{2} / a_{\text{rad}}\) - this will be important if it is smaller than h
    + So use c_s = 10 km/s as the minimum value
    + In the bow wave regime we have
      + a = \kappa L / 4 \pi c R^2
      + And R = \kappa L / 2 \pi c v^2
      + So H / R = c_s^2 / R a
      + where R a = v^2 / 2 => H = 2 / M^2 = (8/3) h = 2.66 h
    + So this is always larger than h
+ Check on the \sigma on axis: we should have \sigma = M^2 n h = (3/4) n R
  + This looks consistent with Fig 4 of Wilkin (1996) for \alpha = 0
  + In principle should follow from his equation (12), but can't be bothered to do the expansions
    + Wolfram alpha confirms this


#+BEGIN_SRC python :eval no :tangle zones-v-n-plane.py 
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from vec_root import chandrupatla

  figname = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, axes = plt.subplots(1, 3, sharex=True, sharey=True, figsize=(8, 4))
  stardata = [
      [10.0, 0.63, 0.0066, 1e-4, axes[0]],
      [20.0, 5.453, 0.1199, 0.1, axes[1]],
      [40.0, 22.19, 0.4468, 1.0, axes[2]],
  ]

  # Velocities in units of km/s (10 km/s -> 100 km/s)
  vgrid = np.linspace(10.0, 100.0, 800)
  # Densities in units of 1 pcc  (0.01 -> 1e5)
  logngrid = np.linspace(-3.3, 6.3, 800)
  # 2d versions of velocity and density grids
  vv, nn = np.meshgrid(vgrid, 10**logngrid)

  def rstar(v10, n, L4):
      """Characteristic radius in pc"""
      return 2.21*np.sqrt(L4/n)/v10

  def taustar(v10, n, L4, kappa600=1.0):
      """Characteristic optical depth"""
      return 0.0089*kappa600*np.sqrt(L4*n)/v10

  def xfunc(x, ts, eta):
      """Function to be zeroed to find x"""
      return x**2 - (1.0 - np.exp(-2*ts*x)) - eta

  R0s = (0.0003, 0.001, 0.003, 0.01, 0.03,
         0.1, 0.3, 1.0, 3.0, 10.0, 30.0)
  lws = np.linspace(0.3, 2.5, len(R0s))
  cformats = { 0.0001: "0.0001 pc", 0.001: "0.001 pc", 0.01: "0.01 pc", 0.1:
               "0.1 pc", 1.0: "1 pc", 10.0: "10 pc", }
  clevs_to_label = list(cformats.keys())

  box_params = dict(fc='w', ec='0.8', lw=0.4, pad=2)
  RBW_label = r"Radiation bow wave, $\eta < \tau < 1$"
  RBS_label = r"Radiation bow shock, $\tau > 1$"
  WBS_label = r"Wind bow shock, $\tau < \eta$"

  # Miscellaneous panel-dependent plot params
  d = {
      "RBW y": {10.0: 4000.0, 20.0: 5000.0, 40.0: 2500.0},
      "trapped y": {10.0: 3.5e4, 20.0: 2.5e5, 40.0: 1.5e5},
      "trapped bg": {10.0: '0.85', 20.0: 'w', 40.0: 'w'},
      "IF tau": {10.0: 0.2, 20.0: 3.7, 40.0: 6.4},
      "IF tau gas": {10.0: 5.0, 20.0: 5.0, 40.0: 5.0},
  }

  T0 = 8000
  kappa = 600.0
  for M, L4, eta, S49, ax in stardata:
      Mlabel = "\n".join([rf"$M = {M:.0f}\, M_\odot$",
                          rf"$L = {1e4*L4:.1e}\, L_\odot$".replace("e+0", r"\times 10^"),
                          rf"$\eta = {eta}$"])
      Rs = rstar(vv/10, nn, L4)
      ts = taustar(vv/10, nn, L4, kappa600=kappa/600.0)
      a, b = 0.0, 2*np.sqrt(1.0 + eta)
      x = chandrupatla(xfunc, a, b, args=(ts, eta))
      R0 = x*Rs
      tau = 2*x*ts

      # Ionization parameter - fiducial
      U = 2.789*S49 / (R0**2 * nn)
      # Shell ionization parameter - assume compression by M^2
      Ush = U/(vv/10)**2
      # Ionization fraction in shell
      ysh = 1.0 - 1.0/(3.5e5*Ush)

      # cs = ax.contour(vv, nn, ysh,
      #                 (0.9, 0.99, 0.999, 0.9999, 0.99999),
      #                 linewidths=1.0,
      #                 colors='g', alpha=0.5)
      # ax.clabel(cs,
      #           fontsize=5, colors='g', fmt='$%.5f$', 
      #           inline=True, inline_spacing=1, use_clabeltext=True)
      # ax.text(75, 6e-3, fr"$y_\mathrm{{in}} = {ysh.max():.5f}$",
      #         fontsize=5, color='g', alpha=0.5)
      # ax.text(12, 1.3e6, fr"$y_\mathrm{{in}} = {ysh.min():.5f}$",
      #         fontsize=5, color='g', alpha=0.5)

      # Fraction of ionizing photons absorbed in shell
      alphaB = 2.6e-13*(T0/1e4)**(-0.7)
      absfrac0 = 3*np.pi*(3.085677582e18)**3 * alphaB / 1e49
      absfrac = absfrac0 * (vv/10)**2 * nn**2 * R0**3 / S49
      # Equivalent optical depth
      tau_gas = -np.log(1.0 - absfrac)
      #absfrac = 2.76e-4 * (vv/10)**-1 * nn**0.5 * (L4)**1.5 / S49

      tau_dust = (3/8)*tau
      # Ionization parameter just outside the shell
      Uout = U*np.exp(-(tau_dust + tau_gas))
      Uout[~np.isfinite(Uout)] = 0.0
      Ushout = Uout/(vv/10)**2

      # y^2 / (1 - y) = CU
      # y = 0.1 => y^2 / (1 - y) = 0.0111111111111
      # y = 0.5 => y^2 / (1 - y) = 0.5
      # y = 0.9 => y^2 / (1 - y) = 8.1
      # y = 0.99 => y^2 / (1 - y) = 98.1

      # cu = 3.5e5*Uout

      # y_out = 0.5*cu * (np.sqrt(1.0 + 4/cu) - 1.0)
      # cs = ax.contour(vv, nn, Uout,
      #                 np.logspace(-7.0, 1.0, 9),
      #                 linewidths=np.linspace(0.2, 1.5, 9),
      #                 colors='r', alpha=0.5)
      # ax.clabel(cs,x
      #           fontsize='xx-small', colors='r', fmt='%.0e', 
      #           inline=True, inline_spacing=1, use_clabeltext=True)

      #ax.contour(vv, nn, 3.5e5*Uout, (0.5, 98.1), colors='r', alpha=0.5)
      c_sig_over_alpha = 2.99792458e10*3e-18 / alphaB
      c_sig_over_alpha *= (1 - absfrac)**(1./3.)
      y_IF = 0.1
      y1, y2 = 0.01, 0.99
      LHS_IF = y_IF**2 / (1 - y_IF)
      LHS1, LHS2 = y1**2/(1 - y1), y2**2/(1 - y2)
      #cs = ax.contour(vv, nn, c_sig_over_alpha*Ushout, (LHS_IF,), linewidths=2, colors='r', alpha=0.5)
      m = (c_sig_over_alpha*Ushout >= LHS1) & (c_sig_over_alpha*Ushout <= LHS2)
      tau_gas_IF = np.nanmean(tau_gas[m])
      tau_dust_IF = np.nanmean(tau_dust[m])
      cs = ax.contourf(vv, nn, tau_dust, (tau_dust[m].min(), tau_dust[m].max()), linewidths=2, colors='r', alpha=0.3)
      ax.contour(vv, nn, absfrac, 1.0, linewidths=0.7, colors='r')

      # ax.contour(vv, nn, tau, tau_dust_IF,
      #            colors='k', linestyles='--', linewidths=0.8)
      # ax.contour(vv, nn, tau_gas, tau_gas_IF,
      #            colors='y', linewidths=0.4)
      arrows = r"$\uparrow\!\!\!\!\uparrow$"
      trap_text = rf"{arrows} Trapped i-front {arrows}"
      ax.text(60, d["trapped y"][M],
              trap_text,
              ha='center', va='center',
              fontsize='xx-small', color='r', alpha=0.5, rotation=10,
              bbox=dict(fc=d["trapped bg"][M], ec='none', pad=0.1)
      )
      # ax.clabel(cs, (0.5,),
      #           manual=((60, 1e4),),
      #           fontsize='xx-small', colors='r',
      #           fmt=r'$\uparrow\uparrow$ Trapped i-front $\uparrow\uparrow$', 
      #           inline=True, inline_spacing=10, use_clabeltext=True)

      ax.contourf(vv, nn, tau, (eta, 1.0), colors='k', alpha=0.15)
      # ax.contour(vv, nn, tau, (eta/3, eta, 3*eta), colors='r')
      # ax.contour(vv, nn, tau, (1.0, 3.0), colors='m')
      cs = ax.contour(vv, nn, R0, R0s, linewidths=lws, colors='k')
      clevs = [level for level in clevs_to_label if level in cs.levels]
      ax.clabel(cs, clevs,
                fontsize='x-small', fmt=cformats,
                inline=True, inline_spacing=2, use_clabeltext=True)
      ax.text(18.0, 3e-3, Mlabel, zorder=100, fontsize='x-small', bbox=box_params)
      ax.text(18.0, d["RBW y"][M], RBW_label, rotation=15, fontsize='xx-small', bbox={**box_params, **dict(fc='0.85', ec='0.6')})
      ax.text(16.0, 1e6, RBS_label, rotation=15, fontsize='xx-small', bbox=box_params)
      ax.text(20.0, 15.0, WBS_label, rotation=15, fontsize='xx-small', bbox=box_params)


      #
      # Now do the cooling length
      #
      # Sound speed:
      cs = 11.4*np.sqrt(T0/1e4)
      # pre-shock Mach number
      M0 = vv/cs
      # post-shock Mach number
      M1 = np.sqrt((M0**2 + 3)/(5*M0**2 - 1))
      # post-shock temperature in units of T0
      T1 = (5*M0**2 - 1)*(1 + 3/M0**2) / 16
      # post-shock density
      n1 = nn*4*M0**2 / (M0**2 + 3)
      # post-shock velocity
      v1 = vv*nn/n1
      # Cooling rate
      Lam1 = 3.3e-24 * (T1*T0/1e4)**2.3
      Lam2 = 1e-20 / (T1*T0/1e4)

      k = 3
      Lambda = (Lam1**(-k) + Lam2**(-k))**(-1/k)

      # Heating rate
      Gamma = (T0/1e4)**2.8 * 3.3e-24 /np.sqrt(T1*T0/1e4)

      # Cooling length in parsec
      dcool = 3*(1e5*v1)*(1.3806503e-16 * T1*T0) / (n1*(Lambda - Gamma)) / 3.085677582e18

      dcool[vv < cs] = np.nan

      # Ratio with respect to adiabatic shell thickness
      h1 = 0.177*R0
      cool_ratio1 = dcool / R0
      # Ratio with respect to isothermal shell thickness
      h2 = 3*R0/(4*M0**2) * (2 / (1 + np.sqrt(1 + (18/M0**2)) ))
      cool_ratio2 = dcool / h2

      cs = ax.contour(vv, nn, cool_ratio1, (1.0,),
                      linewidths=2, colors='b', alpha=0.5)
      ax.clabel(cs, 
                fontsize='xx-small', fmt=r"$d_\mathrm{cool} = R_0$",
                inline=True, inline_spacing=2, use_clabeltext=True)
      cs = ax.contour(vv, nn, cool_ratio2, (1.0,),
                      linewidths=1, colors='b', alpha=0.5)
      ax.clabel(cs, 
                fontsize='xx-small', fmt=r"$d_\mathrm{cool} = h_0$",
                inline=True, inline_spacing=2, use_clabeltext=True)


      ax.set(yscale='log')

  axes[0].set(xlabel=r"$v$, km s$^{-1}$", ylabel=r"$n$, cm$^{-3}$")
  sns.despine()
  for ax in axes:
      ax.label_outer()
  fig.tight_layout()
  fig.savefig(figname)

  print(figname, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python zones-v-n-plane.py
#+END_SRC

#+RESULTS:
[[file:zones-v-n-plane.pdf]]
**** Same but for an early B supergiant
#+BEGIN_SRC python :eval no :tangle zones-v-n-plane-BSG.py 
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from vec_root import chandrupatla

  figname = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, axes = plt.subplots(1, 1, sharex=True, sharey=True, figsize=(3.3, 4))
  stardata = [
      [33.0, 30.2, 0.3079, 0.016, axes],
  ]

  # Velocities in units of km/s (10 km/s -> 100 km/s)
  vgrid = np.linspace(10.0, 100.0, 800)
  # Densities in units of 1 pcc  (0.01 -> 1e5)
  logngrid = np.linspace(-3.3, 6.3, 800)
  # 2d versions of velocity and density grids
  vv, nn = np.meshgrid(vgrid, 10**logngrid)

  def rstar(v10, n, L4):
      """Characteristic radius in pc"""
      return 2.21*np.sqrt(L4/n)/v10

  def taustar(v10, n, L4, kappa600=1.0):
      """Characteristic optical depth"""
      return 0.0089*kappa600*np.sqrt(L4*n)/v10

  def xfunc(x, ts, eta):
      """Function to be zeroed to find x"""
      return x**2 - (1.0 - np.exp(-2*ts*x)) - eta

  R0s = (0.0003, 0.001, 0.003, 0.01, 0.03,
         0.1, 0.3, 1.0, 3.0, 10.0, 30.0)
  lws = np.linspace(0.3, 2.5, len(R0s))
  cformats = { 0.0001: "0.0001 pc", 0.001: "0.001 pc", 0.01: "0.01 pc", 0.1:
               "0.1 pc", 1.0: "1 pc", 10.0: "10 pc", }
  clevs_to_label = list(cformats.keys())

  box_params = dict(fc='w', ec='0.8', lw=0.4, pad=2)
  RBW_label = r"Radiation bow wave, $\eta < \tau < 1$"
  RBS_label = r"Radiation bow shock, $\tau > 1$"
  WBS_label = r"Wind bow shock, $\tau < \eta$"

  # Miscellaneous panel-dependent plot params
  d = {
      "RBW y": {33.0: 1500.0, 20.0: 5000.0, 40.0: 2500.0},
      "trapped y": {33.0: 250, 20.0: 2.5e5, 40.0: 1.5e5},
      "trapped bg": {33.0: 'w', 20.0: 'w', 40.0: 'w'},
      "IF tau": {33.0: 0.2, 20.0: 3.7, 40.0: 6.4},
      "IF tau gas": {33.0: 5.0, 20.0: 5.0, 40.0: 5.0},
  }

  T0 = 8000
  kappa = 600.0
  for M, L4, eta, S49, ax in stardata:
      Mlabel = "\n".join([
          "B supergiant", "",
          rf"$M = {M:.0f}\, M_\odot$",
          rf"$L = {1e4*L4:.1e}\, L_\odot$".replace("e+0", r"\times 10^"),
          rf"$\eta = {eta}$"])
      Rs = rstar(vv/10, nn, L4)
      ts = taustar(vv/10, nn, L4, kappa600=kappa/600.0)
      a, b = 0.0, 2*np.sqrt(1.0 + eta)
      x = chandrupatla(xfunc, a, b, args=(ts, eta))
      R0 = x*Rs
      tau = 2*x*ts

      # Ionization parameter - fiducial
      U = 2.789*S49 / (R0**2 * nn)
      # Shell ionization parameter - assume compression by M^2
      Ush = U/(vv/10)**2
      # Ionization fraction in shell
      ysh = 1.0 - 1.0/(3.5e5*Ush)

      # cs = ax.contour(vv, nn, ysh,
      #                 (0.9, 0.99, 0.999, 0.9999, 0.99999),
      #                 linewidths=1.0,
      #                 colors='g', alpha=0.5)
      # ax.clabel(cs,
      #           fontsize=5, colors='g', fmt='$%.5f$', 
      #           inline=True, inline_spacing=1, use_clabeltext=True)
      # ax.text(75, 6e-3, fr"$y_\mathrm{{in}} = {ysh.max():.5f}$",
      #         fontsize=5, color='g', alpha=0.5)
      # ax.text(12, 1.3e6, fr"$y_\mathrm{{in}} = {ysh.min():.5f}$",
      #         fontsize=5, color='g', alpha=0.5)

      # Fraction of ionizing photons absorbed in shell
      alphaB = 2.6e-13*(T0/1e4)**(-0.7)
      absfrac0 = 3*np.pi*(3.085677582e18)**3 * alphaB / 1e49
      absfrac = absfrac0 * (vv/10)**2 * nn**2 * R0**3 / S49
      # Advection contribution
      advecfrac = 4*np.pi*(3.085677582e18*R0)**2 *nn*vv*1e5 / (1e49*S49) 
      # Equivalent optical depth
      tau_gas = -np.log(1.0 - absfrac)
      #absfrac = 2.76e-4 * (vv/10)**-1 * nn**0.5 * (L4)**1.5 / S49

      tau_dust = (3/8)*tau
      # Ionization parameter just outside the shell
      Uout = U*np.exp(-(tau_dust + tau_gas))
      Uout[~np.isfinite(Uout)] = 0.0
      Ushout = Uout/(vv/10)**2

      # y^2 / (1 - y) = CU
      # y = 0.1 => y^2 / (1 - y) = 0.0111111111111
      # y = 0.5 => y^2 / (1 - y) = 0.5
      # y = 0.9 => y^2 / (1 - y) = 8.1
      # y = 0.99 => y^2 / (1 - y) = 98.1

      # cu = 3.5e5*Uout

      # y_out = 0.5*cu * (np.sqrt(1.0 + 4/cu) - 1.0)
      # cs = ax.contour(vv, nn, Uout,
      #                 np.logspace(-7.0, 1.0, 9),
      #                 linewidths=np.linspace(0.2, 1.5, 9),
      #                 colors='r', alpha=0.5)
      # ax.clabel(cs,x
      #           fontsize='xx-small', colors='r', fmt='%.0e', 
      #           inline=True, inline_spacing=1, use_clabeltext=True)

      #ax.contour(vv, nn, 3.5e5*Uout, (0.5, 98.1), colors='r', alpha=0.5)
      c_sig_over_alpha = 2.99792458e10*3e-18 / alphaB
      c_sig_over_alpha *= (1 - absfrac)**(1./3.)
      y_IF = 0.1
      y1, y2 = 0.01, 0.99
      LHS_IF = y_IF**2 / (1 - y_IF)
      LHS1, LHS2 = y1**2/(1 - y1), y2**2/(1 - y2)
      #cs = ax.contour(vv, nn, c_sig_over_alpha*Ushout, (LHS_IF,), linewidths=2, colors='r', alpha=0.5)
      m = (c_sig_over_alpha*Ushout >= LHS1) & (c_sig_over_alpha*Ushout <= LHS2)
      tau_gas_IF = np.nanmean(tau_gas[m])
      tau_dust_IF = np.nanmean(tau_dust[m])
      cs = ax.contourf(vv, nn, tau_dust, (tau_dust[m].min(), tau_dust[m].max()), linewidths=2, colors='r', alpha=0.3)
      ax.contour(vv, nn, absfrac+advecfrac, 1.0, linewidths=0.7, colors='r')

      # ax.contour(vv, nn, tau, tau_dust_IF,
      #            colors='k', linestyles='--', linewidths=0.8)
      # ax.contour(vv, nn, tau_gas, tau_gas_IF,
      #            colors='y', linewidths=0.4)
      arrows = r"$\uparrow\!\!\!\!\uparrow$"
      # trap_text = rf"{arrows} Trapped i-front, $\tau_\mathrm{{d}} = {tau_dust_IF:.1f}$, $\tau_\mathrm{{gas}} = {tau_gas_IF:.1f}$ {arrows}"
      trap_text = rf"{arrows} Trapped i-front {arrows}"
      ax.text(60, d["trapped y"][M],
              trap_text,
              ha='center', va='center',
              fontsize='xx-small', color='r', alpha=0.5, rotation=10,
              bbox=dict(fc=d["trapped bg"][M], ec='none', pad=0.1)
      )
      # ax.clabel(cs, (0.5,),
      #           manual=((60, 1e4),),
      #           fontsize='xx-small', colors='r',
      #           fmt=r'$\uparrow\uparrow$ Trapped i-front $\uparrow\uparrow$', 
      #           inline=True, inline_spacing=10, use_clabeltext=True)

      ax.contourf(vv, nn, tau, (eta, 1.0), colors='k', alpha=0.15)
      # ax.contour(vv, nn, tau, (eta/3, eta, 3*eta), colors='r')
      # ax.contour(vv, nn, tau, (1.0, 3.0), colors='m')
      cs = ax.contour(vv, nn, R0, R0s, linewidths=lws, colors='k')
      clevs = [level for level in clevs_to_label if level in cs.levels]
      ax.clabel(cs, clevs,
                fontsize='x-small', fmt=cformats,
                inline=True, inline_spacing=2, use_clabeltext=True)
      ax.text(62.0, 1e-2, Mlabel, zorder=100, fontsize='x-small', bbox=box_params)
      ax.text(18.0, d["RBW y"][M], RBW_label, rotation=15, fontsize='xx-small', bbox={**box_params, **dict(fc='0.85', ec='0.6')})
      ax.text(16.0, 1e6, RBS_label, rotation=15, fontsize='xx-small', bbox=box_params)
      ax.text(20.0, 15.0, WBS_label, rotation=15, fontsize='xx-small', bbox=box_params)


      #
      # Now do the cooling length
      #
      # Sound speed:
      cs = 11.4*np.sqrt(T0/1e4)
      # pre-shock Mach number
      M0 = vv/cs
      # post-shock Mach number
      M1 = np.sqrt((M0**2 + 3)/(5*M0**2 - 1))
      # post-shock temperature in units of T0
      T1 = (5*M0**2 - 1)*(1 + 3/M0**2) / 16
      # post-shock density
      n1 = nn*4*M0**2 / (M0**2 + 3)
      # post-shock velocity
      v1 = vv*nn/n1
      # Cooling rate
      Lam1 = 3.3e-24 * (T1*T0/1e4)**2.3
      Lam2 = 1e-20 / (T1*T0/1e4)

      k = 3
      Lambda = (Lam1**(-k) + Lam2**(-k))**(-1/k)

      # Heating rate
      Gamma = (T0/1e4)**2.8 * 3.3e-24 /np.sqrt(T1*T0/1e4)

      # Cooling length in parsec
      dcool = 3*(1e5*v1)*(1.3806503e-16 * T1*T0) / (n1*(Lambda - Gamma)) / 3.085677582e18

      dcool[vv < cs] = np.nan

      # Ratio with respect to adiabatic shell thickness
      h1 = 0.177*R0
      cool_ratio1 = dcool / R0
      # Ratio with respect to isothermal shell thickness
      h2 = 3*R0/(4*M0**2) * (2 / (1 + np.sqrt(1 + (18/M0**2)) ))
      cool_ratio2 = dcool / h2

      cs = ax.contour(vv, nn, cool_ratio1, (1.0,),
                      linewidths=2, colors='b', alpha=0.5)
      ax.clabel(cs, 
                fontsize='xx-small', fmt=r"$d_\mathrm{cool} = R_0$",
                inline=True, inline_spacing=2, use_clabeltext=True)
      cs = ax.contour(vv, nn, cool_ratio2, (1.0,),
                      linewidths=1, colors='b', alpha=0.5)
      ax.clabel(cs, 
                fontsize='xx-small', fmt=r"$d_\mathrm{cool} = h_0$",
                inline=True, inline_spacing=2, use_clabeltext=True)


      ax.set(yscale='log')

  axes.set(xlabel=r"$v$, km s$^{-1}$", ylabel=r"$n$, cm$^{-3}$")
  sns.despine()
  fig.tight_layout()
  fig.savefig(figname)

  print(figname, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python zones-v-n-plane-BSG.py
#+END_SRC

#+RESULTS:
[[file:zones-v-n-plane-BSG.pdf]]
**** Same but for a red supergiant
#+BEGIN_SRC python :eval no :tangle zones-v-n-plane-RSG.py 
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from vec_root import chandrupatla

  figname = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, axes = plt.subplots(1, 1, sharex=True, sharey=True, figsize=(3.3, 4))
  stardata = [
      [20.0, 15.6, 0.0476, 0.0, axes],
  ]

  # Velocities in units of km/s (10 km/s -> 100 km/s)
  vgrid = np.linspace(10.0, 100.0, 800)
  # Densities in units of 1 pcc  (0.01 -> 1e5)
  logngrid = np.linspace(-3.3, 6.3, 800)
  # 2d versions of velocity and density grids
  vv, nn = np.meshgrid(vgrid, 10**logngrid)

  def rstar(v10, n, L4):
      """Characteristic radius in pc"""
      return 2.21*np.sqrt(L4/n)/v10

  def taustar(v10, n, L4, kappa600=1.0):
      """Characteristic optical depth"""
      return 0.0089*kappa600*np.sqrt(L4*n)/v10

  def xfunc(x, ts, eta):
      """Function to be zeroed to find x"""
      return x**2 - (1.0 - np.exp(-2*ts*x)) - eta

  R0s = (0.0003, 0.001, 0.003, 0.01, 0.03,
         0.1, 0.3, 1.0, 3.0, 10.0, 30.0)
  lws = np.linspace(0.3, 2.5, len(R0s))
  cformats = { 0.0001: "0.0001 pc", 0.001: "0.001 pc", 0.01: "0.01 pc", 0.1:
               "0.1 pc", 1.0: "1 pc", 10.0: "10 pc", }
  clevs_to_label = list(cformats.keys())

  box_params = dict(fc='w', ec='0.8', lw=0.4, pad=2)
  RBW_label = r"Radiation bow wave, $\eta < \tau < 1$"
  RBS_label = r"Radiation bow shock, $\tau > 1$"
  WBS_label = r"Wind bow shock, $\tau < \eta$"

  # Miscellaneous panel-dependent plot params
  d = {
      "RBW y": {33.0: 1500.0, 20.0: 1e5, 40.0: 2500.0},
      "trapped y": {33.0: 250, 20.0: 2.5e5, 40.0: 1.5e5},
      "trapped bg": {33.0: 'w', 20.0: 'w', 40.0: 'w'},
      "IF tau": {33.0: 0.2, 20.0: 3.7, 40.0: 6.4},
      "IF tau gas": {33.0: 5.0, 20.0: 5.0, 40.0: 5.0},
  }

  T0 = 1000
  kappa = 60.0
  for M, L4, eta, S49, ax in stardata:
      Mlabel = "\n".join([
          "M supergiant", "",
          rf"$M = {M:.0f}\, M_\odot$",
          rf"$L = {1e4*L4:.1e}\, L_\odot$".replace("e+0", r"\times 10^"),
          rf"$\eta = {eta}$"])
      Rs = rstar(vv/10, nn, L4)
      ts = taustar(vv/10, nn, L4, kappa600=kappa/600.0)
      a, b = 0.0, 2*np.sqrt(1.0 + eta)
      x = chandrupatla(xfunc, a, b, args=(ts, eta))
      R0 = x*Rs
      tau = 2*x*ts


      ax.contourf(vv, nn, tau, (eta, 1.0), colors='k', alpha=0.15)
      # ax.contour(vv, nn, tau, (eta/3, eta, 3*eta), colors='r')
      # ax.contour(vv, nn, tau, (1.0, 3.0), colors='m')
      cs = ax.contour(vv, nn, R0, R0s, linewidths=lws, colors='k')
      clevs = [level for level in clevs_to_label if level in cs.levels]
      ax.clabel(cs, clevs,
                fontsize='x-small', fmt=cformats,
                inline=True, inline_spacing=2, use_clabeltext=True)
      ax.text(62.0, 1e-2, Mlabel, zorder=100, fontsize='x-small', bbox=box_params)
      ax.text(18.0, d["RBW y"][M], RBW_label, rotation=15, fontsize='xx-small', bbox={**box_params, **dict(fc='0.85', ec='0.6')})
      ax.text(16.0, 2e6, RBS_label, rotation=15, fontsize='xx-small', bbox=box_params)
      ax.text(20.0, 300.0, WBS_label, rotation=15, fontsize='xx-small', bbox=box_params)


      #
      # Now do the cooling length
      #
      # Sound speed:
      cs = 11.4*np.sqrt(T0/1e4)
      # pre-shock Mach number
      M0 = vv/cs
      # post-shock Mach number
      M1 = np.sqrt((M0**2 + 3)/(5*M0**2 - 1))
      # post-shock temperature in units of T0
      T1 = (5*M0**2 - 1)*(1 + 3/M0**2) / 16
      # post-shock density
      n1 = nn*4*M0**2 / (M0**2 + 3)
      # post-shock velocity
      v1 = vv*nn/n1
      # Cooling rate
      Lam1 = 3.3e-24 * (T1*T0/1e4)**2.3
      Lam2 = 1e-20 / (T1*T0/1e4)

      k = 3
      Lambda = (Lam1**(-k) + Lam2**(-k))**(-1/k)

      # Heating rate
      Gamma = 1e-26

      # Cooling length in parsec
      dcool = 3*(1e5*v1)*(1.3806503e-16 * T1*T0) / (n1*(Lambda - Gamma)) / 3.085677582e18

      dcool[vv < cs] = np.nan

      # Ratio with respect to adiabatic shell thickness
      h1 = 0.177*R0
      cool_ratio1 = dcool / R0
      # Ratio with respect to isothermal shell thickness
      h2 = 3*R0/(4*M0**2) * (2 / (1 + np.sqrt(1 + (18/M0**2)) ))
      cool_ratio2 = dcool / h2

      cs = ax.contour(vv, nn, cool_ratio1, (1.0,),
                      linewidths=2, colors='b', alpha=0.5)
      ax.clabel(cs, 
                fontsize='xx-small', fmt=r"$d_\mathrm{cool} = R_0$",
                inline=True, inline_spacing=2, use_clabeltext=True)
      cs = ax.contour(vv, nn, cool_ratio2, (1.0,),
                      linewidths=1, colors='b', alpha=0.5)
      ax.clabel(cs, 
                fontsize='xx-small', fmt=r"$d_\mathrm{cool} = h_0$",
                inline=True, inline_spacing=2, use_clabeltext=True)


      ax.set(yscale='log')

  axes.set(xlabel=r"$v$, km s$^{-1}$", ylabel=r"$n$, cm$^{-3}$")
  sns.despine()
  fig.tight_layout()
  fig.savefig(figname)

  print(figname, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python zones-v-n-plane-RSG.py
#+END_SRC

#+RESULTS:
[[file:zones-v-n-plane-RSG.pdf]]

*** Consider radiative decoupling
+ This is the same, but we are going to look at the case where the gas and dust separate
+ Considering drag-free dust, 
  + we have pure radiative turnaround radius:
    \[
    R_{**} = \frac{\sigma Q_{p}}{m} \frac{L}{2\pi c v^{2}}
    \]
    + (earlier I was using R_0, but that is too confusing)
  + If \(Z_{d}\) is the dust-gas mass ratio, then \(\sigma Q_{p} / m = \kappa / Z_{d}\)
    + Alternatively, we can find it from
      + \(\sigma / m = 3 / 4 a_{d} \rho_{d}\) for solid spherical spheres of radius a_d and bulk density \rho_d \approx 3 g/cm^3
      + \(Q_{p} \approx 2 a_{d} / \lambda\) for \(\lambda \ge a_{d}\)
    + Taking \lambda = 1000 \AA this gives 5e4 cm^2/g, which corresponds to \(Z_d = 0.012\)
  + This is same as \(x_{**} \equiv R_{**} / R_{*} = 2 \tau_{*} / Z_{d}\) 
+ To start with, we will plot \(R_{**}\)
  + and also the pure WBS case of \(R_{wbs} = \eta^{1/2} R_*\), since that is what the gas will do if the dust decouples
+ When drag is added, then the dust-wave radius becomes \(R_{dw} = R_{**} / (1 + \alpha)\)
  + where \(\alpha = 2 \tau_{*} / \xi^{1/2} Z_{d}\)
+ Then we get the gas deceleration as it goes through through the dust wave
  + \(\Delta v / v = \frac12 (1 + \alpha) Z_{d}\) where we may or may not want that 1/2 factor
  + So the inner bow shock radius grows since it is confined by a slower stream: \(R_{ibs} = \eta^{1/2} R_{*} / (1 - \Delta v/v)\)
#+BEGIN_SRC python :eval no :tangle decouple-v-n-plane.py 
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from vec_root import chandrupatla

  figname = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, ax = plt.subplots(1, 1, figsize=(3, 4))
  stardata = [
      [10.0, 0.63, 0.0066, ax],
  ]

  # Velocities in units of km/s (10 km/s -> 100 km/s)
  vgrid = np.linspace(10.0, 100.0, 600)
  # Densities in units of 1 pcc  (0.01 -> 1e5)
  logngrid = np.linspace(-3.3, 6.3, 600)
  # 2d versions of velocity and density grids
  vv, nn = np.meshgrid(vgrid, 10**logngrid)

  def rstar(v10, n, L4, c10=0.0):
      """Characteristic radius in pc"""
      return 2.21*np.sqrt(L4/(n*(v10**2 + c10**2)))

  def taustar(v10, n, L4, kappa600=1.0):
      """Characteristic optical depth"""
      return 0.0089*kappa600*np.sqrt(L4*n)/v10

  def xfunc(x, ts, eta):
      """Function to be zeroed to find x"""
      return x**2 - (1.0 - np.exp(-2*ts*x)) - eta

  R0s = (0.0003, 0.001, 0.003, 0.01, 0.03,
         0.1, 0.3, 1.0, 3.0, 10.0, 30.0)
  lws = np.linspace(0.3, 2.5, len(R0s))
  cformats = { 0.0001: "0.0001 pc", 0.001: "0.001 pc", 0.01: "0.01 pc", 0.1:
               "0.1 pc", 1.0: "1 pc", 10.0: "10 pc", }
  clevs_to_label = list(cformats.keys())

  box_params = dict(fc='w', ec='0.8', lw=0.4, pad=2)
  RBW_label = r"Radiation bow wave, $\eta < \tau < 1$"
  RBS_label = r"Radiation bow shock, $\tau > 1$"
  WBS_label = r"Wind bow shock, $\tau < \eta$"

  # Dust-gas mass ratio
  Zd = 0.01
  kappa = 600.0
  # Decoupling efficiency: 2 Q_p / Q_drag
  xi = 0.07

  for M, L4, eta, ax in stardata:
      Mlabel = "\n".join([rf"$M = {M:.0f}\, M_\odot$",
                          rf"$L = {1e4*L4:.1e}\, L_\odot$".replace("e+0", r"\times 10^"),
                          rf"$\eta = {eta}$"])
      Rs = rstar(vv/10, nn, L4)
      ts = taustar(vv/10, nn, L4, kappa600=kappa/600.0)
      a, b = 0.0, 2*np.sqrt(1.0 + eta)
      x = chandrupatla(xfunc, a, b, args=(ts, eta))
      R0 = x*Rs
      tau = 2*x*ts

      # Radiative turnaround radius (no drag)
      Rstarstar = 2*ts*Rs / Zd
      # Drag coefficient
      alpha = (2.0/xi**0.5) * ts / Zd

      # Dust wave radius
      Rdw = Rstarstar / (1.0 + alpha)
      # Rdw = xi**0.5 * Rs

      # Pure wind bow shock radius
      Rwbs = eta**0.5 * Rs

      # Gas deceleration through dust wave Delta v/v
      dv_v = 0.75*(1.0 + alpha)*Zd
      # Inner bow shock radius inside a dust wave
      Ribs = eta**0.5 * rstar((1.0 - dv_v)*vv/10, nn, L4)
      # Don't let it be bigger than dust wave
      m = Ribs > Rdw
      Ribs[m] = Rdw[m]

      # Remove cases where dust wave will not exist
      m = Rdw < R0
      Rdw[m] = np.nan 
      Ribs[m] = np.nan 

      # Choose only the R0 where there is not also a dust wave
      R0[~m] = np.nan

      ax.contourf(vv, nn, tau, (eta, 1.0), colors='k', alpha=0.2)
      ax.contourf(vv, nn, (~m)*np.ones_like(m).astype(float), (0.5, 1.5), colors='c', alpha=0.2)
      if np.any(~m):
          alpha[m] = np.nan
          #ax.contourf(vv, nn, alpha, (0.5, 2.0), colors='m', alpha=0.2)
          cs = ax.contour(vv, nn, alpha, (0.5, 1.0, 2.0, 20.0, 80.0),
                          linewidths=0.3,
                          colors='m', alpha=0.5)
          ax.clabel(cs,
                    fontsize='xx-small', fmt=r"$\alpha = %.2f$",
                    inline=True, inline_spacing=2, use_clabeltext=True)
      # ax.contour(vv, nn, tau, (eta/3, eta, 3*eta), colors='r')
      # ax.contour(vv, nn, tau, (1.0, 3.0), colors='m')
      cs = ax.contour(vv, nn, R0, R0s, linewidths=lws, colors='k')
      clevs = [level for level in clevs_to_label if level in cs.levels]
      ax.clabel(cs, (0.001, 0.01, 0.1, 1.0),
                manual=((25, 5e5), (15, 3e3), (85, 1.2e-2), (20, 2e-3)),
                fontsize='xx-small', fmt=cformats,
                inline=True, inline_spacing=8, use_clabeltext=False)


      # cs = ax.contour(vv, nn, Rstarstar, R0s, linewidths=lws, colors='m', alpha=0.5)
      # clevs = [level for level in clevs_to_label if level in cs.levels]
      # ax.clabel(cs, clevs,
      #           fontsize='small', fmt=cformats,
      #           inline=True, inline_spacing=2, use_clabeltext=True, alpha=0.5, colors='m')
      cs = ax.contour(vv, nn, Rdw, R0s, linewidths=lws, linestyles='dashed', colors='y')
      clevs = [level for level in clevs_to_label if level in cs.levels]
      ax.clabel(cs, (0.001, 0.01, 0.1),
                fontsize='xx-small', fmt=cformats, colors='y',
                inline=True, inline_spacing=0.2, use_clabeltext=True)
      cs = ax.contour(vv, nn, Ribs, R0s, linewidths=lws, colors='k', alpha=0.5)
      ax.clabel(cs, (0.001, 0.01),
                manual=((73, 2e2), (82, 2e0)),
                fontsize='xx-small', fmt=cformats, alpha=0.5, 
                inline=True, inline_spacing=8, use_clabeltext=False)

      ax.text(30.0, 1.5e-3, Mlabel, fontsize='small', bbox=box_params)
      # ax.text(18.0, 4000.0, RBW_label, rotation=15, fontsize='small', bbox={**box_params, **dict(fc='0.8', ec='0.6')})
      # ax.text(18.0, 2e6, RBS_label, rotation=15, fontsize='small', bbox=box_params)
      # ax.text(18.0, 30.0, WBS_label, rotation=15, fontsize='small', bbox=box_params)



      ax.set(yscale='log')

  ax.set(xlabel=r"$v$, km s$^{-1}$", ylabel=r"$n$, cm$^{-3}$")
  sns.despine()
  fig.tight_layout()
  fig.savefig(figname)

  print(figname, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python decouple-v-n-plane.py
#+END_SRC

#+RESULTS:
[[file:decouple-v-n-plane.pdf]]



**** Radii versus density for fixed velocity

+ [-] [2017-12-28 Thu] Add in the inner dust wave
  + This is when the dust sails through the hydro bow shock, but then gets stopped by the radiation at a smaller radius 
  + [X] Do just by extending the dust wave curve
  + [ ] More realistic: decoupling occurs at hydro BS, and dust is given an impulse by gas-drag there. This modifies velocity used to find R_{**}
  + [ ] Even more realistic: take into account Lorentz force at decoupling also

#+BEGIN_SRC python :eval no :tangle decouple-v40-versus-n.py 
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from vec_root import chandrupatla

  figname = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, ax = plt.subplots(1, 1, sharex=True, sharey=True, figsize=(4, 3.5))

  # Velocities in units of km/s (10 km/s -> 100 km/s)
  vv = 40.0
  # Densities in units of 1 pcc  (0.01 -> 1e5)
  logngrid = np.linspace(-4.3, 7.3, 600)
  nn = 10**logngrid

  def rstar(v10, n, L4, c10=0.0):
      """Characteristic radius in pc"""
      return 2.21*np.sqrt(L4/(n*(v10**2 + c10**2)))

  def taustar(v10, n, L4, kappa600=1.0):
      """Characteristic optical depth"""
      return 0.0089*kappa600*np.sqrt(L4*n)/v10

  def xfunc(x, ts, eta):
      """Function to be zeroed to find x"""
      return x**2 - (1.0 - np.exp(-2*ts*x)) - eta

  R0s = (0.0003, 0.001, 0.003, 0.01, 0.03,
         0.1, 0.3, 1.0, 3.0, 10.0, 30.0)
  lws = np.linspace(0.3, 2.5, len(R0s))
  cformats = { 0.0001: "0.0001 pc", 0.001: "0.001 pc", 0.01: "0.01 pc", 0.1:
               "0.1 pc", 1.0: "1 pc", 10.0: "10 pc", }
  clevs_to_label = list(cformats.keys())

  box_params = dict(fc='w', ec='0.8', lw=0.4, pad=2)
  RBW_label = r"Radiation bow wave, $\eta < \tau < 1$"
  RBS_label = r"Radiation bow shock, $\tau > 1$"
  WBS_label = r"Wind bow shock, $\tau < \eta$"

  # Dust-gas mass ratio
  Zd = 0.01
  kappa = 600.0
  # Decoupling efficiency: 2 Q_p / Q_drag
  xi = 0.07

  M, L4, eta = 10.0, 0.63, 0.0066

  Mlabel = "\n".join([rf"$M = {M:.0f}\, M_\odot$   $\eta = {eta}$",
                      rf"$L = {1e4*L4:.1e}\, L_\odot$".replace("e+0", r"\times 10^")])
  Rs = rstar(vv/10, nn, L4)
  ts = taustar(vv/10, nn, L4, kappa600=kappa/600.0)
  a, b = 0.0, 2*np.sqrt(1.0 + eta)
  x = chandrupatla(xfunc, a, b, args=(ts, eta))
  R0 = x*Rs
  tau = 2*x*ts

  # Radiative turnaround radius (no drag)
  Rstarstar = 2*ts*Rs / Zd
  # Drag coefficient
  alpha = (2.0/xi**0.5) * ts / Zd

  # Dust wave radius
  Rdw = Rstarstar / (1.0 + alpha)
  # Rdw = xi**0.5 * Rs

  # Pure wind bow shock radius
  Rwbs = eta**0.5 * Rs

  # Gas deceleration through dust wave Delta v/v
  dv_v = 0.82*(1.0 + alpha)*Zd
  # Inner bow shock radius inside a dust wave
  Ribs = eta**0.5 * rstar((1.0 - dv_v)*vv/10, nn, L4)
  # Don't let it be bigger than dust wave
  m = Ribs > Rdw
  Ribs[m] = Rdw[m]

  # Make a copy for the inner dust wave
  Ridw = Rdw.copy()

  # Remove cases where dust wave is inside the bow shock
  m = Rdw < R0
  Rdw[m] = np.nan 
  Ribs[m] = np.nan 
  # Trim unphysical zones for inner dust wave
  Ridw[~m] = np.nan
  Ridw[nn > 10.0] = np.nan

  # Choose only the R0 where there is not also a dust wave
  ax.plot(nn[~m], R0[~m], color="k", lw=0.1)
  R0[~m] = np.nan

  m = tau <= eta
  ax.plot(nn[m], R0[m], label="Wind bow shock")
  ax.plot(nn, Rdw, ls="--", label="Dust wave")
  ax.plot(nn, Ribs, ls=":", label="Dust-free bow shock")
  m = (tau > eta) & (tau < 1.0)
  ax.plot(nn[m], R0[m], ls="-.", label="Bow wave")
  m = tau >= 1.0
  ax.plot(nn[m], R0[m], label="Radiation bow shock")

  # Go back and plot the internal dust wave
  ax.plot(nn, Ridw, ls="--", c="orange", lw=0.5, label="_nolabel_")

  m = nn < 10.0
  ax.plot(nn[m], Rstarstar[m], color='k', lw=0.1)
  ax.plot(nn[~m], Rstarstar[~m]*Zd, color='k', lw=0.1)
  # ax.contourf(vv, nn, tau, (eta, 1.0), colors='k', alpha=0.2)
  # ax.contourf(vv, nn, (~m)*np.ones_like(m).astype(float), (0.5, 1.5), colors='c', alpha=0.2)
  # if np.any(~m):
  #     alpha[m] = np.nan
  #     cs = ax.contour(vv, nn, alpha, (0.25, 0.5, 1.0, 2.0, 4.0, 20.0, 50.0),
  #                     linewidths=0.3,
  #                     colors='m', alpha=0.5)
  #     ax.clabel(cs,
  #               fontsize='x-small', fmt=r"$\alpha = %.2f$",
  #               inline=True, inline_spacing=0.2, use_clabeltext=True)
  # cs = ax.contour(vv, nn, R0, R0s, linewidths=lws, colors='k')
  # clevs = [level for level in clevs_to_label if level in cs.levels]
  # ax.clabel(cs, clevs,
  #           fontsize='xx-small', fmt=cformats,
  #           inline=True, inline_spacing=0.2, use_clabeltext=True)


  # cs = ax.contour(vv, nn, Rdw, R0s, linewidths=lws, linestyles='dashed', colors='y')
  # clevs = [level for level in clevs_to_label if level in cs.levels]
  # ax.clabel(cs, clevs,
  #           fontsize='xx-small', fmt=cformats, colors='y',
  #           inline=True, inline_spacing=0.2, use_clabeltext=True)
  # cs = ax.contour(vv, nn, Ribs, R0s, linewidths=lws, colors='k', alpha=0.5)
  # clevs = [level for level in clevs_to_label if level in cs.levels]
  # ax.clabel(cs, clevs,
  #           fontsize='xx-small', fmt=cformats, alpha=0.5, 
  #           inline=True, inline_spacing=0.2, use_clabeltext=True)

  ax.text(3e-5, 9e-5, "Stellar parameters:\n" + Mlabel,
          linespacing=1.5, fontsize='small', bbox=box_params)
  ax.text(1e6, 9e-3, "Relative speed:\n$v = 40$ km/s", ha="right",
          linespacing=1.5, fontsize='small', bbox=box_params)
  ax.text(5.0, 0.15, "$R_{_{**}}$",
          fontsize='small', ha="center", va="center", bbox=box_params)
  ax.text(1e6, 0.15/100, "$Z_\mathrm{d}\,R_{_{**}} $",
          fontsize='small', ha="center", va="center", bbox=box_params)

  ax.text(3e-5, 1.2e-3,
          "Dust parameters:\n" + f"$Z_\mathrm{{d}} = {Zd}$"
          + fr"     $\xi = {xi}$" + "\n"
          + f"$\kappa_\mathrm{{d}} = {kappa}$ cm$^2$/g",
          linespacing=1.5, fontsize='small', bbox=box_params)


  leg = ax.legend(loc="upper right", frameon=True, fontsize="small")

  ax.set(xscale='log', yscale='log')

  ax.set(
      ylabel=r"Bow radius: $R$, pc",
      xlabel=r"Ambient density: $n$, cm$^{-3}$",
      #ylim=[1.5e-4, 3.0],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figname)

  print(figname, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python decouple-v40-versus-n.py
#+END_SRC

#+RESULTS:
[[file:decouple-v40-versus-n.pdf]]



** Gas dynamic equations for bow waves
+ we get \(x = (1 - y^{2} + M_{\infty}^{-2} \ln y^{2})^{-1}\)
+ Table for \(M_{\infty} = 4\)
  |      y | x (hyper) | x(v=20) | x(v=40) | x(v=100) |
  |--------+-----------+---------+---------+----------|
  |  0.999 |    500.25 |  667.22 |  533.64 |   505.31 |
  |   0.99 |     50.25 |   67.23 |   53.64 |    50.76 |
  |    0.9 |      5.26 |    7.28 |    5.66 |     5.32 |
  |    0.8 |      2.78 |    4.03 |    3.01 |     2.81 |
  |    0.7 |      1.96 |    3.02 |    2.15 |     1.99 |
  |    0.6 |      1.56 |    2.60 |    1.74 |     1.59 |
  |    0.5 |      1.33 |    2.48 |    1.51 |     1.36 |
  |    0.4 |      1.19 |    2.62 |    1.38 |     1.22 |
  |    0.3 |      1.10 |    3.25 |    1.32 |     1.13 |
  |   0.25 |      1.07 |    4.09 |    1.31 |     1.10 |
  |    0.2 |      1.04 |    6.44 |    1.32 |     1.08 |
  |    0.1 |      1.01 |   -6.20 |    1.42 |     1.06 |
  |   0.01 |      1.00 |   -0.77 |    2.36 |     1.10 |
  |  0.003 |      1.00 |   -0.53 |    3.65 |     1.13 |
  |  0.001 |      1.00 |   -0.41 |    7.32 |     1.16 |
  | 0.0005 |      1.00 |   -0.36 |   20.05 |     1.18 |
  #+TBLFM: $2=1/(1 - $1**2);f2::$3=1/(1 - $1**2 + (1/2**2) ln($1**2));f2::$4=1/(1 - $1**2 + (1/4**2) ln($1**2));f2::$5=1/(1 - $1**2 + (1/10**2) ln($1**2));f2
+ Same but just for the y^2 - (1/M^2) ln y^2 factor
  |      y | Fac(v=20) | Fac(v=40) | Fac(v=100) |
  |--------+-----------+-----------+------------|
  |  0.999 |      1.00 |      1.00 |       1.00 |
  |   0.99 |      0.99 |      0.98 |       0.98 |
  |    0.9 |      0.86 |      0.82 |       0.81 |
  |    0.8 |      0.75 |      0.67 |       0.64 |
  |    0.7 |      0.67 |      0.53 |       0.50 |
  |    0.6 |      0.62 |      0.42 |       0.37 |
  |    0.5 |      0.60 |      0.34 |       0.26 |
  |    0.4 |      0.62 |      0.27 |       0.18 |
  |    0.3 |      0.69 |      0.24 |       0.11 |
  |   0.25 |      0.76 |      0.24 |       0.09 |
  |    0.2 |      0.84 |      0.24 |       0.07 |
  |    0.1 |      1.16 |      0.30 |       0.06 |
  |   0.01 |      2.30 |      0.58 |       0.09 |
  |  0.003 |      2.90 |      0.73 |       0.12 |
  |  0.001 |      3.45 |      0.86 |       0.14 |
  | 0.0005 |      3.80 |      0.95 |       0.15 |
  #+TBLFM: $2=$1**2 - (1/2**2) ln($1**2);f2::$3=$1**2 - (1/4**2) ln($1**2);f2::$4=$1**2 - (1/10**2) ln($1**2);f2


** Eddington ratio for our stars
+ If L/M is low enough, then we would need to take into account the
  gravity as well as the radiation pressure force
  + a_g = - G M / r^2
  + a_r = \kappa L / 4 \pi c r^2
+ Eddington luminosity:
  + \kappa L / 4 \pi c = G M
  + (L / M)_solar.units = 4 \pi c G M_\odot / \kappa L_\odot
    = 4 pi 2.99792458e10 6.673e-8 1.989e33 / 600 3.82e33
    = 21.82 \kappa_600^-1
+ Eddington ratio:
  + \Gamma_dust = 0.04584 \kappa_600 (L / M) 
    |     |  M |      L | \kappa_600 |  \Gamma_dust | (1 - \Gamma^-1) |
    |-----+----+--------+------+--------+-----------|
    | MS  | 10 | 0.63e4 |    1 |  28.88 |     0.965 |
    | MS  | 20 | 5.45e4 |    1 | 124.91 |     0.992 |
    | MS  | 40 | 22.2e4 |    1 | 254.41 |     0.996 |
    | BSG | 33 | 30.2e4 |    1 | 419.51 |     0.998 |
    | RSG | 20 | 15.5e4 |  0.1 |  35.53 |     0.972 |
    #+TBLFM: $5=0.04584 $4 $3 / $2 ;f2::$6=(1 - 1/$-1);f3
+ So we can correct for gravity by multiplying luminosity by
  + (\Gamma - 1) / \Gamma = (1 - \Gamma^-1)
+ Gravity will be important in outer parts of bow shell if
  + \Gamma e^-\tau < 1
  + => \tau > ln \Gamma
** Checking the stellar wind parameters
+ First try the equation from Vink (2000)
+ Mdot column is log10 and from Vink's eq (12)
+ V_esc is calculated from
  + L = 4 pi R^2 sigma T^4
    + R = (L / 4 pi sigma)^{1/2} / T^2
  + 0.5 v^2 = G M / R
    + => v = (2 G M / R)^{1/2}
    + => v = T (2 G M)^{1/2} (4 pi sigma / L)^{1/4}
    + for 1 Msun, 1 Lsun, and T = 1e4 this gives 1070 km/s
    + So we have 1070 (T/1e4) M^{1/2} / L^{1/4} km/s 
|        L |  M |     T |   Mdot | Vcrit |  Gamma_e |  V_esc | 2.6 V_esc | Check |
|----------+----+-------+--------+-------+---------+-------+----------+-------|
|    6.3e3 | 10 | 25200 | -9.473 |   670 |   0.017 |  949. |    2467. | 1.002 |
|  5.453e4 | 20 | 33872 | -7.308 |   721 | 0.07246 | 1022. |    2657. | 1.002 |
|  2.219e5 | 40 | 44124 | -6.221 |   898 |   0.147 | 1271. |    3305. | 1.001 |
| 3.4095e5 | 40 | 36290 | -5.890 |   607 |    0.24 |  886. |    2304. | 1.032 |
#+TBLFM: $4=-6.697 + 2.195 log10($1/1e5) - 1.313 log10($2/30) - 1.226 log10(2.6/2) + 0.933 log10($3/40000) - 10.92 (log10($3/40000))**2 ; f3::$7=1070 ($3/1e4) ($2*(1 - $6))**0.5 / $1**0.25 ; f0::$8=2.6 $-1 ; f0::$9=$7/$5 sqrt(2) ; f3

+ *Conclusion is that the Meyer velocities are all too small by a factor of 2 to 2.5*

** TODO Directly use the Brott (2011) evo tracks to synthesise \eta distribution
+ We could make histograms of (L, \eta) for different masses, then combine them according to an IMF
+ Either weight by time, or weight by stellar energy radiated

* The nature of dust particles
+ Do we really have separate C and silicate grains?
  + Mostly, it is assumed that we have
    1. Power-law silicate grains
    2. Power-law carbon grains
    3. Small PAHs
  + Alternative (Jones at el 2013, 2016)
    + Silicate cores with aromatic carbonaceous mantles
    + Model originally proposed by Mayo Greenberg


** DONE Which grains contribute most to the extinction
CLOSED: [2018-01-01 Mon 14:55]
+ *Conclusion*
  + 0.02 micron grains dominate in FUV
  + 0.2 micron grains dominate in NIR
+ In the FUV, Q ~ 1 for all grain sizes
+ Some grain models have roughly equal contributions from the 3 dust varieties (see above) to the FUV extinction (e.g., Guilet 2017 Fig 8)
  + Silicates dominate the mass by a factor of about 3:1
+ Power law size distribution (following Weingartner & Draine 2001)
  + Volume of carbonaceous dust \approx 1/2 that of silicates
  + Density is also smaller: 2.2 g/cm³ versus 3.5 g/cm³
  + MRN distribution was \( \dfrac{d\,n}{d\,a} = C\, n_{H}\, a^{-3.5}\) from 50 \AA to 0.5 \mu{}m (5000 \AA)
    + n = \int_{a-}^{a+} a^-3.5 d a
    + mass of dust: \int_{a-}^{a+} a^3 a^-3.5 da = (1/2) [a_{+}^{1/2} - a_{-}^{1/2}]
    + opacity of dust, assuming Q constant:
      \int_{a-}^{a+} a^2 a^-3.5 da = (1/2) [a_{-}^{-1/2} - a_{+}^{-1/2}]
    + Opacity of dust, assuming Q ~ a: same as mass
    + Hence, if a_{-} \ll a_{+} then we have
      + mass ~ a_{+}^{1/2}
      + opacity (\lambda < a): \sim a_{-}^{-1/2}
      + opacity (\lambda > a): ~ a_{+}^{1/2}
  + Other distributions have smaller q, apparently, so general results are:
    + mass
      + q < 4 :: a_{+}^{4-q}
      + q = 4 :: ln(a_{+}/a_{-})
      + q > 4 :: a_{-}^{q-4}
    + opacity (a > \lambda)
      + q < 3 :: a_{+}^{3-q}
      + q = 3 :: ln(a_{+}/a_{-})
      + q > 3 :: a_{-}^{q-3}
    + opacity (a < \lambda)
      + same as mass
  + Hence, simple conclusion:
    + Extinction at each wavelength is dominated by grains with a \approx \lambda
      + Unless \lambda > a_{+}, in which case it is a = a_{+}
      + OR unless q > 4 (*never happens*, except at large sizes), in which case it is a = a_{-}
      + OR unless q < 3 (/rarely happens/), in which case it is a = a_{+}
  + Cross-check with Weingartner eq (7)
    + A(\lambda) ~ \int (dn/da) a^3 Q d(ln a)
    + d(ln a) = a^-1 da, so we are in agreement
  + Kim, Martin & Hendry (1994) has a clear presentation
    + They plot in terms of mass-per-decade: a m(a), which is sort of like a SED
      + This is basically the same as the a^4 dn/da in other papers
      + So q < 3 case looks steeper than linear increase on this graph
      + And the q > 4 is falling rather than rising
    + Their binned solutions look like the sum of 3 log-normals
      + Also, Hirashita (2015) show that even just two log-normals can approximate the extinction law
    + The general slope is similar to MRN for R = 3
    + But is steeper for R = 5
      + For silicates, it is roughly linear in mass-per-decade, which is q = 3
      + For carbon it just has a big peak around 0.1 micron (also there for R=3 case)
    + And for R = 5, it is carbon that dominates the FUV opacity (equal silicate and carbon for R=3)
    + They make the point that extinction in range 0.1 \to 5 \mu{}m only constrains the shape of n(a) in the range 0.02 \to 1 \mu{}m
      + Grains smaller than 0.02 microns, contribute according to their mass, so there can be no constraint on the mass distribution
      + Grains larger than 1 micron have gray-ish opacity over entire wavelength range
  + Actually, the a ~ \lambda argument might need tweaking
    + From Figs 3 and 4 of Guillet (2017), it looks like grains as small as 0.02 micron, still have Q \approx 2 at 1000 \AA
    + And, more generally it looks like 5 a = \lambda is more like turnover from constant to a/\lambda
    + A better plot is Fig 8 of Weingartner & Draine (2001).  This is versus a, rather than \lambda, which is what we actually want.  It shows that the turnover occurs around 200 - 300 \AA, which is 0.02 - 0.03 micron.
      + There is slight variation with stellar T in range 20 to 50,000, but not much
      + For the interstellar radiation field (dominated by stars I think), the turnover is at 1 micron for silicates, or 0.2 micron for carbon grains


** Which grains contribute most to MIR and FIR emission
+ [ ] I think it has to be the biggest ones, but need to check

* DONE Magnetic fields in the ISM: magnitude and turbulence 
CLOSED: [2018-01-01 Mon 23:05]
+ It is important to understand the B fields, because of the Lorentz force on the grains, which may dominate in many cases
+ Uniform and turbulent B fields
  + Haverkorn et al (2008) find flat structure functions for rotation measure
    + Interpretation:
      1. Outer scale for turbulence in B fields is a only few parsecs in the spiral arms, conveniently below their smallest separations! 
      2. B fluctuations must be approx Kolmogorov below these scales because otherwise there would be inconsistent with microwave polarization of dust
      3. Outer scale is larger in the inter-arm regions
      4. Total magnetic field strength is around 6 \mu G at the solar radius; regular component is around 2 \micro G
      5. These are with densities of about 0.07 pcc, which gives Alfvén speeds of
         - Total: 43 km/s
         - Regular: 14 km/s
         - So these are both quite high, just because of the low density
  + *However* Xu & Zhang (2016) pour cold water on this and claim that the RM structure functions are dominated by density fluctuations, not B fluctuations
    + The density structure function is flat because of compressible turbulence
    + The B field fluctuations do have an outer scale of 100 pc or so, as previously expected
    + Han (2017) have a E ~ k^{-2/3} law above 3 pc, and E ~ k^{-5/3} law below that
      + If the fluctuating B component follows B ~ r^{1/3} then going from 100 pc to 1 pc, it would be reduced by a factor of 5 or so
+ Meyer (2017) had
  + n = 0.59
  + B = 7 \mu G
  + => v_A = 17.4 km/s
  + This is very high if the bow is supposed to be in an H II region
+ Argument for Alfvén speed in H II regions
  + Alfvén speed in molecular clouds ~ 3 km/s
  + As region expands spherically, v_A ~ n^{1/6}
  + Stops expanding spherically when n c_s^2 ~ n_0 v_{A,0}^2
    + => v_A/v_{A,0} = (v_{A,0}/c_s)^{1/3} =  0.669
    + => v_A =  2 km/s
  + So, density has fallen by 0.3^2 = 0.09
  + E.g., neutral density = 10 => ionized density = 1 pcc
    + Neutral B-field = 4.96 \mu G, Ionized B field: 0.855 micro Gauss
  + Or, to be more like the Rosette: n_0 = 100, n = 10
    + B_0 = 15.7 micro G => B = 3.3 micro G


** Observations of B fields in H II regions 
+ Lots of work on Rosette
  + *Conclusions*
    + Alfvén speed of 2 km/s, B = 3 micro G, n = 10 pcc
    + Ambient density is 23 pcc, v_A = 3.6 km/s, B = 9 micro G
  + Costa et al (2016)
    + Dense sampling of points
    + Model is completely misguided: compressed field in thin shell, like it were a Weaver model
    + Thankfully, they find no evidence for their silly model - instead the evidence weakly prefers a model of unchanged B over the environment
    + But it is very hard to work out what they have actually measured in terms of B, since it is all tangled up with their model
    + In particular, the mean electron density for each line of sight does not seem to be measured directly, even in their "empirical" model - it comes from using their model
    + It might be possible to disentangle something more useful from their data, but it would be some effort
    + Anyway, find evidence for local variations
  + Planck collaboration (2016)
    + Model is actually surprisingly good
      + Takes into account H II region and compressed neutral shell
    + They do actually give the electron densities, derived directly from EM/L
      + Assuming filling factor unity
      + And with L from a spherical shell model with inner, outer radii of 7, 19 pc
    + Find B(los) = 1 to 5 \micro G
    + Variations in B are much larger than variations in n_e
      | Source |     n | B_par |
      |--------+-------+------|
      | I6     |     9 |    5 |
      | I7     |    12 |  2.3 |
      | I8     |    12 |  1.1 |
      | I10    |    10 |    5 |
      | I12    |    13 |  2.1 |
      | I15    |     8 |    4 |
      |--------+-------+------|
      | mean   | 10.67 | 3.25 |
      | sigma  |  1.80 | 1.50 |
      | % sig  |  16.9 | 46.2 |
      #+TBLFM: @8$2..@8$3=vmean(@I..@II);f2::@9$2..@9$3=vpsdev(@I..@II);f2::@10$2..@10$3=100 @-1/@-2;f1
      + Density is 11 +/- 17%
      + B is 3 +/- 46%
      + This means that either there are +/- 50% variations in |B|, or that there are significant variations in direction
    + They have a model (a quite reasonable one) which has the following field strengths
      + Unperturbed ISM: 9 micro G
      + Compressed dust shell: 21.4 micro G
        + Mass: M = 8.6e4 Msun
        + Radius: R = 20 pc = 6.17e19 cm
        + Thickness: h = 4 pc = 1.23e19
        + \rho = M / 4 \pi R^2 h = 2.9e-22 g/cm^3
        + => n = 134 pcc
      + H II region: 3.2 micro G, n = 11 pcc
    + Density of unperturbed ISM
      + Total mass: H II + shell = 1.2e4 + 8.6e4
        + = 9.8e4 Msun
      + R_out = 22 pc
      + \rho = 3 M / 4 pi R^3 = 4.96e-23 g/cm^3
      + n = 22.8 cm^-3
    + Resultant Alfvén speeds
      + H II region: v_A = 1.85 km/s
      + Compressed shell: v_A = 3.5 km/s
      + Ambient medium: v_A = 3.6 km/s
    


 
* Bow waves formed by radiation pressure on dust grains
+ This mini-project has outgrown its original home, which was in [[id:5493D03D-24D5-479B-8C7B-0BE2FCA576EF][Multifactor pair plot of the non-shape parameters]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Stellar-Bowshocks-2017/stellar-bowshocks.org][../Stellar-Bowshocks-2017/stellar-bowshocks.org]]
+ So, I am moving it here to give it room to grow
** Copy dust wave figure files to paper folder
#+BEGIN_SRC sh :results output
  FIGFILES='dust-couple-stream-annotate.pdf dust-wave-Rc-R90*.pdf dust-coupling-1d.pdf dust-divergent.pdf dust-couple-div-stream.jpg decouple-v-n-plane.pdf zones-v-n-plane.pdf zones-v-n-plane-?SG.pdf decouple-v40-versus-n.pdf'
  date
  pwd
  for f in $FIGFILES; do
      cp -av $f ../papers/Papers1234/figs 
  done
#+END_SRC

#+RESULTS:
#+begin_example
Wed Jan  3 17:58:55 CST 2018
/Users/will/Work/Bowshocks/Jorge/bowshock-shape/Dust-wave
dust-couple-stream-annotate.pdf -> ../papers/Papers1234/figs/dust-couple-stream-annotate.pdf
dust-wave-Rc-R90-error.pdf -> ../papers/Papers1234/figs/dust-wave-Rc-R90-error.pdf
dust-wave-Rc-R90.pdf -> ../papers/Papers1234/figs/dust-wave-Rc-R90.pdf
dust-coupling-1d.pdf -> ../papers/Papers1234/figs/dust-coupling-1d.pdf
dust-divergent.pdf -> ../papers/Papers1234/figs/dust-divergent.pdf
dust-couple-div-stream.jpg -> ../papers/Papers1234/figs/dust-couple-div-stream.jpg
decouple-v-n-plane.pdf -> ../papers/Papers1234/figs/decouple-v-n-plane.pdf
zones-v-n-plane.pdf -> ../papers/Papers1234/figs/zones-v-n-plane.pdf
zones-v-n-plane-BSG.pdf -> ../papers/Papers1234/figs/zones-v-n-plane-BSG.pdf
zones-v-n-plane-RSG.pdf -> ../papers/Papers1234/figs/zones-v-n-plane-RSG.pdf
decouple-v40-versus-n.pdf -> ../papers/Papers1234/figs/decouple-v40-versus-n.pdf
#+end_example

** Dust grain trajectories
+ The figure of these in the case of zero gas-grain coupling is done in [[id:8EC004CA-32CC-4B41-830C-535FF79B0544][Dust grain trajectories in a central force]] in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/Quadric-shapes/quadric-projected-2017.org][../Quadric-shapes/quadric-projected-2017.org]]
+ [X] I would like to do some sort of n-body code coupled with a gas code to allow a more realistic model
  + A first approach would be a test-particle approximation, which would avoid the need for the gas code
  + We would have a uniform background gas flow to provide drag, but would ignore the back reaction of the grains on the gas (valid for sufficiently low dust-gas ratio)
  + We could solve this using ~scipy.integrate.odeint~ or ~scipy.integrate.ode~
  + On the axis, for sufficiently weak coupling, I think the trajectories will oscillate between
    1. an inner radius, r_0, where drift speed w \gg inflow speed v_0, allowing grain to decouple and turn from inflow to outflow
    2. an outer radius, r_1, where w = v_0, so grain re-couples and turns from outflow back to inflow again 
  + If density is constant, then w \propto 1/r, so if w_0 is the drift speed at r_0, then r_1 = r_0 w_0 / v_0
  + Although, wouldn’t grain get trapped at r_1?
  + Yes, it turns out that the phase space (x, u) trajectories spiral into (x=r_1, u=0)
*** On-axis numerical solution for trajectories
#+BEGIN_SRC python :eval no :tangle dust-coupling-1d.py
  import sys
  import numpy as np
  from scipy.integrate import odeint
  from matplotlib import pyplot as plt
  import seaborn as sns

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      x, u = y
      dxdt = u
      dudt = 0.5*(x**(-2) - alpha**2 * (u + 1.0))
      return [dxdt, dudt]

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Initial conditions
  y0 = [10.0, -1.0]

  # Coupling parameter
  alpha = 1.0/2.0

  # Time grid
  t = np.linspace(0.0, 60.0, 501)
  soln = odeint(dydt, y0, t, args=(alpha,))
  t0 = t[np.argmin(soln[:, 0])]

  # Slippage velocity
  w = 1.0 + soln[:, 1]
  # Drift velocity
  wdrift = 1.0 / alpha / soln[:, 0]

  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(t - t0, soln[:, 0], label='$R/R_{0}$')
  ax.plot(t - t0, w, label='$w / v_{\infty}$')
  ax.plot(t - t0, wdrift, ls='--', label='$w_\mathrm{drift} / v_{\infty}$')

  ax.axhline(1.0/alpha, ls=':', color='k', lw=0.8)
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  ax.legend(title=r"$\alpha_\mathrm{drag} = 0.5$")
  ax.set(xlabel=r'Time / $(R_{0} / v_{\infty})$', ylim=[-0.3, 4.3])
  t2 = np.linspace(0.0, 20.0, 201)
  soln2 = odeint(dydt, y0, t2, args=(2.0,))
  soln0 = odeint(dydt, y0, t2, args=(0.0,))

  axp.plot(soln0[:, 0], soln0[:, 1], label=r"$\alpha_\mathrm{drag} = 0$")
  axp.plot(soln[:, 0], soln[:, 1], label=r"$\alpha_\mathrm{drag} = 0.5$")
  axp.plot(soln2[:, 0], soln2[:, 1], label=r"$\alpha_\mathrm{drag} = 2$")
  axp.axhline(0, xmax=0.55, color='k', lw=0.5)
  axp.legend(title='Phase space\n  trajectories')
  axp.set(xlabel='$R/R_{0}$', ylabel='$v / v_{\infty}$',
          xlim=[-0.35, 6.9], ylim=[-1.1, 1.1],
          xticks=range(7),
          yticks=[-1.0, -0.5, 0., 0.5, 1.0])

  sns.despine(trim=True)
  fig.tight_layout()
  fig.text(0.02, 0.97, '(a)')
  fig.text(0.02, 0.5, '(b)')
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC shell :results file
python dust-coupling-1d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-1d.pdf]]
*** Two-d solution for trajectories


#+BEGIN_SRC python :eval no :tangle dust_couple_ode.py
  import numpy as np
  from scipy.integrate import odeint

  def dydt(y, t, alpha):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      X, U, Y, V = y
      dXdt = U
      dYdt = V
      R2 = X**2 + Y**2
      theta = np.arctan2(Y, X)
      dUdt = 0.5*(np.cos(theta)/R2 - alpha**2 * (U + 1.0))
      dVdt = 0.5*(np.sin(theta)/R2 - alpha**2 * V)
      return [dXdt, dUdt, dYdt, dVdt]

  def dydt_div(y, t, alpha, mu):
      """Derivatives for ODE in divergent case"""
      X, U, Y, V = y
      dXdt = U
      dYdt = V
      R2 = X**2 + Y**2
      # Gas flow diverges from point (X1, Y1) = (1/mu, 0)
      X1, Y1 = 1.0/mu, 0.0
      # Gas flow is radial from that point
      R1 = np.hypot(X - X1, Y - Y1)
      U1 = (X - X1)/R1
      V1 = (Y - Y1)/R1
      theta = np.arctan2(Y, X)
      dUdt = 0.5*(np.cos(theta)/R2 - alpha**2 * (U - U1))
      dVdt = 0.5*(np.sin(theta)/R2 - alpha**2 * (V - V1))
      return [dXdt, dUdt, dYdt, dVdt]


  def streamline(alpha=1.0/3.0, X0=10.0, Y0=0.0,
                 tstop=60.0, n=201, mu=None):
      # Time grid
      t = np.linspace(0.0, tstop, n)
      if mu is None:
          # parallel stream
          # Vector of initial conditions
          y0 = [X0, -1.0, Y0, 0.0]
          soln = odeint(dydt, y0, t, args=(alpha,))
      else:          # Vector of initial conditions

          # divergent stream
          X1, Y1 = 1.0/mu, 0.0
          assert X0 < X1, 'Start point must be to left of wind source'
          R1 = np.hypot(X0 - X1, Y0 - Y1)
          U0 = (X0 - X1)/R1
          V0 = (Y0 - Y1)/R1
          # Vector of initial conditions
          y0 = [X0, U0, Y0, V0]
          soln = odeint(dydt_div, y0, t, args=(alpha, mu))
        
      return {'t': t, 'b': Y0, 'alpha': alpha, 'mu': mu, 
              'x': soln[:, 0], 'u': soln[:, 1],
              'y': soln[:, 2], 'v': soln[:, 3],}

#+END_SRC

#+BEGIN_SRC python :eval no :tangle dust-coupling-2d.py
  import sys
  from matplotlib import pyplot as plt
  import seaborn as sns
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Impact parameter
  b = 0.001
  stream = streamline(Y0=b, alpha=1.0/2.0, tstop=70, X0=20., n=501, mu=0.01)
  sns.set_style('white')
  sns.set_color_codes()
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(stream['t'], stream['u'], label='$U$')
  ax.plot(stream['t'], stream['v'], label='$V$')
  ax.plot(stream['t'], stream['x'], label='$X$')
  ax.plot(stream['t'], stream['y'], label='$Y$')
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  label = fr"$\alpha = {stream['alpha']:.2f}$, "
  if stream['mu'] is not None:
      label += fr"$\mu = {stream['mu']:.2f}$, "
  label += f"$b = {b:.3f}$"
  ax.legend(title=label, ncol=2)
  ax.set(xlabel='Time', ylim=[-6, 8])

  axp.plot(stream['x'], stream['u'], label='$(X, U)$')
  axp.plot(stream['y'], stream['v'], label='$(Y, V)$')
  axp.axhline(0, color='k', lw=0.5)
  axp.legend(title='Phase space')
  axp.set(xlabel='$X$, $Y$', ylabel='$U$, $V$',
          xlim=[-7, 9], ylim=[-1.1, 1.1])

  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-coupling-2d.py
#+END_SRC

#+RESULTS:
[[file:dust-coupling-2d.pdf]]


#+BEGIN_SRC python :eval no :tangle dust-couple-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.jpg')

  sns.set_style('white')
  sns.set_color_codes()
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  nb = 25*200 + 1
  bgrid = 0.001 + np.linspace(0.0, 5.0, nb)
  ibspecial = 25*np.array([1, 4, 10, 20, 40, 60])
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth

  rm = 2.0/(1.0 + np.cos(thm_grid))
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  xmin, xmax = [-3.99, 3.99]
  ymin, ymax = [0.0, 4.99]
  for alpha, ax in zip(alphas, axes.flat):
      xx, yy, ww = [], [], []
      xs, ys = [], []
      for ib, b in enumerate(bgrid):
          s = streamline(X0=5, Y0=b, tstop=30, alpha=alpha, n=30001)
          # ax.plot(s['x'], s['y'], color='k', lw=0.5)
          # Accumulate (x, y) points in a long list
          xx.extend(s['x'])
          yy.extend(s['y'])
          # Weights proportional to b/r
          ww.extend(s['b']/s['y'])
          # ax.plot(s['x'], s['y'], '.',
          #         mec='none', mfc='r', ms=3, alpha=0.02)
          if ib in ibspecial:
              # Save streamlines for selected impact parameters
              xs.append(s['x'])
              ys.append(s['y'])
      # Plot a density histogram of all the (x, y) points we accumulated
      H, xe, ye = np.histogram2d(xx, yy, bins=(80/1, 50/1), weights=ww,
                                 range=[[xmin, xmax], [ymin, ymax]])
      rho_m = np.median(H)
      ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
                vmin=0.0, vmax=2.0*rho_m, cmap='gray_r')
      # Plot the streamlines that we saved earlier
      for x, y in zip(xs, ys):
          ax.plot(x, y, '-', color='w', lw=0.8, alpha=0.5)
          ax.plot(x, y, '-', color='k', lw=0.5)
      ax.plot(xlocus, ylocus, ':', color='w', alpha=0.5, lw=2)
      ax.axvline(0.0, ls='--', color='w', lw=0.5)
      ax.text(1.0, 4.0, 
              fr"$\alpha_\mathrm{{drag}} = {alpha:.2f}$",
              color='k')
      ax.set_aspect('equal', adjustable='box-forced')

      # Save the minimum radius as a function of theta
      rr = np.hypot(xx, yy)
      theta = np.arctan2(yy, xx)
      rrm_grid = np.empty_like(thm_grid)
      for j, th0 in enumerate(thm_grid):
          # Mask to select points with theta between th0 -> th0 + dth
          m = np.abs(theta - (th0 + 0.5*dth)) <= 0.5*dth
          try:
              rrm_grid[j] = rr[m].min()
          except:
              # Sometimes mask may be empty
              rrm_grid[j] = np.nan
            
      tabfilename = sys.argv[0].replace('.py', f'-alpha{int(100*alpha):03d}.tab')
      Table({'theta': thm_grid, 'R': rrm_grid}).write(tabfilename, format='ascii.tab')

  for ax in axes[:, 0]:
      ax.set(ylabel='$y/R_{0}$', ylim=[ymin, ymax])
  for ax in axes[-1, :]:
      ax.set(xlabel='$x/R_{0}$', xlim=[xmin, xmax])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile, dpi=600)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-couple-stream.py
#+END_SRC

#+RESULTS:
[[file:dust-couple-stream.jpg]]

+ I will now annotate this figure with Graphic.app
  + PDF export in [[file:dust-couple-stream-annotate.pdf]]
+ Now repeat for a divergent incident stream
  + We have problems with the large \alpha_drag models because the bow gets
    small.  So what I will do is to scale the lengths by 1/(1 +
    \alpha_drag), which should make the stand-off distances be the same in
    all cases.
  + Except the factor isn't exactly that.
    + Maybe just try 1/\alpha_drag since that is the stagnation radius,
    + which is close to the inner edge for \alpha_drag \gg 1
    + But not for \alpha_drag < 1

#+BEGIN_SRC python :eval no :tangle dust-couple-div-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from dust_couple_ode import streamline

  figfile = sys.argv[0].replace('.py', '.jpg')

  sns.set_style('ticks')
  sns.set_color_codes()
  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  alphas = [1.0, 1.0, 4.0, 4.0]
  mus = [0.05, 0.2, 0.2, 0.8]
  nb = 25*200 + 1
  bgrid = 0.001 + np.linspace(0.0, 5.0, nb)
  ibspecial = 25*np.array([1, 4, 10, 20, 40, 60])
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth


  xmin, xmax = [-4.1, 4.1]
  ymin, ymax = [0.0, 5.1]
  for alpha, mu, ax in zip(alphas, mus, axes.flat):
      xx, yy, ww = [], [], []
      xs, ys = [], []

      # zoom in on the alpha > 1 models since they get small
      zoom = alpha if alpha > 1.0 else 1.0

      # Launch grains on a uniform grid of th1
      # Make sure it fills the plot
      th1max = np.arctan2(ymax/zoom, 1.0/mu - xmax/zoom)
      th1grid = 0.001*mu + np.linspace(0.0, th1max, nb)
      bgrid = np.sin(th1grid)/mu

      # Hyperbola solution for drag-free case, but scaling mu by alpha
      ecc = 1.0 / (1.0 - 2*mu/alpha)
      # And scale radius by alpha too
      rm = (1.0 + ecc)/(1.0 + ecc*np.cos(thm_grid))/alpha
      rm[rm < 0.0] = np.nan
      xlocus = rm*np.cos(thm_grid)
      ylocus = rm*np.sin(thm_grid)


      for ib, (th1, b) in enumerate(zip(th1grid, bgrid)):
          # Start from a circle just outside the plot window
          Rlaunch = 1/mu - xmax/zoom
          assert Rlaunch > 0.0
          X0 = 1./mu - Rlaunch*np.cos(th1)
          Y0 = Rlaunch*np.sin(th1)
          s = streamline(X0=X0, Y0=Y0, tstop=30, alpha=alpha, mu=mu, n=30001)
          # ax.plot(s['x'], s['y'], color='k', lw=0.5)
          # Accumulate (x, y) points in a long list
          xx.extend(s['x'])
          yy.extend(s['y'])
          # Weights proportional to b/r
          ww.extend(s['b']/s['y'])
          # ax.plot(s['x'], s['y'], '.',
          #         mec='none', mfc='r', ms=3, alpha=0.02)
          if ib in ibspecial:
              # Save streamlines for selected impact parameters
              xs.append(s['x'])
              ys.append(s['y'])
      # Plot a density histogram of all the (x, y) points we accumulated
      H, xe, ye = np.histogram2d(xx, yy, bins=(80/1, 50/1), weights=ww,
                                 range=[[xmin/zoom, xmax/zoom], [ymin/zoom, ymax/zoom]])
      rho_m = np.median(H[H != 0.0])
      rho_m = H[-1, -1]
      ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
                vmin=0.0, vmax=2.0*rho_m, cmap='gray_r')
      # Plot the streamlines that we saved earlier
      for x, y in zip(xs, ys):
          ax.plot(x*zoom, y*zoom, '-', color='w', lw=0.8, alpha=0.5)
          ax.plot(x*zoom, y*zoom, '-', color='k', lw=0.5)
      ax.plot(xlocus*zoom, ylocus*zoom, ':', color='w', alpha=0.5, lw=2)
      ax.axvline(0.0, ls='--', color='w', lw=0.5)
      label = fr"$\alpha_\mathrm{{drag}} = {alpha:.1f}$"
      label += '\n' + fr"$\mu = {mu:.2f}$"
      ax.text(1.0, 4.0, label, color='k')
      ax.set_aspect('equal', adjustable='box-forced')

      # Save the minimum radius as a function of theta
      rr = np.hypot(xx, yy)
      theta = np.arctan2(yy, xx)
      rrm_grid = np.empty_like(thm_grid)
      for j, th0 in enumerate(thm_grid):
          # Mask to select points with theta between th0 -> th0 + dth
          m = np.abs(theta - (th0 + 0.5*dth)) <= 0.5*dth
          try:
              rrm_grid[j] = rr[m].min()
          except:
              # Sometimes mask may be empty
              rrm_grid[j] = np.nan

      suffix = f'-alpha{int(100*alpha):03d}'
      suffix += f'-mu{int(100*mu):03d}'
      tabfilename = sys.argv[0].replace('.py', suffix + '.tab')
      Table({'theta': thm_grid, 'R': rrm_grid}).write(tabfilename, format='ascii.tab', overwrite=True)

  for ax in axes[:, 0]:
      ax.set(
          ylabel=r'$\alpha_\mathrm{{drag}} \,Y$',
          ylim=[ymin, ymax],
          yticks=range(5),
      )
  for ax in axes[-1, :]:
      ax.set(
          xlabel=r'$\alpha_\mathrm{{drag}} \,X$',
          xlim=[xmin, xmax],
          xticks=range(-4,5),
      )

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile, dpi=600)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-couple-div-stream.py
#+END_SRC

*** Shape parameters as function of drag parameter
+ We have written tables of R(\theta) for the inner edge of the dust shells
  + [[file:dust-couple-stream-alpha025.tab]]
  + [[file:dust-couple-stream-alpha050.tab]]
  + [[file:dust-couple-stream-alpha100.tab]]
  + [[file:dust-couple-stream-alpha200.tab]]
+ So we can find R_c and R_90 and plot them as function of \alpha_drag

#+BEGIN_SRC python :eval no :tangle dust-wave-Rc-R90.py
  import sys
  import json
  import numpy as np
  from scipy.interpolate import interp1d
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  import astropy.modeling.fitting
  from astropy.modeling.models import custom_model
  from astropy.modeling.fitting import LevMarLSQFitter
  sys.path.append('../conic-projection')
  from conproj_utils import Conic

  @custom_model
  def conic_y_x(x, x0=-3.0, a=5.0, b=3.0):
      s = np.sign(x0 - 1.0)
      return b*np.sqrt(1.0 + s*((x - x0)/a)**2)

  alldata = {}

  fit = LevMarLSQFitter()

  figfile = sys.argv[0].replace('.py', '.pdf')
  sns.set_style('white')
  sns.set_color_codes()

  fig, axes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))
  efig, eaxes = plt.subplots(2, 2, sharex=True, sharey=True, figsize=(6, 4))

  alphas = [1.0/4.0, 1.0/2.0, 1.0, 2.0]
  results = {'alpha': [0.0] + alphas, 'Rc': [2.0], 'R90': [2.0]}
  for alpha, ax, eax in zip(alphas, axes.flat, eaxes.flat):
      astring = f'-alpha{int(100*alpha):03d}.tab'
      alpha_label = fr"$\alpha_\mathrm{{drag}} =  {alpha:.02f}$"
      fitdata = {}
      t = Table.read('dust-couple-stream' + astring, format='ascii.tab')
      dth = np.pi/len(t)
      theta = t['theta'] + 0.5*dth
      # Mask to select only the near-apex region
      m = np.degrees(theta) <= 30.0
      # Reflect through origin to ensure an even function
      thth = np.concatenate([-theta[m][::-1], theta[m]])
      RR = np.concatenate([t['R'][m][::-1], t['R'][m]])
      # Fit polynomial to find R0 and Rc
      a, b, c = np.polyfit(thth, RR, deg=2)
      assert(b == 0.0, 'Linear term should be non-zero, but is not')
      R0 = c
      Rc = 1.0/(1.0 - 2.0*a/c)

      # Find R90 by linear interpolation
      f = interp1d(theta, t['R'], kind='linear')
      R90 = f(0.5*np.pi)/R0
      results['Rc'].append(Rc)
      results['R90'].append(R90)

      R_bow = t['R']/R0
      x_bow = R_bow*np.cos(theta)
      y_bow = R_bow*np.sin(theta)

      # Define the head-fit conic section that corresponds to (Rc, R90)
      arg = 2*Rc - R90**2
      thc = np.sign(arg)*np.arctan(np.sqrt(np.abs(arg)))
      head_conic = Conic(A=Rc, th_conic=np.degrees(thc))
      t = head_conic.make_t_array()
      x_head = head_conic.x(t)
      y_head = head_conic.y(t)
      th_head = np.arctan2(y_head, x_head)
      R_head = np.hypot(x_head, y_head)

      # Save the parameters for the head fit
      fitdata['head'] = {'Rc': Rc,
                         'R90': R90,
                         'T': head_conic.b_a**2}

      # Now find a tail-fit conic
      # We only fit the tail between xswitch and xfar
      xswitch, xfar = -1.0, -8.0
      mtail = (x_bow < xswitch) & (x_bow > xfar)
      mfar = (x_bow <= xfar) & (x_bow > -40.0)

      # Try a more direct approach: fit hyperbola with LM
      model = conic_y_x()
      best_model = fit(model, x_bow[mtail], y_bow[mtail])
      r0_tail = best_model.a.value + best_model.x0.value

      x_tail = np.linspace(r0_tail, -30.0, 1000)
      y_tail = best_model(x_tail)
      th_tail = np.arctan2(y_tail, x_tail)
      R_tail = np.hypot(x_tail, y_tail)

      # Save the parameters for the tail fit
      fitdata['tail'] = {'x0': best_model.x0.value,
                         'a': best_model.a.value,
                         'b': best_model.b.value,
                         'r0': best_model.a.value + best_model.x0.value,
                         'T': (best_model.b.value/best_model.a.value)**2}

      # Finally, a third fit to the far tail with a hyperbola
      # model2 = conic_y_x(x0=15.0, a=30.0, b=1.0)
      model2 = conic_y_x(x0=-15.0, a=30.0, b=y_bow[mfar].max())
      best_model2 = fit(model2, x_bow[mfar], y_bow[mfar]) 
      x_far = np.linspace(2.0, -100.0, 1000)
      y_far = best_model2(x_far)
      th_far = np.arctan2(y_far, x_far)
      R_far = np.hypot(x_far, y_far)

      # Save the parameters for the far tail fit
      fitdata['far'] = {'x0': best_model2.x0.value,
                        'a': best_model2.a.value,
                        'b': best_model2.b.value,
                        'r0': best_model2.a.value + best_model2.x0.value,
                        'T': (best_model2.b.value/best_model2.a.value)**2}

      # Stash the fit data in the big dict
      alldata[alpha] = fitdata

      # Plot the bow and the two fits
      ax.axvspan(xfar, xswitch, color='k', alpha=0.05)
      ax.plot(x_bow, y_bow, lw=7, alpha=0.3, label='_nolegend_')
      ax.plot(x_far, y_far, ls='-.', color='m', label="Far tail fit")
      ax.plot(x_tail, y_tail, ls=':', lw=2.5, color='r', label="Tail fit")
      ax.plot(x_head, y_head, ls='--', color='orange', label="Head fit")
      ax.text(-14, 0.8, alpha_label, fontsize='small')

      ax.set_aspect('equal', adjustable='box-forced')

      # And plot the errors
      f_R_tail = interp1d(th_tail, R_tail, bounds_error=False)
      e_tail = (f_R_tail(theta) - R_bow)/R_bow
      f_R_head = interp1d(th_head, R_head, bounds_error=False)
      e_head = (f_R_head(theta) - R_bow)/R_bow
      f_R_far = interp1d(th_far, R_far, bounds_error=False)
      e_far = (f_R_far(theta) - R_bow)/R_bow

      # Find angle that corresponds to x = -1
      th1 = interp1d(x_bow, theta)(xswitch)
      # Find angle that corresponds to x = -8
      th2 = interp1d(x_bow, theta)(xfar)
      mh = theta <= th1
      mt = (theta > th1) & (theta <= th2)
      mtt = theta > th2

      eax.axhline(0.0, lw=3, alpha=0.5, color='b')
      eax.axhspan(-0.01, 0.01, color='b', alpha=0.1, ec='none')
      eax.axvspan(np.degrees(th1), np.degrees(th2), color='k', alpha=0.05)

      # Plot each error curve twice, faintly over the bad zone …
      eax.plot(np.degrees(theta[mt | mtt]), e_head[mt | mtt], label='_nolegend_',
               ls='--', color='orange', alpha=0.3)
      # And strongly over the range it should be fitting
      eax.plot(np.degrees(theta[mh]), e_head[mh], label="Head fit",
               ls='--', color='orange', alpha=1.0)

      # Same for the tail fit, but 3 times since we have a bad zone each side
      eax.plot(np.degrees(theta[mh]), e_tail[mh], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_tail[mtt], label='_nolegend_',
               ls=':', lw=2.5, color='r', alpha=0.3)
      eax.plot(np.degrees(theta[mt]), e_tail[mt], label="Tail fit",
               ls=':', lw=2.5, color='r', alpha=1.0)

      # And now for the far-tail fit as well
      eax.plot(np.degrees(theta[mt]), e_far[mt], label='_nolegend_',
               ls='-.', color='m', alpha=0.3)
      eax.plot(np.degrees(theta[mtt]), e_far[mtt], label="Far tail fit",
               ls='-.', color='m', alpha=1.0)

      eax.text(10.0, -0.04, alpha_label, fontsize='small')


  for ax in axes[-1, :]:
      ax.set(xlim=[-15, 2.5], xlabel='$x/R_0$')
  for ax in axes[:, 0]:
      ax.set(ylim=[0, 8], ylabel='$y/R_0$')
  axes[-1,-1].legend(fontsize='small')

  for eax in eaxes[-1, :]:
      eax.set(xlim=[0.0, 180.0],
              xlabel=r"Polar angle: $\theta$, degrees",
              xticks=[0, 30, 60, 90, 120, 150, 180])
  for eax in eaxes[:, 0]:
      eax.set(ylim=[-0.05, 0.05],
              ylabel=r"Fractional error: $\delta R / R$")
  eaxes[-1,-1].legend(fontsize='small')
  eaxes[-1, 1].text(10.0, -0.9/100, r"$|\delta R/R| < 1\%$", 
                    color='b', fontsize='x-small')

  # print(results)
  #     ax.plot(theta, R, label=fr"${alpha:.2f}$")

  # ax.legend(title=r"$\alpha_\mathrm{drag}$")
  # ax.axhline(2.0, color='k', alpha=0.3, lw=1)
  # ax.axvline(90.0, color='k', alpha=0.3, lw=1)
  # ax.set(xlim=[0.0, 180.0], ylim=[0.0, 14.0],
  #        xlabel=r'$\theta$', ylabel=r'$R$')

  sns.despine(fig)
  fig.tight_layout()
  fig.savefig(figfile)

  sns.despine(efig)
  efig.tight_layout()
  efig.savefig(figfile.replace('.pdf', '-error.pdf'))

  jsonfile = figfile.replace('-Rc-R90.pdf', '-fitdata.json')
  with open(jsonfile, 'w') as f:
      json.dump(alldata, f, indent=4)

  print(figfile, end='')
#+END_SRC


#+BEGIN_SRC sh :results file
python dust-wave-Rc-R90.py
#+END_SRC

#+RESULTS:
[[file:dust-wave-Rc-R90.pdf]]

+ Error figure: [[file:dust-wave-Rc-R90-error.pdf]]
+ JSON data file: [[file:dust-wave-fitdata.json]]

*** Plot diagnostic diagrams for the 3-quadric dust wave fits
+ So this will be like the current Fig 16, but for the \alpha_drag models instead of the carawilkinoids
  + Could I call them /dragoids/?
  + Yes, I think I could
  + Actually, we need to ditch /[an]carawilkinoid/, since it is such a mouthful
  + New terms:
    + /cantoid/ for the CRW shape
    + /ancantoid/ for the anisotropic generalization of ~CRW~
      + Or maybe even /tarangoid/ !!
    + Special cases of ancantoids
      + /proploid/ for \xi = 0.8
      + /jetoid/ for small \xi
+ The graph for the carawilkinoids was done here: [[id:F47926C6-77DB-4797-9101-F83B5E59DA6A][R90 vs Rc for generalized CRW]]
  + It made use of this module: [[id:0483E2CE-E74E-4CFD-89B2-0AE92CCC6217][Utility functions for A, B, and \theta_c]]
  + But that is very specific to those fits and the tortuous process of trying to do analytic matching, which I ended up not using.
  + I think we can do something simpler
+ Some of the necessary equations are in [[id:B3ABBD4B-6A04-415F-8A8D-6A3179EB3686][Projection of Quadrics]]
  + But a lot of the seem to be only in my handwritten notes still
  + I have also copied some functions from [[id:9232DE3C-903E-4D13-8E72-FC2B92D1FF95][Projected R90 versus Rc]]
#+BEGIN_SRC python :eval no :tangle three-quadric-dragoid-R90-vs-Rc.py
  import sys
  import json
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns

  def Rc_prime(inc, Tc, Rc):
      f = np.sqrt(1.0 + Tc*np.tan(inc)**2)
      return Rc * (1 + np.tan(inc)**2) / f / (1.0 + Rc*(f - 1.0) / Tc)

  def Tc_prime(inc, Tc):
      fsquared = 1.0 + Tc*np.tan(inc)**2
      return Tc * (1.0 + np.tan(inc)**2) / fsquared

  def R90_prime(inc, Tc, Rc):
      return np.sqrt(2*Rc_prime(inc, Tc, Rc) - Tc_prime(inc, Tc))

  plotfile = sys.argv[0].replace('.py', '.pdf')

  alldata = json.load(open('dust-wave-fitdata.json'))


  sns.set_style('white')
  sns.set_color_codes('dark')

  fig, ax = plt.subplots(figsize=(5, 5))


  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  inc = np.linspace(0.0, 0.5*np.pi, 500, endpoint=False)
  inc_deg = np.degrees(inc)

  colors = 'bmgr'

  for (alpha, data), color in zip(alldata.items(), colors):
      # Parameters for head conic
      R0_h = 1.0
      T_h = data['head']['T']
      tilde_Rc_h = data['head']['Rc']
      R90_h = data['head']['R90']
      ax.plot([tilde_Rc_h], [R90_h], 'o', color=color)
      ax.plot(Rc_prime(inc, T_h, tilde_Rc_h),
              R90_prime(inc, T_h, tilde_Rc_h), '--', color=color)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)

  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 3.1],
      ylim=[0.0, 3.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        

  sns.despine()
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')


#+END_SRC


#+BEGIN_SRC sh :results file
  python three-quadric-dragoid-R90-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:three-quadric-dragoid-R90-vs-Rc.pdf]]



** Dust grain trajectories with magnetic field
#+BEGIN_SRC python :eval no :tangle dust_bfield_ode.py
  import numpy as np
  from scipy.integrate import odeint

  def dydt(y, t, thB):
      """Derivatives for ODE: x'' = 0.5 (x^{-2} - alpha^2 (x' + 1))"""
      X, U, Y, V, Z, W = y
      dXdt = U
      dYdt = V
      dZdt = W
      R2 = X**2 + Y**2 + Z**2
      # Radiative acceleration
      arad = 0.5/R2
      # dot product of radial vector with b vector
      cos_delta = (X*np.cos(thB) + Y*np.sin(thB))/np.sqrt(R2)
      # Projection onto B direction
      a_para = arad*cos_delta
      dUdt = a_para*np.cos(thB)
      dVdt = a_para*np.sin(thB)
      dWdt = 0.0
      return [dXdt, dUdt, dYdt, dVdt, dZdt, dWdt]


  def streamline(thB=np.radians(90), X0=10.0, Y0=0.0, Z0=0.0,
                 tstop=60.0, n=201):
      # Time grid
      t = np.linspace(0.0, tstop, n)
      # parallel stream
      # Vector of initial conditions
      y0 = [X0, -1.0, Y0, 0.0, Z0, 0.0]
      soln = odeint(dydt, y0, t, args=(thB,))
        
      return {'t': t, 'y0': Y0, 'z0': Z0, 'b': np.hypot(Y0, Z0),
              'x': soln[:, 0], 'u': soln[:, 1],
              'y': soln[:, 2], 'v': soln[:, 3],
              'z': soln[:, 4], 'w': soln[:, 5],}

#+END_SRC

#+BEGIN_SRC python :eval no :tangle dust-bfield-2d.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from dust_bfield_ode import streamline

  figfile = sys.argv[0].replace('.py', '.pdf')

  # Impact parameter
  Y0 = 0.35
  Z0 = 0.1
  thB_degrees = -28.2
  stream = streamline(Y0=Y0, Z0=Z0, thB=np.radians(thB_degrees), tstop=150, X0=10., n=2001)
  sns.set_style('white')
  sns.set_color_codes()
  fig, (ax, axp) = plt.subplots(2, 1, figsize=(4, 6))
  ax.plot(stream['t'], stream['u'], label='$U$')
  ax.plot(stream['t'], stream['v'], label='$V$')
  ax.plot(stream['t'], stream['x'], label='$X$')
  ax.plot(stream['t'], stream['y'], label='$Y$')
  ax.axhspan(0.0, 1.0, color='k', alpha=0.1)
  label = fr"$\theta_B = {thB_degrees:.1f}^\circ$, "
  label += f"$y_0 = {Y0:.2f}$, $z_0 = {Z0:.2f}$"
  ax.legend(title=label, ncol=2)
  ax.set(xlabel='Time', ylim=[-2.5, 4.5], xlim=[0, 70])

  axp.plot(stream['x'], stream['u'], label='$(X, U)$')
  axp.plot(stream['y'], stream['v'], label='$(Y, V)$')
  axp.axhline(0, color='k', lw=0.5)
  axp.legend(title='Phase space')
  axp.set(xlabel='$X$, $Y$', ylabel='$U$, $V$',
          xlim=[-7, 9], ylim=[-1.1, 1.1])

  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-bfield-2d.py
#+END_SRC

#+RESULTS:
[[file:dust-bfield-2d.pdf]]


#+BEGIN_SRC python :eval no :tangle dust-bfield-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from astropy.table import Table
  from dust_bfield_ode import streamline

  try:
      thB_degrees = float(sys.argv[1])
      Z0 = float(sys.argv[2])
  except:
      sys.exit(f"Usage: {sys.argv[0]} FIELD_ANGLE Z0")


  suffix = f"b{int(thB_degrees):02d}-z{int(100*Z0):04d}"
  figfile = sys.argv[0].replace('.py', f'-{suffix}.jpg')

  sns.set_style('white')
  sns.set_color_codes()
  fig, ax = plt.subplots(figsize=(5, 5))
  ny0 = 5*400 + 1
  y0grid = 0.001 + np.linspace(-5.0, 5.0, ny0)
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth

  rm = 2.0/(1.0 + np.cos(thm_grid))
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  xmin, xmax = [-4.99, 4.99]
  ymin, ymax = [-4.99, 4.99]
  xx, yy, ww = [], [], []
  xs, ys = [], []
  for iy0, y0 in enumerate(y0grid):
      s = streamline(X0=20, Y0=y0, Z0=Z0, thB=np.radians(thB_degrees), tstop=60, n=3001)
      # ax.plot(s['x'], s['y'], color='k', lw=0.5)
      # Accumulate (x, y) points in a long list
      xx.extend(s['x'])
      yy.extend(s['y'])
      ww.extend(1.0 / (Z0**2 + s['x']**2 + s['y']**2)**0.5)
      # ax.plot(s['x'], s['y'], '.',
      #         mec='none', mfc='r', ms=3, alpha=0.02)
      if iy0 % 30 == 15:
          # Save streamlines for selected impact parameters
          xs.append(s['x'])
          ys.append(s['y'])
  # Plot a density histogram of all the (x, y) points we accumulated
  H, xe, ye = np.histogram2d(xx, yy, bins=(100, 100), weights=ww,
                             range=[[xmin, xmax], [ymin, ymax]])
  # Do another one with uniform weights for just the density
  Hd, _, _ = np.histogram2d(xx, yy, bins=(100, 100), 
                             range=[[xmin, xmax], [ymin, ymax]])
  np.savez(figfile.replace('.jpg', ''),
           rho=Hd, x=0.5*(xe[1:]+xe[:-1]), y=0.5*(ye[1:]+ye[:-1]))

  rho_m = np.median(H)
  ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
            vmin=0.0, vmax=20.0*rho_m, cmap='gray_r')
  # Plot the streamlines that we saved earlier
  for x, y in zip(xs, ys):
      ax.plot(x, y, '-', color='w', lw=0.8, alpha=0.5)
      ax.plot(x, y, '-', color='k', lw=0.5)
  ax.plot(xlocus, ylocus, ':', color='y', alpha=0.7, lw=2)
  ax.plot(xlocus, -ylocus, ':', color='y', alpha=0.7, lw=2)
  cthB = np.cos(np.radians(thB_degrees))
  sthB = np.sin(np.radians(thB_degrees))
  for xx in np.linspace(1.5*xmin, 1.5*xmax, 15):
      yy1, yy2 = 1.5*ymin, 1.5*ymax
      x1 = -xx*sthB + yy1*cthB
      x2 = -xx*sthB + yy2*cthB
      y1 = xx*cthB + yy1*sthB
      y2 = xx*cthB + yy2*sthB
      ax.plot([x1, x2], [y1, y2], lw=2, alpha=0.5, color='c')
  ax.axvline(0.0, ls='--', color='0.5', lw=0.5)
  ax.axhline(0.0, ls='--', color='0.5', lw=0.5)
  ax.plot([0.0], [0.0], '+', color='k')
  ax.plot([0.0], [0.0], '.', color='k')
  ax.set_aspect('equal', adjustable='box-forced')

  # Save the minimum radius as a function of theta
  rr = np.hypot(xx, yy)
  theta = np.arctan2(yy, xx)
  rrm_grid = np.empty_like(thm_grid)
  for j, th0 in enumerate(thm_grid):
      # Mask to select points with theta between th0 -> th0 + dth
      m = np.abs(theta - (th0 + 0.5*dth)) <= 0.5*dth
      try:
          rrm_grid[j] = rr[m].min()
      except:
          # Sometimes mask may be empty
          rrm_grid[j] = np.nan

  tabfilename = sys.argv[0].replace('.py', f'.tab')
  Table({'theta': thm_grid, 'R': rrm_grid}).write(tabfilename, format='ascii.tab')

  ax.set(
      ylabel='$y/R_{0}$',
      ylim=[ymin, ymax],
      xlabel='$x/R_{0}$',
      xlim=[xmin, xmax])

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile, dpi=600)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 30.0 0.0 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b30-z0000.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 45.0 0.0 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b45-z0000.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 60.0 0.0 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b60-z0000.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 75.0 0.0 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b75-z0000.jpg]]



#+BEGIN_SRC sh :eval no :tangle zmulti-bfield-stream.sh
angle=$1
for z in $(seq 0.0 0.1 4.5); do
    python dust-bfield-stream.py $angle $z 
    echo
done
#+END_SRC


*** \theta_B = 10 degrees
#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.0 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0000.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.1 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0010.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.2 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0020.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.3 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0030.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.4 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0040.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.5 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0050.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.6 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0060.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.7 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0070.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.8 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0080.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 0.9 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0090.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.0 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0100.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.1 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0110.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.2 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0120.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.3 
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0130.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.4
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0140.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.5
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0150.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.6
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0160.jpg]]

#+BEGIN_SRC sh :results file
python dust-bfield-stream.py 10.0 1.7
#+END_SRC

#+RESULTS:
[[file:dust-bfield-stream-b10-z0170.jpg]]
*** DONE Animation of field-frozen trajectories
CLOSED: [2018-01-05 Fri 14:16]
+ [X] This will be the same as ~dust-bfield-stream.py~ but showing an animation of the guiding-center trajectories
  + This is mainly to convince myself that the trajectories are correct
  + If all is well, then a point should remain on the same field line as it moves across
  + The animation machinery is based on [[id:CAB16D0A-7B6A-4E49-AAB6-41A0955E55E2][Animate the waves @ inc = 0]]

#+BEGIN_SRC python :eval no :tangle animate-dust-bfield-stream.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib import animation
  import seaborn as sns
  from astropy.table import Table
  from dust_bfield_ode import streamline

  try:
      thB_degrees = float(sys.argv[1])
      Z0 = float(sys.argv[2])
  except:
      sys.exit(f"Usage: {sys.argv[0]} FIELD_ANGLE Z0")


  suffix = f"b{int(thB_degrees):02d}-z{int(100*Z0):04d}"
  fileroot = sys.argv[0].replace('.py', f'-{suffix}')

  sns.set_style('white')
  sns.set_color_codes()
  fig, ax = plt.subplots(figsize=(5, 5))
  ny0 = 5*400 + 1
  y0grid = 0.001 + np.linspace(-5.0, 5.0, ny0)
  nth = 200
  thm_grid = np.linspace(0.0, np.pi, nth)
  dth = np.pi/nth

  rm = 2.0/(1.0 + np.cos(thm_grid))
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  xmin, xmax = [-4.99, 4.99]
  ymin, ymax = [-4.99, 4.99]
  xx, yy, ww = [], [], []
  xs, ys = [], []
  tstop = 60
  nt = 3001
  X0 = 20
  for iy0, y0 in enumerate(y0grid):
      s = streamline(X0=X0, Y0=y0, Z0=Z0, thB=np.radians(thB_degrees), tstop=tstop, n=nt)
      # ax.plot(s['x'], s['y'], color='k', lw=0.5)
      # Accumulate (x, y) points in a long list
      xx.extend(s['x'])
      yy.extend(s['y'])
      ww.extend(1.0 / (Z0**2 + s['x']**2 + s['y']**2)**0.5)
      # ax.plot(s['x'], s['y'], '.',
      #         mec='none', mfc='r', ms=3, alpha=0.02)
      if iy0 % 30 == 15:
          # Save streamlines for selected impact parameters
          xs.append(s['x'])
          ys.append(s['y'])

  # Artist to use for animation of streamlines
  point_artists = [ax.plot([], [], '.', color='r')[0] for _ in xs]
  nB = 30
  line_artists = [ax.plot([], [], lw=2, alpha=0.5, color='c')[0] for _ in range(nB)]
  xxBs = np.linspace(2*xmin, 2*xmax, nB)

  def animate_points_and_lines(itime):
      """Update time along all plotted streamline points and lines"""
      # Update the lines
      for xx, artist in zip(xxBs, line_artists):
          yy1, yy2 = 3*ymin, 3*ymax
          x1 = -xx*sthB + yy1*cthB  + X0 - tstop*itime/nt
          x2 = -xx*sthB + yy2*cthB  + X0 - tstop*itime/nt
          y1 = xx*cthB + yy1*sthB
          y2 = xx*cthB + yy2*sthB
          artist.set_data([x1, x2], [y1, y2])
      # Update the points
      for x, y, artist in zip(xs, ys, point_artists):
          artist.set_data(x[itime-10:itime+20:10], y[itime-10:itime+20:10])
      return point_artists + line_artists

  # Plot a density histogram of all the (x, y) points we accumulated
  H, xe, ye = np.histogram2d(xx, yy, bins=(100, 100), weights=ww,
                             range=[[xmin, xmax], [ymin, ymax]])
  rho_m = np.median(H)
  ax.imshow(H.T, origin='lower', extent=[xmin, xmax, ymin, ymax],
            vmin=0.0, vmax=20.0*rho_m, cmap='gray_r')
  # Plot the streamlines that we saved earlier
  for x, y in zip(xs, ys):
      ax.plot(x, y, '-', color='w', lw=0.8, alpha=0.5)
      ax.plot(x, y, '-', color='k', lw=0.5)
  ax.plot(xlocus, ylocus, ':', color='y', alpha=0.7, lw=2)
  ax.plot(xlocus, -ylocus, ':', color='y', alpha=0.7, lw=2)
  cthB = np.cos(np.radians(thB_degrees))
  sthB = np.sin(np.radians(thB_degrees))
  ax.axvline(0.0, ls='--', color='0.5', lw=0.5)
  ax.axhline(0.0, ls='--', color='0.5', lw=0.5)
  ax.plot([0.0], [0.0], '+', color='k')
  ax.plot([0.0], [0.0], '.', color='k')
  ax.set_aspect('equal', adjustable='box-forced')

  ax.set(
      ylabel='$y/R_{0}$',
      ylim=[ymin, ymax],
      xlabel='$x/R_{0}$',
      xlim=[xmin, xmax])

  sns.despine()
  fig.tight_layout()

  anim = animation.FuncAnimation(fig, animate_points_and_lines,
                                 frames=range(700, 1501, 2),
                                 blit=True)
  moviefile = fileroot + '.mp4'
  anim.save(moviefile, writer='ffmpeg', fps=60, dpi=200)
  print(moviefile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python animate-dust-bfield-stream.py 5.0 0.0 
#+END_SRC

#+RESULTS:
[[file:animate-dust-bfield-stream-b30-z0000.mp4]]

Run this in a shell
#+BEGIN_SRC sh :eval no :tangle multi-animate-bfield.sh
  for th in 0 5 15 30 45 60 75 90; do
      time python animate-dust-bfield-stream.py $th 0.0
      echo
  done
#+END_SRC

*** TODO [0/3] Apparent shapes of magnetized dust waves
**** TODO Stitching the z-planes together
+ [ ] Read the ~.npz~ files and write out a ~.fits~ file
#+BEGIN_SRC python :eval no :tangle stitch-bfield-cube.py
  import sys
  import glob
  import numpy as np
  from astropy.io import fits
  from astropy.wcs import WCS

  try:
      ANGLE = sys.argv[1]
  except:
      sys.exit(f"Usage: {sys.argv[0]} ANGLE")

  zfiles = glob.glob(f"dust-bfield-stream-b{ANGLE}-z*.npz")

  x, y = None, None
  z, zplanes = [], []
  for zfile in sorted(zfiles):
      with np.load(zfile) as data:
          zplanes.append(data['rho'])
          if x is None:
              x = data['x']
              y = data['y']
          z.append(int(zfile.split('.')[0][-4:])/100)
  z = np.array(z)
  # Add on the negative z planes by reflection symmetry about z=0
  z = np.concatenate([-z[:0:-1], z])
  zplanes = zplanes[:0:-1] + zplanes
  cube = np.stack(zplanes)

  xx = x[None, None, :]
  yy = y[None, :, None]
  zz = z[:, None, None]
  rsq = xx**2 + yy**2 + zz**2


  # Write out cube of density
  fits.PrimaryHDU(
      data=cube
  ).writeto(f"dust-bfield-b{ANGLE}-cube.fits", overwrite=True)
  # And cube of density * flux (Assuming ~ 1/R^2)
  fits.PrimaryHDU(
      data=cube/rsq
  ).writeto(f"dust-bfield-b{ANGLE}-cube-F.fits", overwrite=True)
  # And cube of density * T (Assuming T^4 ~ Flux)
  fits.PrimaryHDU(
      data=cube/rsq**0.25
  ).writeto(f"dust-bfield-b{ANGLE}-cube-T.fits", overwrite=True)
  # And cube of density * T^2 (Assuming T^4 ~ Flux)
  fits.PrimaryHDU(
      data=cube/rsq**0.5
  ).writeto(f"dust-bfield-b{ANGLE}-cube-T2.fits", overwrite=True)
#+END_SRC

#+BEGIN_SRC sh :results silent
python stitch-bfield-cube.py 30
#+END_SRC

#+BEGIN_SRC sh
open dust-bfield-b30-cube.fits
#+END_SRC

#+RESULTS:

**** TODO Projection as function of two angles 
**** TODO Distribution in planitude-alatude plane

** Dust waves revisited 
+ We need to more fully understand the coulomb collisional cross section and the grain charging
+ And we need to take into account the Lorentz force 
*** Comparing Coulomb (electrostatic) and collisional (hard sphere) drag terms
+ From Draine & Salpeter (1979) this is (for collision with protons)
  \[
  \frac{F_{es}}{F_{c}} = \phi^{2} \ln\Lambda \frac{G_{2}(s)}{G_{0}(s)}
  \]
+ \(\phi\) is the grain potential in thermal units: \(\phi = eU / k T\)
  + This is of order unity for H II regions if \(k T \approx 1 eV\) and \(U \approx 1 V\)
+ \(\Lambda\) is the plasma parameter, the number of particles in a Debye sphere: \(\Lambda \approx n r_{D}^{3}\)
  + This is \(\ln\Lambda \sim 20\), except that I am not sure if we need to include the grain charge in the equation for \(\Lambda\). If we do, then it would reduce it a bit.
    + To more like \(\ln\Lambda \sim 10\) maybe
  + We can use: \(\Lambda = \dfrac{3}{2 a e |\phi|} \left(\dfrac{k T}{\pi n}\right)^{1/2}\) (from D&S - I am assuming e is in esu)
  + => \(\ln\Lambda = 19.04 - 0.434 \log_{10} a_{0.1} \phi - 0.217 \log_{10} n\)
  + So going from n = 1 to n = 1e5 only changes this by 5%
+ \(G_{0}(s) \approx \frac{8 s}{3 \pi^{1/2}} \left(1 + \frac{9\pi}{64} s^{2}\right)^{1/2} = \frac{s}{a} \left(1 + a^{2} s^{2}\right)^{1/2} \) where \(a = 3 \pi^{1/2} / 8\)  = 0.665
+ \(G_{2}(s) \approx \frac{s}{\frac34\pi^{1/2} + s^{3}} = s / (2 a + s^{3})\)
+ So \(\dfrac{G_{2}(s)}{G_{0}(s)} = \dfrac{1}{(2 + s^{3}/a) (1 + a^{2} s^{2})^{1/2}} \)
+ This behaves somewhat like \(\dfrac{1}{2 + s^{2} + s^{4}}\)
  |      s |   Exact |     D&S |  Approx | (A-E) % | (D-E) % |
  |--------+---------+---------+---------+---------+---------|
  | 0.0001 |   0.500 |   0.500 |   0.500 |    0.00 |    0.00 |
  |    0.1 |   0.496 |   0.499 |   0.497 |    0.20 |    0.60 |
  |    0.2 |   0.484 |   0.493 |   0.490 |    1.24 |    1.86 |
  |    0.5 |   0.411 |   0.434 |   0.432 |    5.11 |    5.60 |
  |    1.0 |   0.239 |   0.238 |   0.250 |    4.60 |   -0.42 |
  |    1.5 |   0.111 |   0.100 |   0.107 |   -3.60 |   -9.91 |
  |    2.0 |   0.048 |   0.043 |   0.045 |   -6.25 |  -10.42 |
  |    2.5 |   0.022 |   0.020 |   0.021 |   -4.55 |   -9.09 |
  |    3.0 |   0.011 |   0.011 |   0.011 |    0.00 |    0.00 |
  |    4.0 |   0.004 |   0.004 |   0.004 |    0.00 |    0.00 |
  |    8.0 | 2.40e-4 | 2.39e-4 | 2.40e-4 |    0.00 |   -0.42 |
  #+TBLFM: $2=(erf($1)/$1**2 - 2exp(-$1**2)/sqrt($pi) $1) / (($1^2 + 1 - 1/4 $1**2) erf($1) + ($1 + 1 / 2 $1) exp(-$1**2) / sqrt($pi)) ;f3::$3=1/(2 + ($1**3)/0.665) sqrt(1 + 0.665**2 $1**2);f3::$4=1/(2 + $1**2 + $1**4);f3::$5=100 ($4 - $2)/$2 ;f2::$6=100 ($3 - $2)/$2 ;f2
+ Yep, that has even better agreement than the D&S approx
  + In the above table, I show
    + The exact solution with the erf and exp
    + the D&S approx with the a
    + My approx
  + Then I show percentage relative errors
    + Turns out that mine (A-E) is better than theirs (D-E) by almost a factor of 2
+ Conclusion:
  \[
  \frac{F_{es}}{F_{c}} = \frac{\phi^{2} \ln\Lambda}{2 + s^{2} + s^{4}}
  \]


**** Grain potential \phi 
+ \phi = e U / k T
  + k T = 0.69 eV @ 8000 K
+ U = Z e / a
+ e = 4.8032e-10 esu
+ 300 Volt = 1 esu (statV)
+ Examples from Akimkin 2015
  + E.g., Large Si grain @ 1 pc has charge of +100 on a grain of 0.3 micron = 3e-5 cm
    + U = 1.60106666667e-3 esu = 0.48 V => \phi = 0.7
    + At 0.1 pc this increases to +1000 => 5 V => \phi = 7.2
  + Or, Intermediate graphite grain 0.02 micron = 2e-6 cm
    + Z = +100 @ 0.1 pc => 7.2 V => \phi = 10
  + Or, very small grains graphite 30 \AA = 3e-7 cm
    + Z = +20 @ 0.1 pc => 9.6 V => \phi = 14
  + These are all for a model of RCW 120
    + T_* = 35 000 K
    + R_* = 6 R_\odot
    + n = 86 cm^-3 (although their model has only 40)
    + R = 1.5 pc
+ Material from Weingartner papers
  + Weingartner & Draine (2001)
    + Dust charge in soft-ish radiation fields
    + Mainly concentrates on interstellar field, but does do an example of H II regions
    + Everything is in terms of Habing field.  Important parameter is G T^{1/2} / n_e
    + 
  + Weingartner et al. (2006)
    + Updated yields for high energies. Deviate from previous for h\nu > 20 eV or so
    + This is important for harder spectra
    + Give examples of PNe and quasars
    + Quasar results depend on ionization parameter U = 0.1 \to 100 and T = 1e4 \to 1e6 K
      + Potential reaches 5 V for U = 0.1 and 15 V for U = 1, both at 1e4 K
      + Calculate U_in for our models, which is value at inner edge of shell:
        + U_in = S / 4 \pi R^2 c n_{sh}
        + R = x R_* where R_*^2 = L / 4 \pi c \rho v^2
        + n_sh = v^2 n / c_s^2 if cooling is strong
          + But if it is not?
          + Then, we have partial or no cooling.
          + In no-cooling case, we have n_sh = n_1 = (2-4) n (assuming M_0 > 2)
          + Partial cooling case, we could work out how far it would cool in the h \approx 0.2 R_0 thickness, and find the density accordingly.
        + Strong cooling case: U = S m c_s^2 / x^2 L
          + m c_s^2 = 2 k T
          + => U_in = (S / L) 2 k T / x^2
          + Normalize to 8000 K, 1e49 s^-1 and 1e4 L_\odot
          + => U_in = 0.578 S_49 T_8000 / x^2 L_4
          + Table
            | M/M_\odot |   L_4 |     S_49 |      \eta |    U_in | U_in(rbs) |
            |------+------+---------+--------+--------+----------|
            |   10 | 0.63 | 0.00013 | 0.0066 | 0.0181 |   0.0001 |
            |   20 | 5.45 |    0.16 | 0.1199 | 0.1415 |   0.0152 |
            |   40 | 22.2 |    1.41 | 0.4468 | 0.0822 |   0.0254 |
            |   33 | 30.2 |   0.016 | 0.3079 | 0.0010 |   0.0002 |
            #+TBLFM: $5=0.578 $3 / $4 $2;f4::$6=0.578 $3 / (1 + $4) $2;f4
        + No cooling case
          + n_sh = n_1 = 4 v^2 / (v^2 + 3 c_s^2)
          + So the c_s^2 in the previous case is replaced with
            + \frac34 c_s^2 + \frac14 v^2 = \frac14 (3 + M_0^2) c_s^2
            + U_in = (S / L) \frac12 (3 + M_0^2) k T / x^2
            + So this is (1/4) (3 + M_0^2) times the strong cooling version, where M_0 \approx v_10
              |   v | (1/4) (3 + M_0^2) |
              |-----+-----------------|
              |  20 |            1.75 |
              |  40 |            4.75 |
              |  70 |           13.00 |
              | 100 |           25.75 |
              #+TBLFM: $2=(1/4) (3 + ($1/10)**2);f2
      + Calculate U_out for the models, which is U just outside the bow shock
        + We can think of U_in as being U_0 n / n_sh, which is U_0 M_0^-2 for the strong cooling case
          + => U_0 = 0.578 S_49 T_8000 M_0^2 / x^2 L_4
        + In the same vein, the outer ionization parameter is U_out = U_0 e^{-(\tau_d + \tau_g)}
          + Where \tau_g is the gas optical depth: τ_g = -ln(1 - 𝓡/𝓕)
          + And τ_d is the dust optical depth of the bow shock shell: τ_d = (3/8) τ

              


** Finding Larmor radius


** DONE Diverging stream trajectories
CLOSED: [2017-11-17 Fri 09:15]
:LOGBOOK:
- Note taken on [2017-11-15 Wed 11:14] \\
  This is a new thing that has occurred to me.  What if the grains stream from a point source?
:END:

*** Gas-free case of diverging dust trajectories
+ The only difference from the parallel stream is that we add \theta_1 = sin^{-1} \mu b/R_0 to all the angles, where \mu = R_0/D
#+BEGIN_SRC python :tangle dust-divergent.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns

  figfile = sys.argv[0].replace('.py', '.pdf')
  NTH = 4001
  MU = 1./10.
  sns.set_style('ticks')
  sns.set_color_codes('dark')
  fig, ax = plt.subplots(figsize=(4, 4))
  blist = np.linspace(0.0, 6.0) + 0.01
  thmlist = np.arccos(1./np.sqrt(1.0 + 4.0*blist**2))
  for thm, b in zip(thmlist, blist):
      epsilon = 1./np.cos(thm)
      th1 = np.arcsin(MU*b)
      ttheta = np.linspace(0.001, min(np.pi, 2*thm - 0.001), NTH)
      im = np.argmin(np.abs(ttheta - thm))
      r = 0.5*(epsilon**2 - 1)/(epsilon*np.cos(ttheta - thm) - 1.0)
      theta = ttheta - th1
      x = r*np.cos(theta)
      y = r*np.sin(theta)
      m_in = (theta <= thm) & (y >= 0.0)
      m_out = (theta > thm) & (y >= 0.0)
      ax.plot([r[im]*np.cos(theta[im])], [r[im]*np.sin(theta[im])],
              's', ms=0.6, color='k')
      ax.plot(x[m_in], y[m_in], '-', color='gray', alpha=0.8, lw=0.5)
      ax.plot(x[m_out], y[m_out], '-', color='r', alpha=0.8, lw=0.5)
  thm_grid = np.linspace(0.0, np.pi, 200)
  rm = 2.0/(1.0 + np.cos(thm_grid))
  ecc = 1.0/(1.0 - (3/2)*MU)**(4/3)
  rmh = (1.0 + ecc)/(1.0 + ecc*np.cos(thm_grid))
  rmh[rmh < 0.0] = np.nan
  xlocus = rm*np.cos(thm_grid)
  ylocus = rm*np.sin(thm_grid)
  ax.plot(xlocus, ylocus, '-', color='k', alpha=0.2, lw=3)
  xlocus = rmh*np.cos(thm_grid)
  ylocus = rmh*np.sin(thm_grid)
  ax.plot(xlocus, ylocus, '-', color='k', alpha=0.2, lw=3)

  ax.plot([0.0], [0.0], '*', color='r')
  ax.set(xlim=[-3.1, 3.9], ylim=[-0.1, 6.9],
         xlabel="$x / R_0$",
         ylabel="$y / R_0$")
  ax.set_aspect('equal')
  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC


#+BEGIN_SRC shell :results file
python dust-divergent.py
#+END_SRC

#+RESULTS:
[[file:dust-divergent.pdf]]

* Projection of a general shape
+ The plan is to find the plane-of-sky shape (x′, y′) numerically for an arbitrary R(\theta) at a given inclination
+ This will be a check on the multi-quadric 
+ Turns out that I already did a version of this years ago in [[file:~/Work/Bowshocks/Jorge/bowshock-shape/projected/bowfuncs.py][projected/bowfuncs.py]], so I will copy routines from there and modify accordingly
+ [7/9] Plan of work for ~bow_projection.py~ and its applications
  1. [X] Implement analytic R(\theta) functions: paraboloid, wilkinoid, cantoid
  2. [X] Implement \omega(\theta)
     + Test for analytic functions
  3. [X] Implement x’_t, y’_t
     + Plot projected shapes for analytic functions
  4. [X] Implement numerical R(\theta) functions: ancantoid, dragoid
     + [X] Use spline fits to get nice smooth derivatives (use much fewer spline knots than we have theta grid points)
     + [X] Solve the problems I have at \theta = 0 and \theta \to 180
     + [X] Use equation6.py or similar for the ancantoid
     + [X] Read dragoid shapes from json files
  5. [X] Implement R_c, R_90
     + [X] Deal better with telling if we are outside the bow
     + [X] Plot diagnostic graphs
       + [X] Dragoids
       + [X] Ancantoids and cantoids
     + This might be better combined with the following step
  6. [X] Make a convenience function that will do all that is necessary to get the info for a given shape at a given inclination
     - *cancelled* This is not necessary, since much is already done by  ~characteristic_radii_projected~
     - Find the range of relevant \theta and make an array
     - Find the R_0’, R_c’, R_90’.
       - Use linear interpolation to get the exact values for \theta_90, \theta_0
       - Fit a quadratic to R’(\theta’) 
     - Calculate the (x_t’, y_t’) curve, including the bottom branch and the special points.  Also the \theta’ array
     - Return a dict with all this packaged up
  7. [ ] Include some of these graphs in the paper
     - [ ] Copy figure files
     - [ ] Write about them
  8. [X] Implement standing wave perturbations
     - [X] Write class to perturb a base shape
     - [X] Make graphs of (x, y) appearance
     - [X] Make graphs of (R_c, R_90) diagrams
  9. [ ] I need to find a better home for this work than the dust-wave file

** Copy bow projection figure files to paper folder
#+BEGIN_SRC sh :results output
  FIGFILES='test_xyprime.pdf test_xyprime_*dragoid.pdf test_xyprime_ancantoid.pdf *oid-R90-vs-Rc*.pdf compare_xyprime_wave-wilkinoid.pdf wave-R90-vs-Rc-A010-N10.pdf wave-R90-vs-Rc-A005-N20.pdf wave_xyprime-A005-N20-dragoid-alpha100.pdf wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf'
  date
  pwd
  for f in $FIGFILES; do
      cp -av $f ../papers/Paper1/figs 
  done
#+END_SRC

#+RESULTS:
#+begin_example
Sat Nov 18 20:06:51 CST 2017
/Users/will/Work/Bowshocks/Jorge/bowshock-shape/Dust-wave
test_xyprime.pdf -> ../papers/Paper1/figs/test_xyprime.pdf
test_xyprime_div_dragoid.pdf -> ../papers/Paper1/figs/test_xyprime_div_dragoid.pdf
test_xyprime_dragoid.pdf -> ../papers/Paper1/figs/test_xyprime_dragoid.pdf
test_xyprime_ancantoid.pdf -> ../papers/Paper1/figs/test_xyprime_ancantoid.pdf
ancantoid-R90-vs-Rc-a.pdf -> ../papers/Paper1/figs/ancantoid-R90-vs-Rc-a.pdf
ancantoid-R90-vs-Rc-b.pdf -> ../papers/Paper1/figs/ancantoid-R90-vs-Rc-b.pdf
ancantoid-R90-vs-Rc-lobeta-a.pdf -> ../papers/Paper1/figs/ancantoid-R90-vs-Rc-lobeta-a.pdf
dragoid-R90-vs-Rc.pdf -> ../papers/Paper1/figs/dragoid-R90-vs-Rc.pdf
three-quadric-dragoid-R90-vs-Rc.pdf -> ../papers/Paper1/figs/three-quadric-dragoid-R90-vs-Rc.pdf
wilkinoid-R90-vs-Rc-wave-A005-N20.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A005-N20.pdf
wilkinoid-R90-vs-Rc-wave-A005-N25.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A005-N25.pdf
wilkinoid-R90-vs-Rc-wave-A010-N10.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A010-N10.pdf
wilkinoid-R90-vs-Rc-wave-A010-N15.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A010-N15.pdf
wilkinoid-R90-vs-Rc-wave-A015-N07.pdf -> ../papers/Paper1/figs/wilkinoid-R90-vs-Rc-wave-A015-N07.pdf
compare_xyprime_wave-wilkinoid.pdf -> ../papers/Paper1/figs/compare_xyprime_wave-wilkinoid.pdf
wave-R90-vs-Rc-A010-N10.pdf -> ../papers/Paper1/figs/wave-R90-vs-Rc-A010-N10.pdf
wave-R90-vs-Rc-A005-N20.pdf -> ../papers/Paper1/figs/wave-R90-vs-Rc-A005-N20.pdf
wave_xyprime-A005-N20-dragoid-alpha100.pdf -> ../papers/Paper1/figs/wave_xyprime-A005-N20-dragoid-alpha100.pdf
wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf -> ../papers/Paper1/figs/wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf
#+end_example


** Utility library ~bow_projection.py~ source
#+BEGIN_SRC python :tangle bow_projection.py :eval no
  import sys
  import numpy as np
  from scipy.optimize import brentq
  from scipy.misc import derivative


  # * Module parameters
  #
  # The delta theta that is used in the central difference approximation
  # to the derivative of the R(theta) function.  For optimum balance
  # between round-off and discretization error, this should be of order
  # ~sqrt(eps)~, where ~eps~ is the machine precision
  DX_FOR_NUMERICAL_DERIVATIVE = 3.0*np.sqrt(np.finfo(1.0).resolution)

  # If True, then print out some diagnostic info
  DEBUG = False

  # * Functions to find plane-of-sky shape
  #
  # All these functions should have argument lists of the form:
  #
  # :    theta, [inc], func_R, *args_for_func_R
  #
  # where ~func_R~ has signature ~func_R(theta, *args_for_func_R)~ and
  # ~inc~ is the inclination (for those functions that depend on that).
  #
  # They should also be written as element-wise functions of a vector
  # ~theta~, so no ~if~ statements are allowed, but ~inc~ must be a
  # scalar, as must all of the extra args for ~func_R~.
  #
  def omega(theta, func_R, *args_for_func_R):
      """Find omega = R^{-1} d R/d theta 

  Note that theta may be an array. Any extra arguments are passed to
  `func_R` after `theta`

      """
      def log_R(theta, *args):
          return np.log(func_R(theta, *args))

      return derivative(log_R, theta,
                        dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)


  def alpha(theta, func_R, *args_for_func_R):
      """Find alpha = tan^{-1} |dy/dx|, the slope angle

  Note that theta may be an array. Any extra arguments are passed on to omega

      """
      om = omega(theta, func_R, *args_for_func_R)
      tan_theta = np.tan(theta)
      return np.arctan((1 + om*tan_theta)/(tan_theta - om))


  def sin_phi_t(theta, inc, func_R, *args_for_func_R):
      """Returns sin(phi_t), where phi_t is azimuth along tangent line"""
      if np.tan(inc) == 0.0:
          # Avoid NaNs in the zero inclination case
          return np.zeros_like(theta)

      om = omega(theta, func_R, *args_for_func_R)
      tan_theta = np.tan(theta)
      return np.tan(inc)*(1.0 + om*tan_theta)/(om - tan_theta) 


  def xyprime_t(theta, inc, func_R, *args_for_func_R):
      """Returns observer-frame (x', y') coordinates of tangent line"""
      R = func_R(theta, *args_for_func_R)
      sphi_t = sin_phi_t(theta, inc, func_R, *args_for_func_R)
      cos_theta, sin_theta = np.cos(theta), np.sin(theta)
      xx = cos_theta*np.cos(inc) - sin_theta*sphi_t*np.sin(inc)
      with np.errstate(all='ignore'):
          yy = sin_theta*np.sqrt(1.0 - sphi_t**2)
      R[R < 0.0] = np.nan
      return R*xx, R*yy


  def radius_of_curvature(theta, func_R, *args_for_func_R):
      """Returns R_c = (R^2 + R'^2)^{3/2} / |R^2 + 2 R'^2 - R R''| 

  Uses numerical differentiation.  NOT RECOMMENDED SINCE NOT ACCURATE ON
  THE AXIS.  Use `axis_Rc` instead.

      """
      R = func_R(theta, *args_for_func_R)
      dR = derivative(func_R, theta,
                      dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)
      d2R = derivative(func_R, theta, n=2,
                       dx=DX_FOR_NUMERICAL_DERIVATIVE, args=args_for_func_R)
      return (R**2 + dR**2)**1.5 / np.abs(R**2 + 2*dR**2 - R*d2R)


  # * Projected R_c and R_{90}
  #

  # How close we try to get to the asymptotic theta
  TOLERANCE_THETA_INFINITY = 1.e-6

  def theta_infinity(func_R, *args_for_func_R):
      """Return maximum theta where R its derivative are still finite"""
      th0, dth = 0.0, np.pi
      thinf_m = np.pi - TOLERANCE_THETA_INFINITY
      with np.errstate(all='ignore'):
          # Keep repeating on a finer and finer grid until we get to within
          # the required tolerance
          while dth > TOLERANCE_THETA_INFINITY:
              # This will divide dth by 50 on each iteration
              th, dth = np.linspace(th0, min(thinf_m, th0 + dth), retstep=True)
              # It is more stringent to insist that omega must be
              # finite, since that needs to be an extra distance (=
              # DX_FOR_NUMERICAL_DERIVATIVE) away from the asymptote in
              # order to calculate the numerical derivative
              om = omega(th, func_R, *args_for_func_R)
              # The largest th for which omega is finite must be within at most
              # (dth + DX_FOR_NUMERICAL_DERIVATIVE) of the true asymptote
              if np.isfinite(om).sum() > 0:
                  th0 = th[np.isfinite(om)].max()

      return th0



  def theta_0_90(inc, func_R, *args_for_func_R):
      """Return (theta_0, theta_90), corresponding projected x and y axes
      """

      # Easy case first
      if inc == 0.0:
          return 0.0, np.pi/2

      # Second, check tangent line existence
      th_inf = theta_infinity(func_R, *args_for_func_R)
      if np.abs(inc) > th_inf - np.pi/2:
          return np.nan, np.nan

      # Otherwise, use root finding

      tani = np.tan(inc)
      sinsq2i = np.sin(2*inc)**2
      cossqi = np.cos(inc)**2

      def _f0(theta):
          """Function that is zero at theta = theta_0"""
          om = omega(theta, func_R, *args_for_func_R)
          return np.sin(theta)*(1.0 - om*tani) - np.cos(theta)*(om + tani)

      def _f90(theta):
          """Function that is zero at theta = theta_90"""
          om = omega(theta, func_R, *args_for_func_R)
          return (1.0/np.tan(theta)
                  - (1.0 - np.sqrt(1.0 + om**2 * sinsq2i))/(2*om*cossqi))

      th_inf = theta_infinity(func_R, *args_for_func_R)
      # If the inclination is too high, then there may be no solution
      if np.abs(inc) > th_inf - np.pi/2:
          return np.nan, np.nan

      # The theta_0 value could be anywhere in range 0 -> th_inf, but we
      # set the lower limit higher than that to avoid some rare errors.
      # This should be alright unless R_c/R_0 < 0.1, which is not true
      # for any of the models I am interested in
      th1, th2 = 0.001*inc, th_inf
      # Make sure we do indeed bracket the root
      if _f0(th1)*_f0(th2) <= 0.0:
          # And use Brent's method to find the root
          th0 = brentq(_f0, th1, th2)
      else:
          th0 = np.nan

      # Repeat for the theta_90 value, which must be higher than theta_0
      th1, th2 = 1.001*th0, th_inf
      if _f90(th1)*_f90(th2) <= 0.0:
          th90 = brentq(_f90, th1, th2)
      else:
          th90 = np.nan
          
      return th0, th90

  # Maximum angle used in fitting Rc'
  DELTA_THETA_RC = np.radians(30.0)
  # Degree of theta'^2 polynomial used in fitting R'(theta') @ theta' = 0
  DEGREE_POLY_NEIGHBORHOOD = 1

  # Maximum angle used in fitting R90'
  DELTA_THETA_R90 = np.radians(5.0)
  # Same for around theta' = 90.  These need to be different since we
  # are fitting a polynomial in just theta' instead of theta'^2
  DEGREE_POLY_NEIGHBORHOOD_90 = 2

  def characteristic_radii_projected_new(inc, func_R, *args_for_func_R):
      """Return all the characteristic radii for projected bow shock

      Returns dict of 'R_0 prime', 'tilde R_c prime', 'theta_0', 'tilde
      R_90 prime', 'theta_90'.  This is a new implementation, since I am
      getting fed up with the previous implementation (see
      'characteristic_radii_projected').  Tha main difference is
      that we define the neighborhood in terms of th-prime instead of
      th.
      """
      # Zeroth step, check that we do have a tangent line
      th_inf = theta_infinity(func_R, *args_for_func_R)

      # What to return when there is no solution 
      no_solution = {'R_0 prime': np.nan, 'theta_inf': th_inf,
                     'tilde R_c prime': np.nan, 'theta_0': np.nan,
                     'tilde R_90 prime': np.nan, 'theta_90': np.nan}

      if np.abs(inc) > th_inf - np.pi/2:
          # No tangent line, so return all NaNs
          return no_solution

      th0, th90 = theta_0_90(inc, func_R, *args_for_func_R)
      th = np.linspace(th0, th_inf, 1001)
      xp, yp = xyprime_t(th, inc, func_R, *args_for_func_R)
      m = np.isfinite(xp) & np.isfinite(yp)
      # Reflect to give full projected bow
      xxp = np.concatenate((xp[m][::-1], xp[m]))
      yyp = np.concatenate((-yp[m][::-1], yp[m]))

      # Polar coordinates on plane of sky
      Rp = np.hypot(xxp, yyp)
      thp = np.arctan2(yyp, xxp)

      # Now fit R'(th') around th' = 0 to determine R_0' and R_c'
      m = np.isfinite(Rp*thp) & (np.abs(thp) < DELTA_THETA_RC)
      if m.sum() <= 3*DEGREE_POLY_NEIGHBORHOOD:
          # If not enough good points, then give up
          return no_solution

      # Fit R' with a polynomial in (theta')^2, and use the constant and
      # linear coefficients to find the projected R_0 and R_c
      coeffs = np.polyfit(thp[m]**2, Rp[m],
                          deg=DEGREE_POLY_NEIGHBORHOOD)
      R0_prime = coeffs[-1]
      gamma = coeffs[-2]/coeffs[-1]
      Rc_prime = 1./(1. - 2*gamma)

      # Next, R90'
      m = np.isfinite(Rp*thp) & (np.abs(thp - 0.5*np.pi) < DELTA_THETA_R90)

      # **************** 29 Nov 2017: TO FINISH ****************
      pass

  # Number of neighborhood points to use when fitting around projected
  # axes (theta' = 0 and theta' = 90)
  N_NEIGHBORHOOD = 50
  # Theta scale of neighborhood around theta' = 0 in units of (th90 - th0)
  SCALE_NEIGHBORHOOD = 0.2
  SCALE_NEIGHBORHOOD_90 = 0.03

  def characteristic_radii_projected(inc, func_R, *args_for_func_R):
      """Return all the characteristic radii for projected bow shock

  Returns dict of 'R_0 prime', 'tilde R_c prime', 'theta_0', 'tilde R_90
  prime', 'theta_90'

      """

      # Zeroth step, check that we do have a tangent line
      th_inf = theta_infinity(func_R, *args_for_func_R)

      # What to return when there is no solution 
      no_solution = {'R_0 prime': np.nan, 'theta_inf': th_inf,
                     'tilde R_c prime': np.nan, 'theta_0': np.nan,
                     'tilde R_90 prime': np.nan, 'theta_90': np.nan}

      if np.abs(inc) > th_inf - np.pi/2:
          # No tangent line, so return all NaNs
          return no_solution

      # First, the quantities at th0, which is theta on the projected
      # symmetry axis (y' = 0) for this inclination
      th0, th90 = theta_0_90(inc, func_R, *args_for_func_R)

      # Make a grid of theta in the neighborhood of th0
      #
      # Earlier, I was using (pi - th0), which I am now (29 Nov 2017)
      # changing to (th90 - th0), so I multiply by 2 to maintain the
      # same scale in the case of i=0.  So if we want dtheta interval,
      # we need to put SCALE_NEIGHBORHOOD = dtheta/180, so 0.33 is 60
      # degrees
      dth = 2*SCALE_NEIGHBORHOOD*(th90 - th0)
      th = np.linspace(th0, th0 + dth, N_NEIGHBORHOOD)
      if DEBUG:
          print("theta", th, file=sys.stderr)
          print("R", func_R(th, *args_for_func_R), file=sys.stderr)
          print("sin(phi_t)", sin_phi_t(th, inc, func_R, *args_for_func_R),
                file=sys.stderr)

      # Now find the tangent line and convert back to polar coordinates
      xprime, yprime = xyprime_t(th, inc, func_R, *args_for_func_R)
      Rprime = np.hypot(xprime, yprime)
      thprime = np.arctan2(yprime, xprime)
      if DEBUG:
          print("x'", xprime, file=sys.stderr)
          print("y'", yprime, file=sys.stderr)
          print("R'", Rprime, file=sys.stderr)
          print("theta'", thprime, file=sys.stderr)
      # Filter out any NaNs in the projected coordinates
      m = np.isfinite(Rprime*thprime)
      if m.sum() <= 3*DEGREE_POLY_NEIGHBORHOOD:
          # If not enough good points, then give up
          return no_solution

      # Fit R' with a cubic in (theta')^2, and use the constant and
      # linear coefficients to find the projected R_0 and R_c
      #
      # It seems to be enough to use deg=2 on 8 points
      coeffs = np.polyfit(thprime[m]**2, Rprime[m],
                          deg=DEGREE_POLY_NEIGHBORHOOD)
      R0_prime = coeffs[-1]
      gamma = coeffs[-2]/coeffs[-1]
      Rc_prime = 1./(1. - 2*gamma)
      if DEBUG:
          print("Polynomial coefficients", coeffs/coeffs[-1], file=sys.stderr)


      # Second, the quantities at th90, which is the theta on the projected
      # perpendicular axis (x' = 0)
      dth = SCALE_NEIGHBORHOOD_90*np.pi/2
      th = np.linspace(th90 - dth/2, th90 + dth/2, N_NEIGHBORHOOD)
      xprime, yprime = xyprime_t(th, inc, func_R, *args_for_func_R)
      Rprime = np.hypot(xprime, yprime)
      thprime = np.arctan2(yprime, xprime)
      if DEBUG:
          print("90 x'", xprime, file=sys.stderr)
          print("90 y'", yprime, file=sys.stderr)
          print("90 R'", Rprime, file=sys.stderr)
          print("90 theta'", thprime, file=sys.stderr)
      m = np.isfinite(Rprime*thprime)
      if m.sum() <= 3*DEGREE_POLY_NEIGHBORHOOD_90:
          # If not enough good points, then give up
          return no_solution
      # Fit a polynomial to thprime, Rprime in the vecinity of pi/2
      p = np.poly1d(np.polyfit(thprime[m], Rprime[m],
                               deg=DEGREE_POLY_NEIGHBORHOOD_90))
      # Evaluate polynomial at pi/2 to find R90_prime
      R90_prime = p(np.pi/2)/R0_prime
      if DEBUG:
          print("90 Polynomial coefficients", coeffs/coeffs[-1], file=sys.stderr)

      return {'R_0 prime': R0_prime, 'theta_inf': th_inf,
              'tilde R_c prime': Rc_prime, 'theta_0': th0,
              'tilde R_90 prime': R90_prime, 'theta_90': th90}



  # * Example analytic shape functions
  #

  def wilkinoid_R_theta(theta):
      """Wilkin solution for wind-stream interaction"""
      # Convert to array if scalar
      theta = np.atleast_1d(theta)
      # Equation (9) of Wilkin (1996)
      R = np.sqrt(3*(1.0 - theta/np.tan(theta)))/np.sin(np.abs(theta))
      # Equation is not stable for very small theta, so we use a Taylor
      # expansion instead
      small_angle = np.abs(theta) < 1e-5
      R[small_angle] = 1.0 + 0.2*theta[small_angle]**2
      return R

  def cantoid_R_theta(theta, beta):
      """Cantoid solution from CRW for wind-wind interaction

  Returns R(theta), normalized to the stagnation radius. Extra parameter
  `beta` is the momentum ratio of the two winds.  Note that this will
  not be accurate if beta is too close to zero, but it seems to be OK
  with beta >= 1.e-6.  For lower values than this, the results will be
  almost identical to the Wilkinoid, so `wilkinoid_R_theta` should be
  used instead.

      """

      theta = np.atleast_1d(theta)

      # Approximate solution for theta_1, the polar angle measured from
      # the "other" star
      theta1 = np.sqrt(7.5*(-1.0 + np.sqrt(
          1.0 + 0.8*beta*(1.0 - theta/np.tan(theta)))))
      # Make sure theta1 and theta have the same sign
      theta1 *= np.sign(theta)


      # On-axis (theta = 0) radius to stagnation point, in units of
      # star-star separation D
      R0 = np.sqrt(beta)/(1.0+np.sqrt(beta))

      R = np.where(np.abs(theta + theta1) > np.pi,
                   # theta > theta_inf => no solution
                   np.nan,
                   # theta <= theta_inf => return radius in units of R0
                   np.sin(theta1) / np.sin(theta + theta1) / R0)

      # Replace with Taylor expansion close to axis
      C = (1.0 - beta)/30.0
      gamma = C/(1.0 + np.sqrt(beta)) + (1.0 + 2*np.sqrt(beta))/6
      small_angle = np.abs(theta) < 1.e-5
      R[small_angle] = 1.0 + gamma*theta[small_angle]**2

      return R


  def paraboloid_R_theta(theta):
      """This is the special parabola with Rc = 2"""
      return 2.0 / (1.0 + np.cos(theta))


  def paraboloid_omega_true(theta):
      """Analytic omega for special parabola"""
      return np.sin(theta)  / (1.0 + np.cos(theta))


  # * Non-analytic shape functions
  #
  # These are bow shock shapes for which it is "non-trivial" to
  # calculate each R(theta).  E.g., requiring numerical root finding, so
  # hard to write naturally in an element-wise vector form
  #
  # For efficiency, we therefore calculate R(theta) once on a grid, and
  # then use a spline interpolation for fast subsequent evaluation
  # of R(theta) and its derivative

  import scipy.interpolate

  class _Spline_R_theta(object):
      """Base class for non-analytic shapes

  The R(theta) shape is initialized once on a grid when the class is
  instantiated, and fitted by a B-spline.  The object can then be called
  as a function of theta, which will be very fast since it just
  evaluates the B-spline.

      """

      thgrid = None
      Rgrid = None
      def _init_grid(self, ngrid, **shape_kwds):
          raise NotImplementedError("Override this method in a sub-class")

      def _init_spline(self, kspline, Rmax, smooth):
          """Fit a smoothing spline to the R(theta) grid. 

  We fit B-splines to the parametric [x(theta), y(theta)] representation
  of the bow shock. `kspline` is the order of the splines (default:
  cubic). `Rmax` is the maximum radius to be included in the spline fit.
  `smooth` is the spline smoothing condition (see docs for
  `scipy.interpolate.splprep`).

          """
          mgood = np.isfinite(self.Rgrid) & (self.Rgrid <= Rmax)
          x = self.Rgrid[mgood]*np.cos(self.thgrid[mgood])
          y = self.Rgrid[mgood]*np.sin(self.thgrid[mgood])
          self.spline_tck, u = scipy.interpolate.splprep(
              [x, y], u=self.thgrid[mgood], k=kspline, s=smooth)

      def __call__(self, theta):
          """Evaluate R(theta) from spline interpolation"""
          theta = np.atleast_1d(theta)
          x, y = scipy.interpolate.splev(theta, self.spline_tck, ext=1)
          # The ext=1 option to splev return 0 for points outside range of theta
          R = np.hypot(x, y)
          # Then we set those out-of-bound points to NaN
          R[(x == 0.0) & (y == 0.0)] = np.nan
          return R

      def __init__(self, ngrid=100, kspline=3, Rmax=100, smooth=0, **shape_kwds):
          """"""
          # Set up grids of theta and R
          self._init_grid(ngrid, **shape_kwds)
          # Set up spline interpolation
          self._init_spline(kspline, Rmax, smooth)


  class Spline_R_theta_from_function(_Spline_R_theta):
      """Spline-interpolated bow shock shape from explicit function

  Extra parameters for initialization: `shape_func` and
  `shape_func_pars`. THIS IS FOR TESTING ONLY!!! It checks that the
  interpolation machinery works for simple shapes. Outside of such
  tests, there is really no need to use the spline interpolation for
  these cases.

      """

      def _init_grid(self, ngrid,
                     shape_func=paraboloid_R_theta,
                     shape_func_pars=()):
          # Include the negative branch so the spline will have the
          # right gradient on the axis
          self.th_inf = theta_infinity(shape_func, *shape_func_pars)
          self.thgrid = np.linspace(0.0, self.th_inf, ngrid)
          self.Rgrid = shape_func(self.thgrid, *shape_func_pars)


  class Spline_R_theta_from_grid(_Spline_R_theta):
      """Spline-interpolated bow shock shape from user-specified arrays

  Extra parameters for initialization: `theta_grid` and `R_grid`.  This
  is the main way that the spline fits will be used.

      """
      def _init_grid(self, ngrid, theta_grid=None, R_grid=None):
          # Note that ngrid is ignored in this implementation
          if theta_grid is not None and R_grid is not None:
              self.thgrid = theta_grid
              self.Rgrid = R_grid
          else:
              raise ValueError("Both theta_grid and R_grid must be specified")


  # * Basic tests of functionality
  #

  if __name__ == "__main__":
      import sys
      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')

      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(0.0, np.pi, 501)
      th_dg = np.degrees(th)
      ax.plot(th_dg, omega(th, paraboloid_R_theta),
              label="paraboloid")
      ax.plot(th_dg, omega(th, wilkinoid_R_theta),
              label="wilkinoid")
      for beta in 0.001, 0.01, 0.1:
          ax.plot(th_dg, omega(th, cantoid_R_theta, beta),
                  label=fr"cantoid $\beta = {beta:.3f}$")
      ax.legend(title=r"Analytic $R(\theta)$ functions")
      ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
      ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
      ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
      ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
          xlim=[0, 180],
          ylim=[0.0, 2e2],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      figfile = f"test_{lib_name}_omega.pdf"
      fig.savefig(figfile)
      print(figfile, end='')
#+END_SRC


** Test the ~bow_projection~ library

*** Tests of analytic shapes
**** Basic test of omega(theta) for analytic shape
This is included in the module itself.  Note the ~symlog~ y-axis, which is linear from 0 \to 1 and then logarithmic from 1 \to 200
#+BEGIN_SRC sh :results file
  python bow_projection.py
#+END_SRC

#+RESULTS:
[[file:test_bow_projection_omega.pdf]]

**** Test of \phi_t
#+BEGIN_SRC python :eval no :tangle test_phi_t.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import sin_phi_t, paraboloid_R_theta, theta_infinity, theta_0_90

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(5, 5))

  inclinations = [0, 15, 30, 45, 60, 75]
  colors = sns.color_palette(n_colors=len(inclinations))
  th_inf = theta_infinity(paraboloid_R_theta)
  for inc_dg, color in zip(inclinations, colors):
      inc = np.radians(inc_dg)
      th0, th90 = theta_0_90(inc, paraboloid_R_theta)
      th = np.linspace(th0, th_inf, 501)
      th_dg = np.degrees(th)
      print("theta:", th_dg, file=sys.stderr)
      sphit = sin_phi_t(th, inc, paraboloid_R_theta)
      print("sphit:", sphit, file=sys.stderr)
      phit_dg = np.degrees(np.arcsin(sphit))
      print("phi:", phit_dg, file=sys.stderr)
      ax.plot(th_dg, phit_dg, label=f"inc = {inc_dg:d}", color=color)

  ax.legend(title="paraboloid")
  ax.set(
      xlabel=r"$\theta$",
      ylabel=r"$\phi_t$",
      xlim=[0, 180],
      ylim=[-90, 90],
      xticks=[0, 30, 60, 90, 120, 150, 180],
      yticks=[-90, -60, -30, 0, 30, 60, 90],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_phi_t.py
#+END_SRC

#+RESULTS:
[[file:test_phi_t.pdf]]

**** Test of plane-of-sky shape
#+BEGIN_SRC python :eval no :tangle test_xyprime.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              paraboloid_R_theta, wilkinoid_R_theta,
                              cantoid_R_theta)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  inclinations = [0, 15, 30, 45, 60.1, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for shape_name, ax, R_theta, extra_pars in [
          ["Paraboloid", axes[0, 0], paraboloid_R_theta, ()],
          ["Wilkinoid", axes[0, 1], wilkinoid_R_theta, ()],
          ["Cantoid\n" r"$\beta = 0.001$", axes[1, 0], cantoid_R_theta, (0.001,)],
          ["Cantoid\n" r"$\beta = 0.01$", axes[1, 1], cantoid_R_theta, (0.01,)],
  ]:
      th_inf = theta_infinity(R_theta, *extra_pars)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, R_theta, *extra_pars)
          th = np.linspace(th0, th_inf, 101)
          xp, yp = xyprime_t(th, inc, R_theta, *extra_pars)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          R0p = xxp.max()
          ax.plot(xxp/R0p, yyp/R0p, label=fr"$i = {int(inc_dg):d}^\circ$", lw=1.5*lw, color=color)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=shape_name, ncol=2, fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )
  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime.pdf]]


*** Test of spline fits to analytic shapes

**** R(\theta) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_spline_radius.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (omega, paraboloid_R_theta,
                              wilkinoid_R_theta, cantoid_R_theta,
                              Spline_R_theta_from_function)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)

  for label, func, pars, ngrid, s in [
          ["paraboloid", paraboloid_R_theta, (), 101, 1.0],
          ["Wilkinoid", wilkinoid_R_theta, (), 101, 0],
          [r"Cantoid $\beta = 0.001$", cantoid_R_theta, (0.001,), 101, 0],
          [r"Cantoid $\beta = 0.01$", cantoid_R_theta, (0.01,), 101, 0],
          [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 101, 0],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      ax.plot(th_dg, func(th, *pars), color='b', alpha=0.2, lw=2, label='_nolabel_')
      ax.plot(th_dg, spline_func(th), lw=0.8, label=label)

  ax.legend(title=r"Spline approximations")
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$R$",
      xlim=[0, 180],
      yscale='log',
      ylim=[0.9, 200.0],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python test_spline_radius.py
#+END_SRC

#+RESULTS:
[[file:test_spline_radius.pdf]]


**** \omega(\theta) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_spline.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (omega, paraboloid_R_theta,
                              wilkinoid_R_theta, cantoid_R_theta,
                              Spline_R_theta_from_function)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(0, np.pi, 10001)
  th_dg = np.degrees(th)

  for label, func, pars, ngrid, s in [
          ["paraboloid", paraboloid_R_theta, (), 1001, 0],
          ["Wilkinoid", wilkinoid_R_theta, (), 1001, 0],
          [r"Cantoid $\beta = 0.001$", cantoid_R_theta, (0.001,), 1001, 0],
          [r"Cantoid $\beta = 0.01$", cantoid_R_theta, (0.01,), 1001, 0],
          [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 1001, 0],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      ax.plot(th_dg, omega(th, func, *pars), color='b', alpha=0.2, lw=2, label='_nolabel_')
      ax.plot(th_dg, omega(th, spline_func), lw=0.8, label=label)

  ax.legend(title=r"Spline approximations")
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
  ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
  ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
      xlim=[0, 180],
      ylim=[0.0, 2e2],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python test_spline.py
#+END_SRC

#+RESULTS:
[[file:test_spline.pdf]]

The same but for the slope angle

#+BEGIN_SRC python :eval no :tangle test_slope.py
    import sys
    import numpy as np
    from matplotlib import pyplot as plt
    import seaborn as sns
    from bow_projection import (omega, paraboloid_R_theta, alpha,
                                wilkinoid_R_theta, cantoid_R_theta,
                                Spline_R_theta_from_function)

    figfile = sys.argv[0].replace('.py', '.pdf')

    sns.set_style('ticks')
    fig, ax = plt.subplots()

    th = np.linspace(0, np.pi, 10001)
    th_dg = np.degrees(th)

    for label, func, pars, ngrid, s in [
            ["paraboloid", paraboloid_R_theta, (), 1001, 0],
            ["Wilkinoid", wilkinoid_R_theta, (), 1001, 0],
            [r"Cantoid $\beta = 0.001$", cantoid_R_theta, (0.001,), 1001, 0],
            [r"Cantoid $\beta = 0.01$", cantoid_R_theta, (0.01,), 1001, 0],
            [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 1001, 0],
    ]:
        spline_func = Spline_R_theta_from_function(
            ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
        alpha_slope = np.degrees(alpha(th, func, *pars))
        alpha_slope_spline = np.degrees(alpha(th, spline_func))
        ax.plot(th_dg, (90 - alpha_slope)/th_dg, 
                color='b', alpha=0.2, lw=2, label='_nolabel_')
        ax.plot(th_dg, (90 - alpha_slope_spline)/th_dg,
                lw=0.8, label=label)

    ax.legend(title=r"Spline approximations")
    ax.set(
        xlabel=r"Polar angle: $\theta$, degrees",
        ylabel=r"Slope angle, $(90 - \alpha) / \theta$",
        xlim=[0, 180],
        ylim=[0.0, 1.1],
        xticks=[0, 30, 60, 90, 120, 150, 180],
    )
    sns.despine()
    fig.tight_layout()
    fig.savefig(figfile)
    print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python test_slope.py
#+END_SRC

#+RESULTS:
[[file:test_slope.pdf]]


**** (x_t’, y_t’) spline fit to function
#+BEGIN_SRC python :eval no :tangle test_xyprime_spline.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected,
                              Spline_R_theta_from_function,
                              paraboloid_R_theta, wilkinoid_R_theta,
                              cantoid_R_theta)

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for label, ax, func, pars, ngrid, s in [
          ["paraboloid", axes[0, 0], paraboloid_R_theta, (), 1001, 0],
          ["Wilkinoid", axes[0, 1], wilkinoid_R_theta, (), 1001, 0],
          [r"Cantoid $\beta = 0.001$", axes[1, 0], cantoid_R_theta, (0.001,), 1001, 0],
          [r"Cantoid $\beta = 0.01$", axes[1, 1], cantoid_R_theta, (0.01,), 1001, 0],
          # [r"Cantoid $\beta = 0.1$", cantoid_R_theta, (0.1,), 101, 1e-10],
  ]:
      spline_func = Spline_R_theta_from_function(
          ngrid=ngrid, smooth=s, shape_func=func, shape_func_pars=pars)
      th_inf = theta_infinity(spline_func)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, spline_func)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, spline_func)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, spline_func)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_spline.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_spline.pdf]]



** Dragoid application of ~bow_projection~ library

#+BEGIN_SRC python :eval no :tangle dragoid_shape.py
  import sys
  import numpy as np
  from astropy.table import Table
  import statsmodels.api as sm
  from bow_projection import Spline_R_theta_from_grid

  class Dragoid(object):
      def __init__(self, alpha, mu=None, lowess_frac=None):
          if mu is None:
              astring = 'dust-couple-stream'
          else:
              astring = 'dust-couple-div-stream'
          astring += f'-alpha{int(100*alpha):03d}'
          if mu is not None:
              astring += f'-mu{int(100*mu):03d}'
          astring += '.tab'
          self.label = fr"$\alpha_\mathrm{{drag}} =  {alpha:.02f}$"
          if mu is not None:
              self.label += ', ' + fr"$\mu =  {mu:.02f}$"
          t = Table.read(astring, format='ascii.tab')
          dth = np.pi/len(t)
          self.thgrid = t['theta'] + 0.5*dth
          self.Rgrid = t['R']/t['R'][0]
          self.thgrid = np.concatenate([-self.thgrid[::-1], self.thgrid])
          self.Rgrid = np.concatenate([self.Rgrid[::-1], self.Rgrid])
          if lowess_frac is not None:
              # Optionally smooth the shape before fitting spline
              Rsmooth = sm.nonparametric.lowess(
                  self.Rgrid, self.thgrid, frac=lowess_frac,
                  is_sorted=True, return_sorted=False)
              # Gradually transition between smooth version for low
              # theta and the original version for theta > 60.0 deg
              smooth_mix = np.exp(-(self.thgrid/np.radians(45.0))**2)
              self.Rgrid = self.Rgrid*(1. - smooth_mix) + Rsmooth*smooth_mix
          self.splinefit = Spline_R_theta_from_grid(
                theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the spline fitted result
          return self.splinefit(theta)

  if __name__ == "__main__":

      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')
      figfile = f"test_{lib_name}_radius.pdf"

      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(-np.pi, np.pi, 1001)
      th_dg = np.degrees(th)

      alphas = [0.25, 0.5, 1.0, 2.0] + [4.0, 4.0]
      mus = [None]*4 + [0.2, 0.8]
      for alpha, mu in zip(alphas, mus):
          shape = Dragoid(alpha=alpha, mu=mu, lowess_frac=0.1)
          ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
                  color='b', alpha=0.2, lw=2, label='_nolabel_')
          ax.plot(th_dg, shape(th), lw=0.8, label=shape.label)

      ax.legend(title=r"Dragoid shapes")
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$R$",
          xlim=[0, 180],
          yscale='log',
          ylim=[0.9, 200.0],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      fig.savefig(figfile)
      print(figfile, end='')

#+END_SRC

**** Test R(\theta) spline fit to dragoid
#+BEGIN_SRC sh :results file
python dragoid_shape.py
#+END_SRC

#+RESULTS:
[[file:test_dragoid_shape_radius.pdf]]

**** DONE Test \alpha(\theta) for dragoid
CLOSED: [2017-11-18 Sat 20:07]
:LOGBOOK:
- Note taken on [2017-11-18 Sat 11:58] \\
  I need to get to the bottom of why the R_c fits for the dragoids are so dependent on the \Delta\theta and order of polynomial
:END:

We are actually plotting \((90 - \alpha) / \theta\)
#+BEGIN_SRC python :eval no :tangle dragoid_slope_angle.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  from dragoid_shape import Dragoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(10, 4))

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)

  alpha_drags = [0.25, 1.0] + [1.0, 1.0, 4.0, 4.0]
  mus = [None]*2 + [.05, 0.2, 0.2, 0.8]

  for alpha_drag, mu in zip(alpha_drags, mus):
      shape = Dragoid(alpha=alpha_drag, mu=mu, lowess_frac=0.1)
      alpha_slope = np.degrees(bp.alpha(shape.thgrid, shape))
      fac = (90.0 - alpha_slope)/np.degrees(shape.thgrid)
      ax.plot(np.degrees(shape.thgrid), fac,
              lw=0.8, label=shape.label)

  ax.legend(title=r"Dragoid shapes")
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"Slope angle, $(90 - \alpha)/\theta$",
      xlim=[0, 180],
      ylim=[0, 1.1],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python dragoid_slope_angle.py
#+END_SRC

#+RESULTS:
[[file:dragoid_slope_angle.pdf]]

**** Test (x_t’, y_t’) for dragoid
#+BEGIN_SRC python :eval no :tangle test_xyprime_dragoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from dragoid_shape import Dragoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  # For some reason, exactly 30.0 had problems with R0p
  inclinations = [0.0, 15.0, 30.01, 45.0, 60.0, 75.01]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for alpha, ax in zip([0.25, 0.5, 1.0, 2.0], axes.flat):
      shape = Dragoid(alpha=alpha, lowess_frac=0.1)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)        
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:.0f}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title="Dragoid " + shape.label,
                fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                ncol=2, loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )

  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_dragoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_dragoid.pdf]]

#+BEGIN_SRC python :eval no :tangle test_xyprime_div_dragoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from dragoid_shape import Dragoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  # For some reason, exactly 30.0 had problems with R0p
  inclinations = [0.0, 15.0, 30.01, 45.0, 60.0, 75.01]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  # alphas = [1.0, 1.0, 2.0, 2.0]
  # mus = [0.05, 0.2, 0.05, 0.2]
  alphas = [1.0, 1.0, 4.0, 4.0]
  mus = [0.05, 0.2, 0.2, 0.8]
  for alpha, mu, ax in zip(alphas, mus, axes.flat):
      shape = Dragoid(alpha=alpha, mu=mu, lowess_frac=0.1)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)        
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:.0f}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title="Dragoid\n" + shape.label,
                fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                ncol=2, loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')
  axes[-1, 0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )

  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_div_dragoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_div_dragoid.pdf]]

** Ancantoid application of ~bow_projection~ library

*** Spline fit to ancantoid shape

+ [ ] Cache the shape to a file 

#+BEGIN_SRC python :eval no :tangle ancantoid_shape.py
  import sys
  import json
  import numpy as np
  from bow_projection import Spline_R_theta_from_grid
  sys.path.append("../CRW-shapes")
  import equation6

  DEBUG = False


  class Ancantoid(object):
      def __init__(self, xi, beta, n=101):
          if DEBUG:
              print("Initialising Ancantoid(xi={xi:.2g}, beta={beta:.2g}, n={n})",
                    file=sys.stderr)
          self.xi = xi
          self.beta = beta
          self.n = n
          self.thgrid = np.linspace(0.0, np.pi, n)
          try:
              # First, look for cached file
              self._load_Rgrid_from_cache()
          except:
              # Failing that, use equation6 to find grid of R, theta
              self.shell = equation6.Shell(innertype='anisotropic', beta=beta, xi=xi)
              self.Rgrid = self.shell.radius(self.thgrid) / self.shell.R0
              self._save_Rgrid_to_cache()

          if DEBUG:
              print("thgrid =", self.thgrid, file=sys.stderr)
              print("Rgrid = ", self.Rgrid, file=sys.stderr)
          # Then set up the spline fit to the grid points
          self.splinefit = Spline_R_theta_from_grid(
              theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the spline fitted result
           return self.splinefit(theta)

      def _load_Rgrid_from_cache(self):
          with open(self._cache_filename()) as f:
              data = json.load(f)
          self.thgrid = np.array(data['theta'])
          self.Rgrid = np.array(data['R'])

      def _save_Rgrid_to_cache(self):
          data = {'theta': list(self.thgrid), 'R': list(self.Rgrid)}
          with open(self._cache_filename(), 'w') as f:
              json.dump(data, f, indent=4)

      def _cache_filename(self, suffix=".json"):
          fn = "ancantoid"
          fn += f"-xi{int(100*self.xi):03d}"
          fn += f"-beta{int(100000*self.beta):06d}"
          fn += f"-n{self.n:05d}"
          fn += suffix
          return fn


  if __name__ == "__main__":

      from matplotlib import pyplot as plt
      import seaborn as sns

      lib_name = sys.argv[0].replace('.py', '')
      figfile = f"test_{lib_name}_radius.pdf"
      

      sns.set_style('ticks')
      fig, ax = plt.subplots()

      th = np.linspace(-np.pi, np.pi, 1001)
      th_dg = np.degrees(th)

      for xi, beta in [[0.8, 0.001],
                       [0.8, 0.01],
                       [0.8, 0.1],
                       [0.4, 0.001],
                       [0.4, 0.01],
                       [0.4, 0.1],]:
          label = fr"$\beta = {beta:.3f}$, $\xi = {xi:.1f}$"
          shape = Ancantoid(xi=xi, beta=beta)
          ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
                  color='b', alpha=0.2, lw=2, label='_nolabel_')
          ax.plot(th_dg, shape(th), lw=0.8, label=label)

      ax.legend(title=r"Ancantoid shapes")
      ax.set(
          xlabel=r"Polar angle: $\theta$, degrees",
          ylabel=r"$R$",
          xlim=[0, 180],
          yscale='log',
          ylim=[0.9, 200.0],
          xticks=[0, 30, 60, 90, 120, 150, 180],
      )
      sns.despine()
      fig.tight_layout()
      fig.savefig(figfile)
      print(figfile, end='')

#+END_SRC


**** Test R(\theta) spline fit to ancantoid
#+BEGIN_SRC sh :results file
python ancantoid_shape.py
#+END_SRC

#+RESULTS:
[[file:test_ancantoid_shape_radius.pdf]]


**** Test (x_t’, y_t’) for ancantoid

***** \xi = 0.8, 0.4
#+BEGIN_SRC python :eval no :tangle test_xyprime_ancantoid.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from ancantoid_shape import Ancantoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for xi, beta, ax in [[0.8, 0.001, axes[0, 0]],
                       [0.8, 0.1, axes[0, 1]],
                       [0.4, 0.001, axes[1, 0]],
                       [0.4, 0.1, axes[1, 1]],]:

      label = "Ancantoid\n" fr"$\beta = {beta:.3f}$, $k = {2/xi - 2:.1f}$"
      shape = Ancantoid(xi=xi, beta=beta)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )
  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_ancantoid.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_ancantoid.pdf]]


***** \xi = 1.0
+ This behaves strangely because of the discontinuity in the slope at \theta = \pi/2
#+BEGIN_SRC python :eval no :tangle test_xyprime_ancantoid_xi10.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from ancantoid_shape import Ancantoid

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  for xi, beta, ax in [[1.0, 0.001, axes[0, 0]],
                       [1.0, 0.02, axes[0, 1]],
                       [1.0, 0.05, axes[1, 0]],
                       [1.0, 0.1, axes[1, 1]],]:

      label = fr"Ancantoid $\beta = {beta:.3f}$, $\xi = {xi:.1f}$"
      shape = Ancantoid(xi=xi, beta=beta, n=301)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=2, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_ancantoid_xi10.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_ancantoid_xi10.pdf]]


** Diagnostic plots with the ~bow_projection~ library
This is what we have been working towards


*** Library ~bow_diagnostic.py~ for finding (R_c, R_90)

#+BEGIN_SRC python :eval yes :return result :tangle bow_diagnostic.py
  import numpy as np
  from astropy.table import Table
  import bow_projection as bp

  def parameter_table(inclinations, shape, *shape_args):
      """Diagnostic parameters for `inclinations` from `shape`

  Input argument `inclinations` should be a vector of angles (in
  radians) and input argument `shape` should be callable to give
  R(theta), optionally with additional arguments `shape_args`.  Example
  functions suitable for passing as `shape` can be found in the
  `bow_projection` module.

  Returns an `astropy.table.Table` of characteristic angles and radii.

      """
      rows = [bp.characteristic_radii_projected(inc, shape, *shape_args)
              for inc in inclinations]
      tab = Table(rows=rows)
      tab['inc'] = inclinations
      # Number formatting in output
      for k in tab.colnames:
          if 'theta' in k or 'inc' in k:
              # Angle columns: convert to degrees, give to 1 decimal place
              tab[k] = np.degrees(tab[k]).round(decimals=1)
          else:
              # Radii columns: give to 4 decimal places
              tab[k] = tab[k].round(decimals=4)
      return tab


  if __name__ == '__main__':
      bp.DEBUG = True
      th_inf = bp.theta_infinity(bp.cantoid_R_theta, 0.001)
      inclinations = np.linspace(0.0, th_inf - np.pi/2, 30)
      tab = parameter_table(inclinations, bp.cantoid_R_theta, 0.001)
      Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
      tab_s = parameter_table(inclinations,
                              bp.Spline_R_theta_from_function(
                                  ngrid=1000,
                                  shape_func=bp.cantoid_R_theta,
                                  shape_func_pars=(0.001,)))
      Rc_s, R90_s = tab_s['tilde R_c prime'], tab_s['tilde R_90 prime']

      result = [['inc', 'R_c', 'R_c spline', 'R_90', 'R_90 spline'], None]
      result += list(zip(np.degrees(inclinations).astype(int),
                         Rc, Rc_s, R90, R90_s))
#+END_SRC

#+RESULTS:
| inc |     R_c | R_c spline |    R_90 | R_90 spline |
|-----+--------+-----------+--------+------------|
|   0 | 1.7894 |    1.7894 | 1.7892 |     1.7892 |
|   2 | 1.8088 |    1.8078 | 1.7899 |     1.7898 |
|   5 | 1.8258 |    1.8258 | 1.7904 |     1.7904 |
|   8 | 1.8432 |    1.8433 | 1.7911 |     1.7911 |
|  10 | 1.8627 |    1.8603 | 1.7921 |     1.7918 |
|  13 | 1.8767 |    1.8796 | 1.7926 |     1.7929 |
|  16 |  1.896 |     1.896 | 1.7937 |     1.7937 |
|  18 | 1.9117 |    1.9078 | 1.7945 |      1.794 |
|  21 | 1.9267 |    1.9222 | 1.7953 |     1.7948 |
|  24 | 1.9409 |    1.9359 | 1.7962 |     1.7955 |
|  26 | 1.9488 |    1.9488 | 1.7963 |     1.7963 |
|  29 | 1.9667 |    1.9608 | 1.7979 |     1.7971 |
|  32 | 1.9719 |    1.9719 |  1.798 |      1.798 |
|  34 |  1.989 |     1.989 |    1.8 |        1.8 |
|  37 | 1.9915 |    1.9915 | 1.8002 |     1.8002 |
|  40 | 2.0076 |    2.0076 | 1.8027 |     1.8027 |
|  43 | 2.0158 |    2.0158 | 1.8045 |     1.8045 |
|  45 | 2.0151 |    2.0151 | 1.8056 |     1.8056 |
|  48 | 2.0307 |    2.0221 | 1.8099 |     1.8086 |
|  51 | 2.0293 |    2.0382 | 1.8127 |      1.814 |
|  53 | 2.0373 |    2.0465 | 1.8184 |     1.8197 |
|  56 | 2.0473 |    2.0473 | 1.8263 |     1.8263 |
|  59 | 2.0707 |    2.0707 |  1.839 |      1.839 |
|  61 | 2.0813 |    2.0813 | 1.8542 |     1.8542 |
|  64 | 2.1136 |    2.1243 | 1.8794 |     1.8809 |
|  67 |  2.169 |    2.1807 | 1.9195 |     1.9211 |
|  69 |  2.288 |    2.2742 | 1.9902 |     1.9886 |
|  72 | 2.5353 |    2.5353 | 2.1268 |     2.1268 |
|  75 | 3.4723 |    3.4723 | 2.4906 |     2.4906 |
|  77 |    nan |       nan |    nan |        nan |

+ So there are two problems here:
  1. The direct function has problems for inc = 1, 2, 3 degrees, while the spline fit is fine there
     - (not apparent any more with this particular list of incs)
     - But we get occasional unbracketed roots errors if we use slightly different lists
  2. The spline fit doesn’t quite get to the asymptotic angle




*** Test ~bow_diagnostic.py~ for the wilkinoid

#+name: test-wilkinoid-diagnostic
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.2
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = bp.Spline_R_theta_from_function(ngrid=1000,
                                          shape_func=bp.wilkinoid_R_theta)
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-wilkinoid-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    174.2 |           1.732 |         1.6652 |    0 |
|   1.0003 |    2.9 |      90 |    174.2 |           1.732 |         1.6647 |  1.7 |
|   1.0012 |    5.7 |    90.2 |    174.2 |          1.7319 |         1.6639 |  3.4 |
|   1.0027 |    8.6 |    90.4 |    174.2 |          1.7317 |         1.6631 |  5.2 |
|   1.0048 |   11.5 |    90.6 |    174.2 |          1.7314 |         1.6622 |  6.9 |
|   1.0076 |   14.3 |      91 |    174.2 |           1.731 |         1.6611 |  8.6 |
|   1.0109 |   17.2 |    91.4 |    174.2 |          1.7306 |         1.6599 | 10.3 |
|   1.0149 |   20.1 |      92 |    174.2 |            1.73 |         1.6586 |   12 |
|   1.0196 |     23 |    92.6 |    174.2 |          1.7294 |         1.6568 | 13.8 |
|   1.0249 |   25.9 |    93.2 |    174.2 |          1.7287 |         1.6555 | 15.5 |
|   1.0309 |   28.8 |      94 |    174.2 |           1.728 |         1.6538 | 17.2 |
|   1.0376 |   31.7 |    94.8 |    174.2 |          1.7271 |         1.6521 | 18.9 |
|   1.0451 |   34.6 |    95.7 |    174.2 |          1.7261 |         1.6497 | 20.6 |
|   1.0532 |   37.5 |    96.7 |    174.2 |          1.7251 |         1.6476 | 22.3 |
|   1.0622 |   40.4 |    97.7 |    174.2 |           1.724 |         1.6455 | 24.1 |
|    1.072 |   43.4 |    98.8 |    174.2 |          1.7228 |         1.6439 | 25.8 |
|   1.0826 |   46.3 |     100 |    174.2 |          1.7214 |         1.6409 | 27.5 |
|   1.0941 |   49.3 |   101.2 |    174.2 |          1.7201 |         1.6392 | 29.2 |
|   1.1066 |   52.2 |   102.5 |    174.2 |          1.7186 |         1.6368 | 30.9 |
|   1.1201 |   55.2 |   103.9 |    174.2 |          1.7169 |         1.6334 | 32.7 |
|   1.1347 |   58.2 |   105.3 |    174.2 |          1.7152 |         1.6307 | 34.4 |
|   1.1503 |   61.3 |   106.8 |    174.2 |          1.7134 |         1.6279 | 36.1 |
|   1.1672 |   64.3 |   108.3 |    174.2 |          1.7115 |          1.625 | 37.8 |
|   1.1853 |   67.4 |   109.9 |    174.2 |          1.7095 |          1.622 | 39.5 |
|   1.2047 |   70.4 |   111.6 |    174.2 |          1.7074 |         1.6199 | 41.3 |
|   1.2257 |   73.5 |   113.3 |    174.2 |          1.7051 |         1.6158 |   43 |
|   1.2482 |   76.7 |   115.1 |    174.2 |          1.7029 |         1.6135 | 44.7 |
|   1.2726 |   79.8 |   116.9 |    174.2 |          1.7003 |         1.6091 | 46.4 |
|   1.2987 |     83 |   118.8 |    174.2 |          1.6977 |         1.6056 | 48.1 |
|    1.327 |   86.2 |   120.7 |    174.2 |           1.695 |          1.602 | 49.9 |
|   1.3574 |   89.5 |   122.7 |    174.2 |          1.6922 |         1.5994 | 51.6 |
|   1.3904 |   92.7 |   124.8 |    174.2 |          1.6892 |         1.5955 | 53.3 |
|   1.4261 |   96.1 |   126.8 |    174.2 |          1.6861 |         1.5915 |   55 |
|   1.4651 |   99.4 |     129 |    174.2 |          1.6828 |         1.5863 | 56.7 |
|   1.5075 |  102.8 |   131.2 |    174.2 |          1.6794 |          1.582 | 58.4 |
|   1.5537 |  106.3 |   133.4 |    174.2 |           1.676 |         1.5787 | 60.2 |
|   1.6046 |  109.8 |   135.7 |    174.2 |          1.6722 |          1.573 | 61.9 |
|   1.6606 |  113.4 |   138.1 |    174.2 |          1.6684 |         1.5682 | 63.6 |
|   1.7226 |    117 |   140.5 |    174.2 |          1.6644 |         1.5632 | 65.3 |
|   1.7916 |  120.7 |   142.9 |    174.2 |          1.6603 |         1.5581 |   67 |
|   1.8689 |  124.4 |   145.4 |    174.2 |          1.6562 |         1.5537 | 68.8 |
|   1.9565 |  128.3 |     148 |    174.2 |          1.6518 |         1.5473 | 70.5 |
|   2.0564 |  132.2 |   150.6 |    174.2 |          1.6474 |         1.5416 | 72.2 |
|   2.1718 |  136.3 |   153.2 |    174.2 |           1.643 |         1.5357 | 73.9 |
|   2.3068 |  140.4 |   155.9 |    174.2 |          1.6386 |         1.5305 | 75.6 |
|   2.4683 |  144.7 |   158.7 |    174.2 |           1.634 |         1.5236 | 77.4 |
|   2.6655 |  149.1 |   161.5 |    174.2 |          1.6296 |         1.5175 | 79.1 |
|   2.9142 |  153.6 |   164.3 |    174.2 |          1.6254 |         1.5122 | 80.8 |
|   3.2427 |  158.3 |   167.2 |    174.2 |          1.6214 |         1.5057 | 82.5 |
|   3.7057 |  163.1 |   170.1 |    174.2 |          1.6179 |         1.5009 | 84.2 |


*** Test ~bow_diagnostic.py~ for the cantoids
+ \beta = 0.1 – R_90 starts going up immediately, but R_c drops about 1% and then back again over inc = 0 \to 23 deg. Bow is gone by 37 deg.  Strange reduction in R_c near the end
+ \beta = 0.01 – As for \beta = 0.1 but over 0 \to 37 deg and gone by 63 deg
+ \beta = 0.001 – For inc = 0 \to 45 deg, almost nothing happens. R_c goes down monotonically by about 3%.  R_90 goes down and then up, but only varies by about 0.1%. From 45 \to 60, both go up but only by a few percent. R_c regains its initial value at 66 deg.  Then from 66 \to 75 deg, they go up faster
+ \beta = 0.0001 – This is very similar to the wilkinoid, except for the highest inclinations. Both radii decline until 60–70 deg, but only by 2% for R_90 and 5% for R_c.  Then they start to go up again


#+name: test-cantoid-diagnostic
#+header: :var beta=0.001
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.2
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = bp.Spline_R_theta_from_function(ngrid=1000,
                                          shape_func=bp.cantoid_R_theta,
                                          shape_func_pars=(beta,))
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-cantoid-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    165.4 |          1.7884 |         1.7192 |    0 |
|   1.0003 |    2.6 |      90 |    165.4 |          1.7884 |         1.7186 |  1.5 |
|   1.0011 |    5.3 |    90.1 |    165.4 |          1.7884 |         1.7179 |  3.1 |
|   1.0024 |      8 |    90.3 |    165.4 |          1.7883 |         1.7171 |  4.6 |
|   1.0042 |   10.6 |    90.6 |    165.4 |          1.7883 |         1.7163 |  6.2 |
|   1.0066 |   13.3 |    90.9 |    165.4 |          1.7882 |         1.7152 |  7.7 |
|   1.0095 |   15.9 |    91.2 |    165.4 |          1.7881 |         1.7143 |  9.2 |
|    1.013 |   18.6 |    91.7 |    165.4 |          1.7879 |          1.713 | 10.8 |
|    1.017 |   21.2 |    92.2 |    165.4 |          1.7878 |         1.7118 | 12.3 |
|   1.0216 |   23.9 |    92.8 |    165.4 |          1.7877 |         1.7109 | 13.9 |
|   1.0268 |   26.6 |    93.4 |    165.4 |          1.7875 |         1.7091 | 15.4 |
|   1.0325 |   29.3 |    94.1 |    165.4 |          1.7873 |         1.7083 | 16.9 |
|    1.039 |     32 |    94.9 |    165.4 |          1.7871 |         1.7063 | 18.5 |
|    1.046 |   34.7 |    95.8 |    165.4 |           1.787 |         1.7049 |   20 |
|   1.0537 |   37.4 |    96.7 |    165.4 |          1.7868 |         1.7034 | 21.6 |
|   1.0621 |   40.1 |    97.6 |    165.4 |          1.7866 |         1.7018 | 23.1 |
|   1.0712 |   42.8 |    98.6 |    165.4 |          1.7864 |         1.7002 | 24.6 |
|   1.0811 |   45.6 |    99.7 |    165.4 |          1.7863 |         1.6987 | 26.2 |
|   1.0917 |   48.3 |   100.9 |    165.4 |          1.7862 |          1.698 | 27.7 |
|   1.1032 |   51.1 |   102.1 |    165.4 |           1.786 |         1.6955 | 29.3 |
|   1.1154 |   53.8 |   103.3 |    165.4 |           1.786 |         1.6949 | 30.8 |
|   1.1287 |   56.6 |   104.6 |    165.4 |           1.786 |         1.6934 | 32.3 |
|   1.1429 |   59.4 |     106 |    165.4 |          1.7859 |         1.6907 | 33.9 |
|   1.1581 |   62.3 |   107.4 |    165.4 |          1.7861 |         1.6904 | 35.4 |
|   1.1745 |   65.1 |   108.8 |    165.4 |          1.7861 |         1.6877 |   37 |
|    1.192 |     68 |   110.4 |    165.4 |          1.7864 |         1.6863 | 38.5 |
|   1.2107 |   70.8 |   111.9 |    165.4 |          1.7868 |         1.6863 |   40 |
|   1.2309 |   73.7 |   113.6 |    165.4 |          1.7872 |         1.6836 | 41.6 |
|   1.2525 |   76.7 |   115.2 |    165.4 |          1.7879 |         1.6824 | 43.1 |
|   1.2757 |   79.6 |   116.9 |    165.4 |          1.7887 |         1.6813 | 44.6 |
|   1.3006 |   82.6 |   118.7 |    165.4 |          1.7898 |         1.6804 | 46.2 |
|   1.3274 |   85.7 |   120.5 |    165.4 |          1.7912 |         1.6796 | 47.7 |
|   1.3562 |   88.7 |   122.4 |    165.4 |          1.7931 |         1.6807 | 49.3 |
|   1.3873 |   91.8 |   124.3 |    165.4 |          1.7952 |         1.6805 | 50.8 |
|   1.4212 |   94.9 |   126.3 |    165.4 |          1.7977 |         1.6788 | 52.3 |
|   1.4578 |   98.1 |   128.3 |    165.4 |           1.801 |         1.6792 | 53.9 |
|   1.4976 |  101.3 |   130.4 |    165.4 |           1.805 |         1.6801 | 55.4 |
|    1.541 |  104.6 |   132.6 |    165.4 |          1.8102 |         1.6834 |   57 |
|   1.5886 |    108 |   134.7 |    165.4 |          1.8164 |         1.6856 | 58.5 |
|   1.6411 |  111.4 |     137 |    165.4 |          1.8242 |         1.6888 |   60 |
|   1.6992 |  114.9 |   139.3 |    165.4 |          1.8339 |         1.6932 | 61.6 |
|   1.7642 |  118.5 |   141.7 |    165.4 |          1.8461 |         1.6972 | 63.1 |
|    1.837 |  122.1 |   144.1 |    165.4 |          1.8619 |         1.7052 | 64.7 |
|   1.9197 |  125.9 |   146.6 |    165.4 |          1.8826 |         1.7162 | 66.2 |
|   2.0147 |  129.8 |   149.1 |    165.4 |          1.9101 |         1.7314 | 67.7 |
|   2.1254 |  133.9 |   151.7 |    165.4 |          1.9481 |         1.7552 | 69.3 |
|    2.258 |  138.2 |   154.4 |    165.4 |          2.0019 |         1.7834 | 70.8 |
|   2.4205 |  142.7 |   157.2 |    165.4 |          2.0842 |         1.8334 | 72.4 |
|   2.6299 |  147.6 |   160.1 |    165.4 |           2.221 |           1.91 | 73.9 |
|   2.9224 |    153 |     163 |    165.4 |          2.4926 |         2.0492 | 75.4 |


#+call: test-cantoid-diagnostic(beta=0.1)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    127.6 |          2.5087 |         2.4246 |    0 |
|   1.0002 |    1.9 |      90 |    127.6 |          2.5089 |         2.4219 |  0.8 |
|   1.0006 |    3.7 |    90.1 |    127.6 |          2.5095 |          2.419 |  1.5 |
|   1.0012 |    5.6 |    90.1 |    127.6 |          2.5105 |         2.4165 |  2.3 |
|   1.0021 |    7.5 |    90.3 |    127.6 |           2.512 |         2.4141 |  3.1 |
|   1.0033 |    9.4 |    90.4 |    127.6 |          2.5139 |         2.4119 |  3.8 |
|   1.0048 |   11.2 |    90.6 |    127.6 |          2.5163 |         2.4111 |  4.6 |
|   1.0065 |   13.1 |    90.8 |    127.6 |          2.5191 |          2.408 |  5.4 |
|   1.0085 |     15 |      91 |    127.6 |          2.5225 |         2.4079 |  6.1 |
|   1.0108 |   16.9 |    91.3 |    127.6 |          2.5263 |         2.4066 |  6.9 |
|   1.0133 |   18.8 |    91.6 |    127.6 |          2.5306 |         2.4055 |  7.7 |
|   1.0162 |   20.7 |    91.9 |    127.6 |          2.5353 |         2.4021 |  8.4 |
|   1.0193 |   22.6 |    92.3 |    127.6 |          2.5407 |         2.4039 |  9.2 |
|   1.0228 |   24.5 |    92.7 |    127.6 |          2.5465 |         2.4003 |   10 |
|   1.0266 |   26.4 |    93.1 |    127.6 |           2.553 |         2.3996 | 10.7 |
|   1.0306 |   28.3 |    93.6 |    127.6 |          2.5601 |         2.3992 | 11.5 |
|    1.035 |   30.3 |      94 |    127.6 |          2.5679 |         2.3989 | 12.3 |
|   1.0397 |   32.2 |    94.6 |    127.6 |          2.5765 |         2.4037 | 13.1 |
|   1.0448 |   34.2 |    95.1 |    127.6 |          2.5858 |         2.4043 | 13.8 |
|   1.0503 |   36.1 |    95.7 |    127.6 |          2.5956 |         2.3996 | 14.6 |
|   1.0561 |   38.1 |    96.3 |    127.6 |          2.6064 |         2.4002 | 15.4 |
|   1.0624 |   40.1 |    96.9 |    127.6 |          2.6182 |         2.4011 | 16.1 |
|   1.0688 |   42.1 |    97.6 |    127.6 |          2.6313 |         2.4096 | 16.9 |
|    1.076 |   44.1 |    98.3 |    127.6 |          2.6448 |         2.4037 | 17.7 |
|   1.0834 |   46.1 |      99 |    127.6 |          2.6603 |         2.4139 | 18.4 |
|   1.0915 |   48.2 |    99.7 |    127.6 |          2.6761 |         2.4072 | 19.2 |
|      1.1 |   50.2 |   100.5 |    127.6 |          2.6939 |         2.4093 |   20 |
|    1.109 |   52.3 |   101.3 |    127.6 |          2.7131 |         2.4116 | 20.7 |
|   1.1186 |   54.4 |   102.2 |    127.6 |          2.7341 |         2.4141 | 21.5 |
|   1.1285 |   56.5 |     103 |    127.6 |          2.7578 |         2.4293 | 22.3 |
|   1.1396 |   58.7 |   103.9 |    127.6 |          2.7821 |         2.4195 |   23 |
|   1.1507 |   60.9 |   104.9 |    127.6 |          2.8105 |          2.437 | 23.8 |
|   1.1629 |   63.1 |   105.8 |    127.6 |          2.8408 |          2.441 | 24.6 |
|   1.1764 |   65.3 |   106.8 |    127.6 |          2.8732 |         2.4274 | 25.3 |
|   1.1899 |   67.6 |   107.8 |    127.6 |          2.9114 |         2.4484 | 26.1 |
|   1.2048 |   69.9 |   108.8 |    127.6 |          2.9527 |         2.4514 | 26.9 |
|   1.2214 |   72.3 |   109.9 |    127.6 |          2.9974 |          2.431 | 27.6 |
|   1.2386 |   74.7 |     111 |    127.6 |          3.0492 |         2.4295 | 28.4 |
|   1.2563 |   77.1 |   112.1 |    127.6 |          3.1101 |         2.4526 | 29.2 |
|   1.2773 |   79.6 |   113.3 |    127.6 |          3.1751 |         2.4176 | 29.9 |
|   1.2981 |   82.2 |   114.5 |    127.6 |          3.2554 |         2.4374 | 30.7 |
|   1.3233 |   84.9 |   115.7 |    127.6 |           3.343 |         2.3824 | 31.5 |
|   1.3483 |   87.7 |   116.9 |    127.6 |          3.4539 |         2.3893 | 32.2 |
|   1.3778 |   90.6 |   118.2 |    127.6 |          3.5833 |         2.3406 |   33 |
|   1.4112 |   93.6 |   119.5 |    127.6 |          3.7423 |         2.2625 | 33.8 |
|   1.4534 |   96.8 |   120.8 |    127.6 |          3.9338 |         2.0801 | 34.5 |
|   1.4977 |  100.2 |   122.2 |    127.6 |          4.2028 |         1.9343 | 35.3 |
|   1.5614 |    104 |   123.6 |    127.6 |          4.5519 |         1.6066 | 36.1 |
|   1.6703 |  108.2 |     125 |    127.6 |          5.0121 |         1.0941 | 36.9 |
|   2.1507 |  113.1 |   126.5 |    127.6 |          4.9983 |         0.4141 | 37.6 |

#+call: test-cantoid-diagnostic(beta=0.01)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    152.7 |          1.9226 |         1.8488 |    0 |
|   1.0002 |    2.4 |      90 |    152.7 |          1.9226 |         1.8479 |  1.3 |
|   1.0009 |    4.7 |    90.1 |    152.7 |          1.9227 |         1.8471 |  2.6 |
|   1.0019 |    7.1 |    90.3 |    152.7 |          1.9229 |         1.8462 |  3.8 |
|   1.0034 |    9.5 |    90.4 |    152.7 |          1.9233 |         1.8453 |  5.1 |
|   1.0054 |   11.9 |    90.7 |    152.7 |          1.9237 |         1.8447 |  6.4 |
|   1.0078 |   14.2 |      91 |    152.7 |          1.9242 |         1.8439 |  7.7 |
|   1.0106 |   16.6 |    91.4 |    152.7 |          1.9248 |          1.843 |    9 |
|   1.0139 |     19 |    91.8 |    152.7 |          1.9255 |         1.8418 | 10.2 |
|   1.0176 |   21.4 |    92.2 |    152.7 |          1.9263 |         1.8409 | 11.5 |
|   1.0218 |   23.8 |    92.8 |    152.7 |          1.9273 |         1.8401 | 12.8 |
|   1.0265 |   26.2 |    93.3 |    152.7 |          1.9284 |           1.84 | 14.1 |
|   1.0317 |   28.6 |      94 |    152.7 |          1.9296 |         1.8394 | 15.4 |
|   1.0374 |     31 |    94.6 |    152.7 |          1.9309 |         1.8378 | 16.6 |
|   1.0436 |   33.4 |    95.4 |    152.7 |          1.9324 |         1.8382 | 17.9 |
|   1.0504 |   35.8 |    96.1 |    152.7 |           1.934 |         1.8366 | 19.2 |
|   1.0577 |   38.3 |      97 |    152.7 |          1.9359 |         1.8374 | 20.5 |
|   1.0656 |   40.7 |    97.9 |    152.7 |          1.9379 |         1.8371 | 21.7 |
|   1.0741 |   43.2 |    98.8 |    152.7 |          1.9402 |          1.837 |   23 |
|   1.0833 |   45.7 |    99.8 |    152.7 |          1.9425 |         1.8354 | 24.3 |
|   1.0931 |   48.1 |   100.8 |    152.7 |          1.9453 |         1.8371 | 25.6 |
|   1.1037 |   50.6 |   101.8 |    152.7 |          1.9482 |         1.8356 | 26.9 |
|   1.1149 |   53.1 |     103 |    152.7 |          1.9516 |         1.8378 | 28.1 |
|   1.1269 |   55.7 |   104.1 |    152.7 |          1.9552 |         1.8385 | 29.4 |
|   1.1399 |   58.2 |   105.3 |    152.7 |           1.959 |         1.8372 | 30.7 |
|   1.1536 |   60.8 |   106.6 |    152.7 |          1.9634 |         1.8382 |   32 |
|   1.1682 |   63.4 |   107.9 |    152.7 |          1.9684 |         1.8419 | 33.3 |
|    1.184 |     66 |   109.2 |    152.7 |          1.9736 |         1.8411 | 34.5 |
|   1.2007 |   68.6 |   110.6 |    152.7 |          1.9796 |         1.8431 | 35.8 |
|   1.2185 |   71.2 |   112.1 |    152.7 |          1.9865 |         1.8484 | 37.1 |
|   1.2376 |   73.9 |   113.5 |    152.7 |          1.9939 |         1.8514 | 38.4 |
|   1.2581 |   76.6 |   115.1 |    152.7 |          2.0022 |         1.8549 | 39.7 |
|     1.28 |   79.4 |   116.6 |    152.7 |          2.0116 |         1.8591 | 40.9 |
|   1.3036 |   82.1 |   118.3 |    152.7 |          2.0221 |          1.864 | 42.2 |
|   1.3291 |     85 |   119.9 |    152.7 |          2.0338 |          1.866 | 43.5 |
|   1.3562 |   87.8 |   121.6 |    152.7 |          2.0477 |         1.8764 | 44.8 |
|   1.3859 |   90.7 |   123.4 |    152.7 |          2.0629 |         1.8801 | 46.1 |
|   1.4178 |   93.7 |   125.2 |    152.7 |          2.0808 |          1.889 | 47.3 |
|   1.4522 |   96.7 |     127 |    152.7 |          2.1021 |         1.9041 | 48.6 |
|   1.4904 |   99.8 |   128.9 |    152.7 |          2.1262 |         1.9118 | 49.9 |
|   1.5316 |  102.9 |   130.9 |    152.7 |          2.1556 |         1.9319 | 51.2 |
|   1.5773 |  106.2 |   132.9 |    152.7 |          2.1905 |         1.9499 | 52.5 |
|   1.6285 |  109.5 |   134.9 |    152.7 |          2.2324 |         1.9653 | 53.7 |
|   1.6851 |    113 |     137 |    152.7 |          2.2858 |         1.9981 |   55 |
|   1.7495 |  116.6 |   139.2 |    152.7 |           2.353 |         2.0306 | 56.3 |
|   1.8236 |  120.4 |   141.4 |    152.7 |          2.4414 |         2.0709 | 57.6 |
|   1.9104 |  124.4 |   143.7 |    152.7 |          2.5628 |          2.121 | 58.8 |
|   2.0152 |  128.7 |     146 |    152.7 |          2.7404 |          2.181 | 60.1 |
|   2.1495 |  133.5 |   148.4 |    152.7 |          3.0259 |         2.2153 | 61.4 |
|   2.3352 |  139.1 |   150.9 |    152.7 |          3.5901 |         2.1653 | 62.7 |

#+call: test-cantoid-diagnostic(beta=0.0001)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    171.1 |          1.7495 |         1.6819 |    0 |
|   1.0003 |    2.8 |      90 |    171.1 |          1.7495 |         1.6814 |  1.7 |
|   1.0012 |    5.6 |    90.2 |    171.1 |          1.7494 |         1.6807 |  3.3 |
|   1.0026 |    8.4 |    90.3 |    171.1 |          1.7492 |         1.6798 |    5 |
|   1.0046 |   11.1 |    90.6 |    171.1 |           1.749 |          1.679 |  6.6 |
|   1.0072 |   13.9 |      91 |    171.1 |          1.7488 |         1.6778 |  8.3 |
|   1.0104 |   16.7 |    91.4 |    171.1 |          1.7484 |         1.6766 |  9.9 |
|   1.0142 |   19.5 |    91.9 |    171.1 |           1.748 |         1.6753 | 11.6 |
|   1.0186 |   22.3 |    92.4 |    171.1 |          1.7476 |         1.6742 | 13.2 |
|   1.0236 |   25.1 |    93.1 |    171.1 |          1.7471 |         1.6728 | 14.9 |
|   1.0293 |     28 |    93.8 |    171.1 |          1.7465 |         1.6708 | 16.5 |
|   1.0357 |   30.8 |    94.6 |    171.1 |          1.7459 |         1.6692 | 18.2 |
|   1.0427 |   33.6 |    95.4 |    171.1 |          1.7452 |         1.6679 | 19.9 |
|   1.0505 |   36.4 |    96.3 |    171.1 |          1.7444 |         1.6656 | 21.5 |
|   1.0589 |   39.3 |    97.3 |    171.1 |          1.7437 |         1.6643 | 23.2 |
|   1.0682 |   42.1 |    98.4 |    171.1 |          1.7428 |         1.6623 | 24.8 |
|   1.0782 |     45 |    99.5 |    171.1 |          1.7419 |         1.6603 | 26.5 |
|   1.0891 |   47.9 |   100.7 |    171.1 |          1.7409 |         1.6582 | 28.1 |
|   1.1009 |   50.8 |   101.9 |    171.1 |          1.7399 |         1.6561 | 29.8 |
|   1.1136 |   53.7 |   103.2 |    171.1 |          1.7388 |         1.6539 | 31.4 |
|   1.1273 |   56.6 |   104.6 |    171.1 |          1.7377 |         1.6517 | 33.1 |
|    1.142 |   59.5 |     106 |    171.1 |          1.7365 |         1.6493 | 34.7 |
|   1.1578 |   62.5 |   107.5 |    171.1 |          1.7352 |          1.646 | 36.4 |
|   1.1748 |   65.5 |     109 |    171.1 |          1.7339 |         1.6435 | 38.1 |
|   1.1931 |   68.5 |   110.6 |    171.1 |          1.7326 |          1.641 | 39.7 |
|   1.2126 |   71.5 |   112.2 |    171.1 |          1.7313 |         1.6396 | 41.4 |
|   1.2338 |   74.5 |   113.9 |    171.1 |          1.7298 |         1.6359 |   43 |
|   1.2563 |   77.6 |   115.7 |    171.1 |          1.7285 |         1.6344 | 44.7 |
|   1.2808 |   80.7 |   117.5 |    171.1 |           1.727 |         1.6306 | 46.3 |
|    1.307 |   83.8 |   119.3 |    171.1 |          1.7255 |         1.6279 |   48 |
|   1.3353 |   86.9 |   121.2 |    171.1 |          1.7241 |         1.6252 | 49.6 |
|   1.3657 |   90.1 |   123.2 |    171.1 |          1.7228 |         1.6237 | 51.3 |
|   1.3988 |   93.3 |   125.2 |    171.1 |          1.7213 |         1.6198 | 52.9 |
|   1.4345 |   96.6 |   127.3 |    171.1 |          1.7201 |         1.6183 | 54.6 |
|   1.4735 |   99.9 |   129.4 |    171.1 |          1.7188 |         1.6144 | 56.3 |
|   1.5158 |  103.2 |   131.5 |    171.1 |          1.7179 |         1.6131 | 57.9 |
|   1.5621 |  106.6 |   133.8 |    171.1 |          1.7171 |         1.6105 | 59.6 |
|   1.6129 |  110.1 |     136 |    171.1 |          1.7165 |         1.6081 | 61.2 |
|   1.6691 |  113.6 |   138.4 |    171.1 |          1.7162 |         1.6046 | 62.9 |
|   1.7313 |  117.2 |   140.7 |    171.1 |          1.7166 |         1.6027 | 64.5 |
|   1.8005 |  120.9 |   143.2 |    171.1 |          1.7179 |         1.6024 | 66.2 |
|   1.8784 |  124.6 |   145.7 |    171.1 |            1.72 |         1.6014 | 67.8 |
|   1.9668 |  128.5 |   148.2 |    171.1 |          1.7234 |         1.6012 | 69.5 |
|   2.0681 |  132.4 |   150.8 |    171.1 |          1.7289 |         1.6023 | 71.1 |
|   2.1861 |  136.5 |   153.5 |    171.1 |          1.7371 |         1.6038 | 72.8 |
|   2.3252 |  140.7 |   156.2 |    171.1 |          1.7498 |         1.6105 | 74.5 |
|   2.4939 |    145 |   159.1 |    171.1 |          1.7694 |         1.6205 | 76.1 |
|   2.7047 |  149.6 |   161.9 |    171.1 |          1.8008 |         1.6367 | 77.8 |
|   2.9805 |  154.4 |   164.9 |    171.1 |          1.8552 |         1.6687 | 79.4 |
|   3.3697 |  159.5 |   167.9 |    171.1 |          1.9632 |         1.7355 | 81.1 |


*** Test ~bow_diagnostic.py~ for the dragoids
+ Something strange is going on with these
+ R_0’ is fine and R_90’ is mostly fine too, but R_c’ is all over the place, especially for low inclinations
+ This turned out to be because of the small value of ~bp.SCALE_NEIGHBORHOOD~, which meant it was trying to fit small fluctuations in the radius close to the axis
  + These are really there in the data, and must be due to the discretization in the impact parameter of the drag models
+ So, if I use ~bp.SCALE_NEIGHBORHOOD = 0.2~, which corresponds to 36 degrees, then things are much better
+ Results are:
  + R_c increases slightly at constant R_90 for i = 0 \to 20 deg, but this is hardly noticeable: for instance, 1.89 \to 1.92 for \alpha_drag = 0.25
  + Then R_c goes back again, and then keeps on decreasing, while R_90 starts decreasing also, maintaining R_90 \approx 1.03 R_c
#+name: test-dragoid-diagnostic
#+header: :var alpha=0.25 mu=0
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import dragoid_shape
  import bow_diagnostic

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.25
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = dragoid_shape.Dragoid(alpha=alpha,
                                mu=None if mu == 0 else mu,
                                lowess_frac=0.1)

  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-dragoid-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0025 |      0 |      90 |    163.3 |          1.9532 |         1.8881 |    0 |
|   1.0028 |    2.8 |      90 |    163.3 |          1.9533 |         1.8894 |  1.5 |
|   1.0037 |    5.6 |    90.2 |    163.3 |          1.9534 |         1.8917 |    3 |
|   1.0052 |    8.4 |    90.3 |    163.3 |          1.9536 |         1.8937 |  4.5 |
|   1.0073 |   11.3 |    90.6 |    163.3 |          1.9537 |         1.8953 |    6 |
|   1.0102 |   14.2 |    90.9 |    163.3 |          1.9538 |         1.8965 |  7.5 |
|   1.0137 |   17.1 |    91.3 |    163.3 |          1.9538 |         1.8965 |    9 |
|   1.0179 |     20 |    91.8 |    163.3 |          1.9539 |         1.8956 | 10.5 |
|   1.0228 |   22.9 |    92.4 |    163.3 |          1.9539 |         1.8951 |   12 |
|   1.0284 |   25.9 |      93 |    163.3 |          1.9539 |         1.8941 | 13.5 |
|   1.0347 |   28.8 |    93.7 |    163.3 |           1.954 |         1.8943 |   15 |
|   1.0418 |   31.7 |    94.4 |    163.3 |           1.954 |         1.8927 | 16.4 |
|   1.0498 |   34.6 |    95.3 |    163.3 |          1.9538 |         1.8896 | 17.9 |
|   1.0584 |   37.8 |    96.2 |    163.3 |          1.9538 |         1.8886 | 19.4 |
|    1.068 |   40.6 |    97.1 |    163.3 |          1.9535 |         1.8873 | 20.9 |
|   1.0784 |   43.4 |    98.1 |    163.3 |          1.9532 |         1.8859 | 22.4 |
|   1.0898 |   46.3 |    99.1 |    163.3 |          1.9529 |         1.8841 | 23.9 |
|   1.1022 |   49.3 |   100.3 |    163.3 |          1.9524 |         1.8809 | 25.4 |
|   1.1158 |   52.3 |   101.4 |    163.3 |          1.9515 |         1.8755 | 26.9 |
|   1.1302 |   55.4 |   102.6 |    163.3 |          1.9511 |         1.8751 | 28.4 |
|   1.1461 |   58.9 |   103.9 |    163.3 |          1.9498 |         1.8672 | 29.9 |
|   1.1628 |     61 |   105.2 |    163.3 |          1.9492 |         1.8686 | 31.4 |
|   1.1808 |   64.3 |   106.6 |    163.3 |          1.9483 |         1.8659 | 32.9 |
|   1.2005 |   67.3 |     108 |    163.3 |          1.9471 |         1.8607 | 34.4 |
|   1.2215 |   70.3 |   109.5 |    163.3 |          1.9457 |         1.8552 | 35.9 |
|   1.2445 |   73.3 |   110.9 |    163.3 |          1.9436 |         1.8447 | 37.4 |
|   1.2685 |     76 |   112.4 |    163.3 |          1.9424 |         1.8453 | 38.9 |
|    1.294 |   78.8 |     114 |    163.3 |          1.9416 |         1.8506 | 40.4 |
|   1.3217 |   81.3 |   115.6 |    163.3 |          1.9405 |         1.8532 | 41.9 |
|   1.3523 |   84.9 |   117.2 |    163.3 |           1.938 |          1.842 | 43.4 |
|   1.3844 |   87.5 |   118.8 |    163.3 |          1.9359 |         1.8437 | 44.9 |
|   1.4197 |   90.4 |   120.5 |    163.3 |          1.9328 |          1.834 | 46.4 |
|    1.458 |   93.8 |   122.2 |    163.3 |          1.9294 |         1.8216 | 47.8 |
|    1.498 |   96.4 |     124 |    163.3 |          1.9272 |          1.824 | 49.3 |
|   1.5426 |   99.4 |   125.7 |    163.3 |          1.9231 |          1.812 | 50.8 |
|   1.5902 |  102.4 |   127.5 |    163.3 |          1.9194 |         1.8067 | 52.3 |
|   1.6414 |  105.2 |   129.3 |    163.3 |          1.9159 |         1.8068 | 53.8 |
|   1.6972 |    108 |   131.1 |    163.3 |          1.9117 |         1.8033 | 55.3 |
|   1.7582 |  110.9 |   132.9 |    163.3 |          1.9069 |         1.7983 | 56.8 |
|   1.8246 |  113.9 |   134.8 |    163.3 |          1.9017 |         1.7935 | 58.3 |
|   1.8985 |  116.9 |   136.7 |    163.3 |          1.8945 |          1.778 | 59.8 |
|   1.9776 |  119.7 |   138.5 |    163.3 |          1.8886 |         1.7776 | 61.3 |
|   2.0652 |  122.5 |   140.4 |    163.3 |          1.8815 |         1.7736 | 62.8 |
|   2.1611 |  125.3 |   142.3 |    163.3 |          1.8741 |         1.7739 | 64.3 |
|   2.2693 |  128.2 |   144.2 |    163.3 |          1.8641 |         1.7614 | 65.8 |
|   2.3879 |    131 |   146.2 |    163.3 |          1.8543 |         1.7586 | 67.3 |
|   2.5219 |  133.9 |   148.1 |    163.3 |          1.8421 |         1.7475 | 68.8 |
|   2.6717 |  136.7 |     150 |    163.3 |          1.8286 |         1.7389 | 70.3 |
|   2.8424 |  139.5 |     152 |    163.3 |          1.8124 |         1.7225 | 71.8 |
|   3.0343 |  142.3 |   153.9 |    163.3 |           1.795 |         1.7136 | 73.3 |

#+call: test-dragoid-diagnostic(alpha=0.5)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0024 |      0 |      90 |    168.7 |          1.9136 |         1.8524 |    0 |
|   1.0028 |    2.9 |      90 |    168.7 |          1.9137 |         1.8539 |  1.6 |
|   1.0037 |    5.9 |    90.2 |    168.7 |          1.9137 |         1.8559 |  3.2 |
|   1.0054 |    8.9 |    90.4 |    168.7 |          1.9138 |         1.8581 |  4.8 |
|   1.0078 |   11.9 |    90.7 |    168.7 |          1.9138 |         1.8594 |  6.4 |
|   1.0109 |   14.9 |      91 |    168.7 |          1.9137 |         1.8601 |    8 |
|   1.0148 |     18 |    91.5 |    168.7 |          1.9134 |         1.8597 |  9.6 |
|   1.0194 |   21.1 |      92 |    168.7 |          1.9131 |         1.8597 | 11.2 |
|   1.0248 |   24.2 |    92.6 |    168.7 |          1.9127 |         1.8592 | 12.8 |
|   1.0311 |   27.2 |    93.3 |    168.7 |          1.9122 |         1.8575 | 14.5 |
|   1.0382 |   30.4 |    94.1 |    168.7 |          1.9115 |         1.8554 | 16.1 |
|    1.046 |   33.4 |    94.9 |    168.7 |          1.9109 |         1.8557 | 17.7 |
|   1.0548 |   36.7 |    95.8 |    168.7 |            1.91 |         1.8527 | 19.3 |
|   1.0645 |   39.5 |    96.8 |    168.7 |          1.9091 |         1.8503 | 20.9 |
|   1.0751 |   42.7 |    97.8 |    168.7 |          1.9082 |         1.8492 | 22.5 |
|   1.0869 |   45.8 |    98.9 |    168.7 |          1.9067 |         1.8438 | 24.1 |
|   1.0996 |     49 |   100.1 |    168.7 |          1.9055 |         1.8421 | 25.7 |
|   1.1135 |     52 |   101.2 |    168.7 |          1.9037 |         1.8375 | 27.3 |
|   1.1283 |   55.1 |   102.5 |    168.7 |          1.9022 |         1.8374 | 28.9 |
|   1.1451 |   58.9 |   103.9 |    168.7 |          1.8992 |         1.8233 | 30.5 |
|   1.1623 |   61.2 |   105.3 |    168.7 |          1.8977 |         1.8274 | 32.1 |
|   1.1812 |   64.4 |   106.6 |    168.7 |          1.8951 |         1.8231 | 33.7 |
|   1.2017 |   67.5 |   108.2 |    168.7 |          1.8922 |          1.818 | 35.3 |
|   1.2233 |   70.4 |   109.6 |    168.7 |          1.8898 |         1.8197 | 36.9 |
|   1.2471 |   73.5 |   111.2 |    168.7 |          1.8863 |         1.8128 | 38.5 |
|   1.2732 |   76.9 |   112.8 |    168.7 |          1.8818 |         1.7986 | 40.1 |
|    1.301 |   80.3 |   114.4 |    168.7 |          1.8774 |         1.7888 | 41.8 |
|   1.3296 |   82.9 |   116.1 |    168.7 |          1.8743 |         1.7958 | 43.4 |
|   1.3617 |   85.9 |   117.8 |    168.7 |          1.8697 |         1.7882 |   45 |
|   1.3958 |   88.8 |   119.5 |    168.7 |          1.8645 |         1.7854 | 46.6 |
|    1.432 |   91.5 |   121.3 |    168.7 |          1.8596 |         1.7888 | 48.2 |
|   1.4725 |   94.8 |     123 |    168.7 |          1.8527 |         1.7746 | 49.8 |
|   1.5159 |   97.9 |   124.9 |    168.7 |          1.8456 |         1.7642 | 51.4 |
|   1.5626 |  100.8 |   126.7 |    168.7 |          1.8382 |          1.756 |   53 |
|   1.6124 |  103.8 |   128.6 |    168.7 |          1.8309 |         1.7551 | 54.6 |
|   1.6672 |  106.7 |   130.4 |    168.7 |          1.8218 |         1.7461 | 56.2 |
|   1.7261 |  109.7 |   132.3 |    168.7 |          1.8127 |         1.7416 | 57.8 |
|   1.7914 |  112.7 |   134.2 |    168.7 |          1.8013 |         1.7257 | 59.4 |
|   1.8612 |  115.7 |   136.1 |    168.7 |          1.7903 |          1.721 |   61 |
|   1.9386 |  118.4 |     138 |    168.7 |          1.7769 |         1.7071 | 62.6 |
|   2.0226 |  121.6 |   139.9 |    168.7 |          1.7629 |         1.6964 | 64.2 |
|   2.1157 |  124.5 |   141.9 |    168.7 |          1.7468 |         1.6805 | 65.8 |
|   2.2175 |  127.3 |   143.8 |    168.7 |          1.7295 |         1.6669 | 67.4 |
|   2.3297 |  130.2 |   145.8 |    168.7 |          1.7105 |         1.6529 | 69.1 |
|    2.455 |  133.1 |   147.7 |    168.7 |          1.6887 |         1.6319 | 70.7 |
|   2.5943 |    136 |   149.7 |    168.7 |          1.6646 |         1.6097 | 72.3 |
|   2.7489 |  138.8 |   151.7 |    168.7 |          1.6382 |         1.5888 | 73.9 |
|   2.9236 |  141.6 |   153.7 |    168.7 |           1.608 |         1.5602 | 75.5 |
|   3.1204 |  144.4 |   155.7 |    168.7 |          1.5743 |         1.5292 | 77.1 |
|   3.3439 |  147.3 |   157.6 |    168.7 |          1.5365 |          1.494 | 78.7 |


#+call: test-dragoid-diagnostic(alpha=1.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   0.9997 |      0 |      90 |    174.1 |          1.8308 |         1.7815 |    0 |
|        1 |    2.5 |      90 |    174.1 |          1.8308 |         1.7851 |  1.7 |
|    1.001 |    5.4 |    90.2 |    174.1 |          1.8308 |         1.7892 |  3.4 |
|   1.0028 |    9.4 |    90.4 |    174.1 |          1.8305 |         1.7913 |  5.2 |
|   1.0053 |   12.4 |    90.7 |    174.1 |          1.8301 |         1.7924 |  6.9 |
|   1.0085 |   15.5 |    91.1 |    174.1 |          1.8295 |         1.7926 |  8.6 |
|   1.0126 |   18.6 |    91.5 |    174.1 |          1.8285 |         1.7921 | 10.3 |
|   1.0174 |   21.8 |    92.1 |    174.1 |          1.8274 |         1.7907 |   12 |
|   1.0231 |   24.9 |    92.7 |    174.1 |           1.826 |         1.7888 | 13.7 |
|   1.0295 |   27.7 |    93.4 |    174.1 |          1.8244 |         1.7871 | 15.5 |
|   1.0369 |   31.1 |    94.2 |    174.1 |          1.8226 |         1.7845 | 17.2 |
|   1.0451 |   34.1 |    95.1 |    174.1 |          1.8205 |         1.7811 | 18.9 |
|   1.0542 |     37 |      96 |    174.1 |          1.8183 |         1.7786 | 20.6 |
|   1.0642 |   40.4 |      97 |    174.1 |          1.8159 |         1.7755 | 22.3 |
|   1.0752 |   43.2 |      98 |    174.1 |           1.813 |         1.7717 |   24 |
|   1.0872 |   46.4 |    99.2 |    174.1 |          1.8098 |         1.7677 | 25.8 |
|   1.1004 |   49.6 |   100.4 |    174.1 |          1.8063 |         1.7608 | 27.5 |
|   1.1147 |   53.2 |   101.6 |    174.1 |          1.8023 |         1.7541 | 29.2 |
|     1.13 |   55.9 |   102.9 |    174.1 |          1.7985 |         1.7513 | 30.9 |
|   1.1466 |   59.1 |   104.3 |    174.1 |          1.7941 |         1.7449 | 32.6 |
|   1.1646 |   62.3 |   105.7 |    174.1 |          1.7892 |         1.7385 | 34.3 |
|   1.1836 |   64.9 |   107.2 |    174.1 |          1.7844 |         1.7373 | 36.1 |
|   1.2044 |   68.1 |   108.6 |    174.1 |          1.7787 |         1.7297 | 37.8 |
|   1.2269 |   71.7 |   110.3 |    174.1 |          1.7722 |         1.7184 | 39.5 |
|   1.2505 |   74.6 |   111.8 |    174.1 |          1.7661 |          1.715 | 41.2 |
|   1.2763 |     78 |   113.5 |    174.1 |           1.759 |         1.7061 | 42.9 |
|   1.3035 |   80.2 |   115.1 |    174.1 |          1.7518 |         1.7025 | 44.6 |
|   1.3331 |   83.7 |   116.8 |    174.1 |          1.7435 |         1.6924 | 46.4 |
|    1.365 |   86.7 |   118.5 |    174.1 |          1.7345 |         1.6816 | 48.1 |
|   1.3991 |   90.2 |   120.3 |    174.1 |          1.7251 |         1.6715 | 49.8 |
|   1.4353 |   92.7 |   121.8 |    174.1 |          1.7158 |         1.6655 | 51.5 |
|   1.4749 |   95.9 |   123.8 |    174.1 |          1.7043 |         1.6516 | 53.2 |
|   1.5167 |   98.8 |   125.7 |    174.1 |          1.6928 |         1.6435 | 54.9 |
|   1.5621 |  101.9 |   127.5 |    174.1 |          1.6802 |         1.6312 | 56.7 |
|   1.6113 |  104.7 |   129.4 |    174.1 |          1.6664 |         1.6161 | 58.4 |
|   1.6641 |  107.9 |   131.3 |    174.1 |          1.6517 |         1.6013 | 60.1 |
|   1.7208 |  110.8 |   133.2 |    174.1 |          1.6361 |         1.5877 | 61.8 |
|   1.7822 |  113.6 |   135.1 |    174.1 |          1.6193 |         1.5724 | 63.5 |
|   1.8485 |  116.5 |     137 |    174.1 |          1.6012 |         1.5567 | 65.2 |
|   1.9208 |  119.5 |     139 |    174.1 |          1.5814 |         1.5374 |   67 |
|    1.999 |  121.9 |     141 |    174.1 |          1.5603 |         1.5191 | 68.7 |
|   2.0846 |  125.4 |     143 |    174.1 |          1.5372 |         1.4953 | 70.4 |
|    2.178 |  128.3 |     145 |    174.1 |          1.5121 |         1.4711 | 72.1 |
|   2.2803 |  131.3 |     147 |    174.1 |          1.4849 |         1.4448 | 73.8 |
|   2.3928 |  134.3 |     149 |    174.1 |          1.4553 |          1.416 | 75.5 |
|   2.5167 |  137.2 |   151.1 |    174.1 |          1.4231 |         1.3856 | 77.3 |
|   2.6545 |  140.3 |   153.2 |    174.1 |          1.3876 |          1.351 |   79 |
|   2.8083 |  143.4 |   155.4 |    174.1 |          1.3486 |         1.3139 | 80.7 |
|   2.9816 |  146.6 |   157.6 |    174.1 |          1.3052 |         1.2729 | 82.4 |
|   3.1793 |  149.9 |   159.9 |    174.1 |          1.2563 |         1.2272 | 84.1 |

#+call: test-dragoid-diagnostic(alpha=2.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0004 |      0 |      90 |    176.8 |          1.7144 |         1.6534 |    0 |
|        1 |    3.9 |      90 |    176.8 |          1.7155 |         1.6887 |  1.8 |
|   1.0005 |    1.5 |    90.2 |    176.8 |          1.7158 |         1.7118 |  3.5 |
|   1.0024 |    9.6 |    90.4 |    176.8 |          1.7147 |         1.6838 |  5.3 |
|   1.0045 |    9.8 |    90.6 |    176.8 |          1.7143 |         1.6931 |  7.1 |
|   1.0075 |   18.2 |      91 |    176.8 |           1.713 |         1.6882 |  8.9 |
|   1.0113 |   20.3 |    91.4 |    176.8 |          1.7115 |         1.6827 | 10.6 |
|   1.0158 |   22.3 |      92 |    176.8 |          1.7096 |         1.6738 | 12.4 |
|   1.0209 |     23 |    92.5 |    176.8 |          1.7077 |         1.6719 | 14.2 |
|   1.0266 |   26.8 |    93.2 |    176.8 |          1.7057 |         1.6741 | 15.9 |
|    1.033 |   28.6 |    93.9 |    176.8 |          1.7033 |         1.6732 | 17.7 |
|   1.0402 |   32.1 |    94.9 |    176.8 |          1.7011 |         1.6751 | 19.5 |
|   1.0486 |   35.7 |    95.5 |    176.8 |          1.6977 |         1.6603 | 21.3 |
|   1.0574 |     36 |    96.8 |    176.8 |          1.6939 |          1.657 |   23 |
|    1.067 |   42.1 |    97.4 |    176.8 |           1.691 |         1.6541 | 24.8 |
|   1.0776 |     44 |    98.9 |    176.8 |          1.6869 |         1.6487 | 26.6 |
|   1.0887 |   46.6 |    99.7 |    176.8 |          1.6834 |          1.651 | 28.4 |
|   1.1014 |   51.6 |   100.7 |    176.8 |          1.6781 |         1.6407 | 30.1 |
|   1.1141 |   58.2 |   102.3 |    176.8 |          1.6731 |         1.6451 | 31.9 |
|   1.1289 |   58.4 |   103.4 |    176.8 |          1.6675 |         1.6334 | 33.7 |
|   1.1441 |   58.5 |   104.8 |    176.8 |          1.6615 |         1.6357 | 35.4 |
|   1.1606 |   63.5 |   106.2 |    176.8 |          1.6558 |         1.6348 | 37.2 |
|   1.1794 |   67.5 |   107.6 |    176.8 |          1.6478 |         1.6137 |   39 |
|    1.199 |   72.6 |   108.6 |    176.8 |          1.6393 |         1.5924 | 40.8 |
|   1.2192 |   72.8 |   111.3 |    176.8 |          1.6317 |         1.5831 | 42.5 |
|   1.2404 |   74.6 |   111.7 |    176.8 |          1.6249 |         1.5781 | 44.3 |
|   1.2626 |   79.6 |   113.5 |    176.8 |          1.6159 |         1.5782 | 46.1 |
|   1.2873 |   80.2 |   115.4 |    176.8 |          1.6084 |         1.5695 | 47.8 |
|   1.3153 |   82.7 |     117 |    176.8 |          1.5963 |         1.5405 | 49.6 |
|   1.3431 |     89 |   118.8 |    176.8 |          1.5837 |         1.5429 | 51.4 |
|   1.3731 |   89.5 |   119.8 |    176.8 |          1.5721 |         1.5302 | 53.2 |
|   1.4045 |   92.1 |     122 |    176.8 |          1.5613 |         1.5221 | 54.9 |
|   1.4384 |   95.3 |   124.2 |    176.8 |          1.5484 |         1.5125 | 56.7 |
|   1.4752 |   99.1 |     125 |    176.8 |          1.5343 |         1.4943 | 58.5 |
|   1.5139 |  100.5 |   127.2 |    176.8 |          1.5197 |         1.4759 | 60.3 |
|   1.5548 |  103.5 |   129.3 |    176.8 |          1.5046 |         1.4664 |   62 |
|   1.5985 |  106.8 |   131.2 |    176.8 |          1.4893 |         1.4531 | 63.8 |
|   1.6453 |  108.5 |     132 |    176.8 |           1.472 |           1.44 | 65.6 |
|   1.6978 |  111.7 |   134.9 |    176.8 |          1.4519 |         1.4072 | 67.3 |
|   1.7537 |  115.4 |   136.4 |    176.8 |          1.4314 |         1.3821 | 69.1 |
|   1.8101 |  117.2 |   138.5 |    176.8 |          1.4126 |         1.3756 | 70.9 |
|   1.8746 |  121.8 |   140.6 |    176.8 |          1.3895 |         1.3515 | 72.7 |
|   1.9434 |  124.5 |   143.2 |    176.8 |          1.3651 |         1.3275 | 74.4 |
|   2.0175 |  127.3 |   144.3 |    176.8 |          1.3394 |          1.303 | 76.2 |
|   2.0992 |  131.2 |   146.6 |    176.8 |          1.3113 |         1.2731 |   78 |
|   2.1869 |  133.6 |   149.4 |    176.8 |          1.2816 |         1.2516 | 79.7 |
|   2.2864 |  137.8 |     152 |    176.8 |          1.2478 |         1.2161 | 81.5 |
|   2.3954 |  140.6 |   154.2 |    176.8 |          1.2115 |         1.1847 | 83.3 |
|   2.5197 |  144.1 |   157.2 |    176.8 |            1.17 |         1.1474 | 85.1 |
|   2.6646 |  149.4 |   159.8 |    176.8 |          1.1222 |          1.105 | 86.8 |

#+call: test-dragoid-diagnostic(alpha=1.0, mu=0.2)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   0.9997 |      0 |      90 |    152.4 |          2.0696 |         2.0097 |    0 |
|   0.9999 |    2.2 |      90 |    152.4 |          2.0698 |         2.0146 |  1.3 |
|   1.0006 |    5.7 |    90.1 |    152.4 |          2.0702 |           2.02 |  2.5 |
|   1.0019 |    7.7 |    90.3 |    152.4 |          2.0704 |         2.0216 |  3.8 |
|   1.0036 |    9.8 |    90.5 |    152.4 |          2.0709 |         2.0244 |  5.1 |
|    1.006 |   13.1 |    90.8 |    152.4 |          2.0713 |         2.0229 |  6.4 |
|   1.0089 |   15.3 |    91.1 |    152.4 |          2.0718 |         2.0224 |  7.6 |
|   1.0124 |   18.3 |    91.5 |    152.4 |          2.0725 |         2.0222 |  8.9 |
|   1.0164 |   20.7 |    91.9 |    152.4 |          2.0732 |         2.0244 | 10.2 |
|   1.0211 |   23.9 |    92.4 |    152.4 |          2.0735 |         2.0195 | 11.5 |
|   1.0263 |   26.2 |      93 |    152.4 |          2.0744 |           2.02 | 12.7 |
|   1.0321 |     29 |    93.6 |    152.4 |          2.0756 |         2.0197 |   14 |
|   1.0386 |   31.3 |    94.2 |    152.4 |          2.0766 |         2.0198 | 15.3 |
|   1.0459 |   34.5 |    94.9 |    152.4 |          2.0769 |         2.0101 | 16.6 |
|   1.0539 |   37.4 |    95.7 |    152.4 |          2.0775 |         2.0046 | 17.8 |
|   1.0622 |   39.5 |    96.5 |    152.4 |           2.079 |         2.0117 | 19.1 |
|   1.0714 |   42.1 |    97.4 |    152.4 |            2.08 |         2.0099 | 20.4 |
|   1.0817 |   44.7 |    98.3 |    152.4 |          2.0808 |         2.0021 | 21.7 |
|   1.0926 |   47.2 |    99.3 |    152.4 |          2.0818 |         1.9986 | 22.9 |
|   1.1046 |   50.7 |   100.3 |    152.4 |          2.0825 |         1.9859 | 24.2 |
|   1.1173 |     53 |   101.4 |    152.4 |          2.0835 |         1.9818 | 25.5 |
|   1.1303 |   55.4 |   102.4 |    152.4 |          2.0858 |           1.99 | 26.7 |
|   1.1448 |   58.4 |   103.6 |    152.4 |          2.0874 |         1.9868 |   28 |
|   1.1608 |   61.6 |   104.7 |    152.4 |           2.088 |         1.9732 | 29.3 |
|   1.1771 |   63.9 |     106 |    152.4 |          2.0905 |         1.9783 | 30.6 |
|   1.1948 |   66.1 |   107.1 |    152.4 |          2.0923 |         1.9779 | 31.8 |
|   1.2149 |   69.9 |   108.4 |    152.4 |          2.0924 |         1.9516 | 33.1 |
|   1.2339 |   70.9 |   109.7 |    152.4 |          2.0966 |         1.9797 | 34.4 |
|   1.2566 |   74.5 |     111 |    152.4 |          2.0971 |         1.9583 | 35.7 |
|   1.2796 |   77.3 |   112.5 |    152.4 |          2.1001 |         1.9612 | 36.9 |
|   1.3041 |   79.3 |   113.8 |    152.4 |           2.103 |           1.97 | 38.2 |
|   1.3322 |   82.5 |   115.2 |    152.4 |          2.1036 |          1.944 | 39.5 |
|   1.3611 |   85.2 |   116.7 |    152.4 |           2.106 |         1.9394 | 40.8 |
|   1.3904 |   87.6 |   118.2 |    152.4 |          2.1112 |           1.96 |   42 |
|   1.4232 |   90.2 |   119.7 |    152.4 |          2.1146 |         1.9616 | 43.3 |
|   1.4628 |   93.6 |   121.2 |    152.4 |          2.1122 |         1.9033 | 44.6 |
|   1.4978 |   95.6 |   122.7 |    152.4 |          2.1209 |         1.9452 | 45.9 |
|     1.54 |   98.3 |   124.3 |    152.4 |          2.1236 |         1.9314 | 47.1 |
|   1.5848 |  101.3 |   125.9 |    152.4 |          2.1281 |         1.9241 | 48.4 |
|   1.6322 |  103.6 |   127.6 |    152.4 |          2.1345 |         1.9342 | 49.7 |
|   1.6868 |  106.4 |   129.2 |    152.4 |           2.138 |         1.9082 | 50.9 |
|    1.742 |    109 |   130.9 |    152.4 |          2.1475 |         1.9239 | 52.2 |
|   1.8058 |  111.9 |   132.7 |    152.4 |          2.1542 |         1.9015 | 53.5 |
|   1.8735 |  114.5 |   134.5 |    152.4 |          2.1654 |         1.9026 | 54.8 |
|   1.9493 |  116.9 |   136.3 |    152.4 |          2.1777 |         1.8921 |   56 |
|   2.0323 |  119.6 |   138.2 |    152.4 |          2.1949 |         1.8827 | 57.3 |
|   2.1255 |  122.4 |   140.2 |    152.4 |          2.2169 |         1.8634 | 58.6 |
|   2.2236 |  125.1 |   142.3 |    152.4 |          2.2546 |         1.8871 | 59.9 |
|   2.3375 |  127.9 |   144.6 |    152.4 |          2.3056 |         1.8874 | 61.1 |
|   2.4711 |  130.8 |     147 |    152.4 |          2.3828 |         1.8615 | 62.4 |

#+call: test-dragoid-diagnostic(alpha=4.0, mu=0.2)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0022 |      0 |      90 |    172.3 |          1.6465 |         1.5869 |    0 |
|   1.0024 |    2.6 |      90 |    172.3 |          1.6465 |         1.5883 |  1.7 |
|   1.0031 |    5.3 |    90.1 |    172.3 |          1.6462 |         1.5897 |  3.4 |
|   1.0044 |    7.9 |    90.3 |    172.3 |          1.6458 |         1.5907 |    5 |
|   1.0062 |   10.6 |    90.5 |    172.3 |          1.6452 |         1.5904 |  6.7 |
|   1.0085 |   13.3 |    90.8 |    172.3 |          1.6445 |         1.5908 |  8.4 |
|   1.0113 |   16.1 |    91.2 |    172.3 |          1.6435 |         1.5901 | 10.1 |
|   1.0147 |   18.8 |    91.6 |    172.3 |          1.6423 |         1.5908 | 11.8 |
|   1.0187 |   21.4 |    92.1 |    172.3 |          1.6408 |         1.5906 | 13.4 |
|   1.0232 |   24.1 |    92.7 |    172.3 |          1.6391 |         1.5899 | 15.1 |
|   1.0283 |   27.3 |    93.3 |    172.3 |           1.637 |         1.5882 | 16.8 |
|    1.034 |   29.5 |      94 |    172.3 |          1.6349 |         1.5861 | 18.5 |
|   1.0403 |   32.4 |    94.7 |    172.3 |          1.6326 |         1.5837 | 20.2 |
|   1.0473 |     35 |    95.5 |    172.3 |          1.6296 |         1.5806 | 21.8 |
|   1.0549 |   37.7 |    96.4 |    172.3 |          1.6268 |         1.5774 | 23.5 |
|   1.0631 |   40.9 |    97.3 |    172.3 |          1.6235 |          1.574 | 25.2 |
|   1.0721 |   43.5 |    98.2 |    172.3 |          1.6201 |         1.5705 | 26.9 |
|   1.0817 |   45.9 |    99.2 |    172.3 |          1.6162 |         1.5664 | 28.6 |
|   1.0921 |   48.6 |   100.3 |    172.3 |          1.6121 |         1.5617 | 30.2 |
|   1.1033 |   52.5 |   101.3 |    172.3 |          1.6076 |         1.5557 | 31.9 |
|    1.115 |     53 |   102.6 |    172.3 |          1.6031 |          1.553 | 33.6 |
|   1.1277 |   56.4 |   103.8 |    172.3 |          1.5983 |         1.5479 | 35.3 |
|   1.1413 |   59.9 |     105 |    172.3 |          1.5929 |         1.5405 |   37 |
|   1.1556 |   62.1 |   106.2 |    172.3 |          1.5875 |         1.5363 | 38.6 |
|    1.171 |   65.1 |   107.7 |    172.3 |          1.5814 |         1.5293 | 40.3 |
|   1.1873 |   67.4 |     109 |    172.3 |          1.5752 |          1.523 |   42 |
|   1.2047 |     70 |   110.5 |    172.3 |          1.5689 |         1.5157 | 43.7 |
|    1.223 |   73.2 |     112 |    172.3 |          1.5619 |          1.508 | 45.4 |
|   1.2426 |   75.9 |   113.2 |    172.3 |          1.5546 |         1.4995 |   47 |
|   1.2635 |     79 |   114.9 |    172.3 |          1.5464 |         1.4898 | 48.7 |
|   1.2852 |     81 |   116.5 |    172.3 |          1.5389 |         1.4831 | 50.4 |
|   1.3085 |   83.9 |   118.1 |    172.3 |          1.5302 |         1.4736 | 52.1 |
|   1.3334 |     87 |     120 |    172.3 |          1.5212 |         1.4616 | 53.8 |
|   1.3595 |   89.4 |   121.5 |    172.3 |          1.5124 |         1.4521 | 55.4 |
|   1.3873 |   92.1 |   123.4 |    172.3 |          1.5029 |          1.442 | 57.1 |
|   1.4167 |   94.7 |   125.2 |    172.3 |          1.4931 |         1.4327 | 58.8 |
|   1.4483 |     98 |   127.2 |    172.3 |          1.4828 |         1.4202 | 60.5 |
|   1.4816 |  100.7 |   129.2 |    172.3 |          1.4726 |           1.41 | 62.2 |
|   1.5175 |  103.7 |   131.2 |    172.3 |          1.4615 |         1.3958 | 63.8 |
|   1.5557 |  106.3 |   133.4 |    172.3 |          1.4505 |         1.3823 | 65.5 |
|   1.5968 |  109.9 |   135.7 |    172.3 |          1.4391 |         1.3669 | 67.2 |
|   1.6408 |  112.5 |   138.2 |    172.3 |           1.428 |         1.3522 | 68.9 |
|   1.6881 |  115.9 |   140.8 |    172.3 |          1.4172 |         1.3372 | 70.6 |
|   1.7388 |  118.6 |   143.9 |    172.3 |          1.4077 |         1.3259 | 72.2 |
|   1.7946 |  121.6 |   147.3 |    172.3 |          1.3995 |         1.3111 | 73.9 |
|   1.8561 |  125.4 |     151 |    172.3 |          1.3947 |         1.2949 | 75.6 |
|   1.9243 |  129.3 |   155.4 |    172.3 |          1.3975 |          1.279 | 77.3 |
|   2.0014 |  133.7 |   160.3 |    172.3 |           1.418 |         1.2647 | 78.9 |
|   2.0909 |  138.7 |   165.4 |    172.3 |          1.4854 |         1.2544 | 80.6 |
|   2.2015 |  145.4 |   170.1 |    172.3 |          1.7232 |         1.2557 | 82.3 |

#+call: test-dragoid-diagnostic(alpha=4.0, mu=0.8)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0021 |      0 |      90 |    155.1 |          1.8601 |         1.8121 |    0 |
|   1.0023 |    2.4 |      90 |    155.1 |          1.8601 |         1.8141 |  1.3 |
|   1.0029 |    4.8 |    90.1 |    155.1 |          1.8601 |         1.8153 |  2.7 |
|    1.004 |    7.2 |    90.2 |    155.1 |            1.86 |         1.8167 |    4 |
|   1.0055 |    9.6 |    90.4 |    155.1 |          1.8597 |         1.8174 |  5.3 |
|   1.0075 |     12 |    90.7 |    155.1 |          1.8594 |          1.818 |  6.6 |
|     1.01 |   14.5 |      91 |    155.1 |           1.859 |          1.818 |    8 |
|    1.013 |     17 |    91.3 |    155.1 |          1.8585 |         1.8167 |  9.3 |
|   1.0165 |   19.5 |    91.7 |    155.1 |           1.858 |         1.8155 | 10.6 |
|   1.0204 |     22 |    92.2 |    155.1 |          1.8575 |         1.8162 |   12 |
|   1.0248 |   24.4 |    92.7 |    155.1 |          1.8568 |         1.8164 | 13.3 |
|   1.0297 |   26.7 |    93.2 |    155.1 |           1.856 |         1.8164 | 14.6 |
|   1.0352 |     29 |    93.8 |    155.1 |          1.8551 |         1.8151 | 15.9 |
|   1.0413 |   31.9 |    94.5 |    155.1 |          1.8541 |          1.813 | 17.3 |
|   1.0478 |   34.4 |    95.2 |    155.1 |          1.8531 |         1.8113 | 18.6 |
|    1.055 |   36.7 |    95.8 |    155.1 |          1.8518 |         1.8081 | 19.9 |
|   1.0628 |   39.2 |    96.7 |    155.1 |          1.8502 |          1.804 | 21.3 |
|   1.0711 |   41.5 |    97.5 |    155.1 |          1.8489 |         1.8014 | 22.6 |
|   1.0801 |     44 |    98.4 |    155.1 |          1.8474 |         1.7977 | 23.9 |
|   1.0897 |   46.9 |    99.3 |    155.1 |          1.8458 |         1.7942 | 25.3 |
|   1.0999 |   49.1 |   100.2 |    155.1 |          1.8442 |         1.7921 | 26.6 |
|   1.1111 |   51.8 |   101.3 |    155.1 |          1.8421 |         1.7848 | 27.9 |
|   1.1234 |   56.1 |   102.2 |    155.1 |          1.8391 |         1.7671 | 29.2 |
|   1.1357 |   58.8 |   103.4 |    155.1 |          1.8377 |         1.7663 | 30.6 |
|   1.1481 |   57.3 |   104.4 |    155.1 |          1.8368 |         1.7789 | 31.9 |
|   1.1624 |   61.1 |   105.7 |    155.1 |          1.8345 |          1.768 | 33.2 |
|   1.1772 |   63.5 |   106.8 |    155.1 |          1.8327 |         1.7646 | 34.6 |
|   1.1932 |   66.3 |   108.2 |    155.1 |          1.8306 |         1.7551 | 35.9 |
|   1.2098 |   68.9 |   109.4 |    155.1 |          1.8291 |         1.7508 | 37.2 |
|    1.228 |   71.5 |   110.8 |    155.1 |          1.8266 |         1.7387 | 38.5 |
|   1.2464 |   73.7 |   112.1 |    155.1 |          1.8258 |         1.7375 | 39.9 |
|   1.2663 |     76 |   113.6 |    155.1 |          1.8244 |         1.7314 | 41.2 |
|   1.2869 |   78.2 |   115.1 |    155.1 |          1.8242 |         1.7311 | 42.5 |
|   1.3089 |   80.5 |   116.6 |    155.1 |          1.8241 |         1.7284 | 43.9 |
|   1.3327 |   83.2 |   118.2 |    155.1 |          1.8242 |         1.7191 | 45.2 |
|   1.3586 |   86.1 |   119.9 |    155.1 |           1.824 |         1.7014 | 46.5 |
|   1.3843 |   88.2 |   121.7 |    155.1 |          1.8271 |         1.7063 | 47.8 |
|   1.4122 |   90.2 |   123.5 |    155.1 |          1.8308 |         1.7038 | 49.2 |
|   1.4426 |   93.4 |   125.4 |    155.1 |          1.8351 |         1.6908 | 50.5 |
|   1.4747 |   95.5 |   127.4 |    155.1 |          1.8422 |         1.6842 | 51.8 |
|   1.5086 |   98.3 |   129.5 |    155.1 |          1.8527 |           1.68 | 53.2 |
|    1.546 |  101.3 |   131.8 |    155.1 |           1.866 |          1.664 | 54.5 |
|   1.5841 |  103.6 |   134.2 |    155.1 |          1.8878 |         1.6727 | 55.8 |
|   1.6264 |  106.3 |   136.7 |    155.1 |          1.9166 |         1.6697 | 57.1 |
|   1.6721 |  109.3 |   139.3 |    155.1 |          1.9581 |          1.671 | 58.5 |
|   1.7216 |  112.2 |     142 |    155.1 |          2.0195 |         1.6805 | 59.8 |
|    1.777 |  115.8 |   144.9 |    155.1 |          2.1121 |         1.6865 | 61.1 |
|   1.8393 |  119.7 |   147.7 |    155.1 |          2.2619 |          1.697 | 62.5 |
|   1.9084 |  123.6 |   150.6 |    155.1 |          2.5358 |         1.7587 | 63.8 |
|   1.9937 |  129.4 |   153.3 |    155.1 |          3.1544 |         1.8499 | 65.1 |


*** Reproduce paper fig of R_c-R_90 for cantoid and ancantoid 

#+BEGIN_SRC python :eval no :tangle ancantoid-R90-vs-Rc.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import bow_projection as bp
  import ancantoid_shape
  import bow_diagnostic

  try: 
      xiset = sys.argv[1]
      plotfile = sys.argv[0].replace('.py', f'-{xiset}.pdf')
      assert xiset in 'ab'
      istart = -2 if xiset == 'a' else -1
  except:
      sys.exit(f"Usage: {sys.argv[0]} a|b")

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [0.3, 0.1, 0.03, 0.01, 1e-3]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = np.linspace(0.0, 1.0, 20)
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")


  cols = sns.color_palette('magma', n_colors=nxi)
  annot_pars_list = [right_annotate_pars]*2 + [left_annotate_pars]*2 
  for beta in BETA_LIST[::-1]:
      for xi, col, annot_pars in list(zip(XI_LIST, cols, annot_pars_list))[istart::-2]:
          k = None if xi is None else 2/xi - 2
          if beta == BETA_LIST[0]:
              label = "Cantoid" if k is None else fr"Ancantoid $k = {k:.1f}$"
          else:
              label = "_nolabel_"

          if xi is None:
              shape = bp.Spline_R_theta_from_function(
                  ngrid=1000,
                  shape_func=bp.cantoid_R_theta,
                  shape_func_pars=(beta,))
          else:
              shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)

          th_inf = bp.theta_infinity(shape)
          inc = np.linspace(0.0, th_inf - np.pi/2, 200)
          tab = bow_diagnostic.parameter_table(inc, shape)
          Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
          ax.plot(Rc, R90, '-', c=col, label=label, lw=0.7, alpha=0.9)

          # Get points evenly spaced in sin i
          sini = np.linspace(0.0, 1.0, 20)
          inc_e = np.arcsin(sini)
          inc_e = inc_e[inc_e < th_inf - np.pi/2]
          tab_e = bow_diagnostic.parameter_table(inc_e, shape)
          Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
          ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
                     linewidths=0.1, edgecolors='none',
                     c=col, alpha=0.5, label="_nolabel_")

          # Put a dot at the i=0 case
          ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)
          # Label the dot with the cross-over inclination
          beta_label = rf'$\beta = \mathrm{{{beta:g}}}$'
          if beta_label.endswith('1}$'):
              # But only for some of them
              ax.annotate(beta_label, xy=(Rc[0], R90[0]),
                          textcoords='offset points',
                          fontsize='x-small', color=col, **annot_pars)


  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

**** Make ancantoid graphs for two parameter sets 

#+BEGIN_SRC sh :results file
python ancantoid-R90-vs-Rc.py a
#+END_SRC

#+RESULTS:
[[file:ancantoid-R90-vs-Rc-a.pdf]]

#+BEGIN_SRC sh :results file
python ancantoid-R90-vs-Rc.py b
#+END_SRC

#+RESULTS:
[[file:ancantoid-R90-vs-Rc-b.pdf]]



**** Same but for very small beta

#+BEGIN_SRC python :eval no :tangle ancantoid-R90-vs-Rc-lobeta.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import bow_projection as bp
  import ancantoid_shape
  import bow_diagnostic

  try: 
      xiset = sys.argv[1]
      plotfile = sys.argv[0].replace('.py', f'-{xiset}.pdf')
      assert xiset in 'ab'
      istart = -2 if xiset == 'a' else -1
  except:
      sys.exit(f"Usage: {sys.argv[0]} a|b")

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  left_annotate_pars = dict(xytext=(-5, 5), ha='right', va='bottom')
  right_annotate_pars = dict(xytext=(5, -5), ha='left', va='top')


  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  XI_LIST = [None, 1.0, 0.8, 0.4]
  BETA_LIST = [1e-3, 1e-4, 1e-5]
  nxi, nbeta = len(XI_LIST), len(BETA_LIST)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = np.linspace(0.0, 1.0, 20)
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")


  cols = sns.color_palette('magma', n_colors=nxi)
  annot_pars_list = [right_annotate_pars]*4 
  for beta in BETA_LIST[::-1]:
      for xi, col, annot_pars in list(zip(XI_LIST, cols, annot_pars_list))[istart::-2]:
          k = None if xi is None else 2/xi - 2
          if beta == BETA_LIST[0]:
              label = "Cantoid" if k is None else fr"Ancantoid $k = {k:.1f}$"
          else:
              label = "_nolabel_"

          if xi is None:
              shape = bp.Spline_R_theta_from_function(
                  ngrid=1000,
                  shape_func=bp.cantoid_R_theta,
                  shape_func_pars=(beta,))
          else:
              shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)

          th_inf = bp.theta_infinity(shape)
          inc = np.linspace(0.0, th_inf - np.pi/2, 200)
          tab = bow_diagnostic.parameter_table(inc, shape)
          Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
          ax.plot(Rc, R90, '-', c=col, label=label, lw=0.7, alpha=0.9)

          # Get points evenly spaced in sin i
          sini = np.linspace(0.0, 1.0, 20)
          inc_e = np.arcsin(sini)
          inc_e = inc_e[inc_e < th_inf - np.pi/2]
          tab_e = bow_diagnostic.parameter_table(inc_e, shape)
          Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
          ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
                     linewidths=0.1, edgecolors='none',
                     c=col, alpha=0.5, label="_nolabel_")

          # Put a dot at the i=0 case
          ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)
          # Label the dot with the cross-over inclination
          beta_label = rf'$\beta = 10^{{{int(np.log10(beta)):d}}}$'
          # But only for some of them
          ax.annotate(beta_label, xy=(Rc[0], R90[0]),
                      textcoords='offset points',
                      fontsize='x-small', color=col, **annot_pars)


  ax.legend(ncol=1, fontsize='small', frameon=True)
  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[1.3, 2.0],
      ylim=[1.3, 2.0],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python ancantoid-R90-vs-Rc-lobeta.py a
#+END_SRC

#+RESULTS:
[[file:ancantoid-R90-vs-Rc-lobeta-a.pdf]]

*** Figure of R_c-R_90 for the dragoids
This is something I never got finished for the multi-quadric fits

#+BEGIN_SRC python :eval no :tangle dragoid-R90-vs-Rc.py
  import sys
  import numpy as np
  from scipy.interpolate import interp1d
  import statsmodels.api as sm
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  import bow_projection as bp
  import dragoid_shape
  import bow_diagnostic


  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = (0.5 + np.arange(20))/20
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")

  # For dragoids, widen the region for fitting R_c
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03

  ALPHA_LIST = [0.25, 1.0, 1.0, 1.0, 4.0, 4.0]
  MU_LIST = [None, None, 0.05, 0.2, 0.2, 0.8]
  nalpha = len(ALPHA_LIST)
  cols = sns.color_palette(n_colors=nalpha)
  for alpha, mu, col in list(zip(ALPHA_LIST, MU_LIST, cols))[::-1]:
      shape = dragoid_shape.Dragoid(alpha=alpha, mu=mu, lowess_frac=0.1)
      th_inf = bp.theta_infinity(shape)
      inc = np.linspace(0.0, th_inf - np.pi/2, 50)
      tab = bow_diagnostic.parameter_table(inc, shape)
      Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']

      Rcs = sm.nonparametric.lowess(Rc, inc, frac=0.3,
                                    is_sorted=True, return_sorted=False)
      #Rcs = Rc
      Rcs[0] = Rc[0]
      ax.plot(Rcs, R90, '-', c=col, label=shape.label, lw=0.7, alpha=0.9)

      # Get points evenly spaced in sin i
      sini = (0.5 + np.arange(20))/20
      inc_e = np.arcsin(sini)
      inc_e = inc_e[inc_e < th_inf - np.pi/2]
      # Interpolate to get the even probability points
      Rc_e = interp1d(inc, Rcs)(inc_e)
      R90_e = interp1d(inc, R90)(inc_e)

      ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
                 linewidths=0.1, edgecolors='none',
                 c=col, alpha=0.5, label="_nolabel_")

      # Put a dot at the i=0 case
      ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=col, label="_nolabel_", alpha=0.7)


  ax.legend(ncol=1, fontsize='small', title='Dragoids',
            frameon=True, loc="lower right")
  ax.set(
      xlim=[0.9, 2.7],
      ylim=[0.9, 2.7],
      yticks=[1.0, 1.5, 2.0, 2.5],
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python dragoid-R90-vs-Rc.py
#+END_SRC

#+RESULTS:
[[file:dragoid-R90-vs-Rc.pdf]]




** Standing wave perturbations


*** ~standing_wave.py~: class for perturbed shell 
#+BEGIN_SRC python :eval no :tangle standing_wave.py
  import numpy as np

  class StandingWave(object):

      def __init__(self, base_shape, amplitude, wavenumber, phase=0.0, **base_shape_kwds):
          """
          Constant amplitude standing wave with antinode on x-axis (theta = 0)

          Parameters
          ----------
          base_shape : callable
              Underlying R(theta) shape to be perturbed
          amplitude
              Relative amplitude of radial oscillation
          wavenumber
              Angular wavenumber of oscillation. With `wavenumber = 1.0` there will
              be a node on the y-axis (theta = pi/2). With `wavenumber = 2.0` there
              will be an anti-node on the y-axis that is out of phase with the
              node on the x-axis.
          phase : optional
              Temporal phase of the oscillation. The amplitude is multiplied
              by `cos(2 pi phase)`, so that When `phase = 0` the radial perturbation
              is positive at `theta = 0`, whereas when `phase = 0.5` the radial
              perturbation is negative at `theta = 0`.  For `phase = 0.25, 0.75`
              the perturbation is zero for all `theta`.
          ,**base_shape_kwds : optional
              Any unrecognised args are passed on to the unperturbed radius
              function: `base_shape(theta, **base_shape_kwds)` 


          """
          self.base_shape = base_shape
          self.amplitude = amplitude
          self.wavenumber = wavenumber
          self.phase = phase
          self.base_shape_kwds = base_shape_kwds

      def __call__(self, theta):
          """
          Radius as function of `theta` for standing wave
          """
          return ((1.0 + self.perturbation(theta)) *
                  self.base_shape(theta, **self.base_shape_kwds))

      def perturbation(self, theta):
          """
          Fractional perturbation of `base_shape` radius at each angle `theta`
          """
          return (self.amplitude *
                  np.cos(2*np.pi*self.phase) *
                  np.cos(self.wavenumber*theta))

#+END_SRC


*** Test the slopes for the standing waves
#+BEGIN_SRC python :eval no :tangle test_slope_wave.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  import standing_wave

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)
  
  amplitude, wavenumber = 0.001, 20.0
  shape = standing_wave.StandingWave(
      bp.wilkinoid_R_theta, amplitude=amplitude, wavenumber=wavenumber)
  phases = [0.0, 0.25, 0.5]
  for phase in phases:
      shape.phase = phase
      alpha_slope = np.degrees(bp.alpha(th, shape))
      ax.plot(th_dg, (90.0 - alpha_slope)/th_dg,
              lw=0.8, label=f"phase {phase:.2f}")

  ax.legend(title=rf"$A = {amplitude:.1f}$, $N = {wavenumber:.1f}$")
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"Slope angle, $(90 - \alpha)/\theta$",
      xlim=[0, 180],
      ylim=[0, 1.1],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')

#+END_SRC
#+BEGIN_SRC sh :results file
python test_slope_wave.py
#+END_SRC

#+RESULTS:
[[file:test_slope_wave.pdf]]

*** Test the xy shapes for standing waves
#+BEGIN_SRC python :eval no :tangle test_xyprime_wave.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  import standing_wave

  try:
      amplitude = float(sys.argv[1])
      wavenumber = float(sys.argv[2])
  except:
      sys.exit(f"Usage: {sys.argv[0]} AMPLITUDE WAVENUMBER")


  figfile = sys.argv[0].replace(
      '.py', f'-A{int(100*amplitude):03d}-N{int(10*wavenumber):02d}.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(8, 8))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette(palette="magma_r", n_colors=len(inclinations))


  shape = standing_wave.StandingWave(
      bp.wilkinoid_R_theta, amplitude=amplitude, wavenumber=wavenumber)

  phases = np.linspace(0.0, 0.5, len(axes.flat))
  for phase, ax in zip(phases, axes.flat):
      shape.phase = phase
      label = f"Phase = ${phase:.2f}$"
      th_inf = bp.theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = bp.theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=1, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-7, 3],
          ylim=[-5, 5],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

**** Wilkinoid, Wavenumber 1.0, Amplitude 0.1
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.1 1.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A010-N10.pdf]]

Note that for phase = 0.12, the effect of the perturbation is to push the shape closer to the paraboloid, with the result that varying the inclination makes no difference

#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.3 1.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A030-N10.pdf]]


**** Wilkinoid, Wavenumber 2.0, Amplitude 0.05
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.05 2.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A005-N20.pdf]]

#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.15 2.0
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A015-N20.pdf]]

**** Wilkinoid, Wavenumber 1.5, Amplitude 0.1
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.1 1.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A010-N15.pdf]]

This one more clearly shows the difference between 
1. phase = 0, where the i = 0 shape is pointy, becoming flatter as inc increases
2. phase = 0.5, where the i = 0 shapes is flat, and it becomes pointier as inc increases

**** Wilkinoid, Wavenumber 2.5, Amplitude 0.07
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.07 2.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A007-N25.pdf]]



**** Wilkinoid, Wavenumber 4.5, Amplitude 0.05
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.05 4.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A005-N45.pdf]]

Having such a high wave number is a bit silly, but it does show new behaviour: we can get the perturbations in R_c and R_90 having opposite signs

**** Wilkinoid, Wavenumber 5, Amplitude 0.01
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.01 5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A001-N50.pdf]]

**** Wilkinoid, Wavenumber 5.5, Amplitude 0.3
#+BEGIN_SRC sh :results file
python test_xyprime_wave.py 0.3 5.5
#+END_SRC

#+RESULTS:
[[file:test_xyprime_wave-A030-N55.pdf]]

This one is very silly. For phase = 0.5 it looks like a duck





*** Same again, but zooming in and allowing different shapes

#+BEGIN_SRC python :eval no :tangle wave_xyprime.py
  import sys
  import scanf
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  import ancantoid_shape
  import dragoid_shape
  import standing_wave

  try:
      AMPLITUDE = float(sys.argv[1])
      WAVENUMBER = float(sys.argv[2])
      BASE_SHAPE_ID = sys.argv[3]
  except:
      sys.exit(f"Usage: {sys.argv[0]} AMPLITUDE WAVENUMBER BASE_SHAPE_ID")


  figfile = sys.argv[0].replace(
      '.py', f'-A{int(100*AMPLITUDE):03d}-N{int(10*WAVENUMBER):02d}'
      f'-{BASE_SHAPE_ID}.pdf')

  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"


  sns.set_style('ticks')
  fig, axes = plt.subplots(1, 3, figsize=(9, 4))

  inclinations = [0, 15, 30, 45, 60, 75]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette(palette="magma_r", n_colors=len(inclinations))


  shape = standing_wave.StandingWave(
      base_shape, amplitude=AMPLITUDE, wavenumber=WAVENUMBER)

  phases = np.linspace(0.0, 0.5, len(axes.flat))
  for phase, ax in zip(phases, axes.flat):
      shape.phase = phase
      label = f"Phase = ${phase:.2f}$"
      th_inf = bp.theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = bp.theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inc, shape)
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:d}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=label, ncol=1, loc="center left")
      ax.set(
          xlabel=r"$x' / R_0'$",
          ylabel=r"$y' / R_0'$",
          xlim=[-2.5, 1.2],
          ylim=[-3, 3],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.05 2.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A005-N20-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.1 1.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A010-N10-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.05 2.0 dragoid-alpha100
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A005-N20-dragoid-alpha100.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.4 2.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A040-N20-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.1 6.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A010-N60-ancantoid-xi080-beta000500.pdf]]

#+BEGIN_SRC sh :results file
python wave_xyprime.py 0.04 10.0 ancantoid-xi080-beta000500
#+END_SRC

#+RESULTS:
[[file:wave_xyprime-A004-N100-ancantoid-xi080-beta000500.pdf]]


*** Zoom and compare different waves in (x, y) shape @ inc=0 

#+BEGIN_SRC python :eval no :tangle compare_xyprime_wave.py
  import sys
  import scanf
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  import bow_projection as bp
  import standing_wave

  try:
      BASE_SHAPE_ID = sys.argv[1]
  except:
      sys.exit(f"Usage: {sys.argv[0]} BASE_SHAPE_ID")


  figfile = sys.argv[0].replace(
      '.py', f'-{BASE_SHAPE_ID}.pdf')

  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"

  sns.set_style('ticks')
  fig, axes = plt.subplots(1, 3, figsize=(8, 4))

  # Different phases are different lines on same graph
  phases = [0.0, 0.25, 0.5]
  phase_labels = ["phase = 0.0, 1.0", "phase = 0.25, 0.75", "phase = 0.5"]
  colors = 'b', 'k', 'r'
  linewidths = [2, 1, 2]
  # Different (amplitude, wavenumber) are different panels
  amplitudes = [0.1, 0.05, 0.02]
  wavenumbers = [1.0, 2.0, 5.0]

  # All are for zero inclination
  inclination = 0.0

  for amplitude, wavenumber, ax in zip(amplitudes, wavenumbers, axes.flat):
      shape = standing_wave.StandingWave(
          base_shape, amplitude=amplitude, wavenumber=wavenumber)
      wave_label = fr"$A = {amplitude}$, $N = {wavenumber}$"
      th_inf = bp.theta_infinity(shape)
      for phase, phase_label, color, lw in zip(phases, phase_labels, colors, linewidths):
          shape.phase = phase
          th0, th90 = bp.theta_0_90(inclination, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inclination, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inclination, shape)
          R0p = radii['R_0 prime']
          R0p = 1.0
          ax.plot(xxp/R0p, yyp/R0p, label=phase_label, color=color, lw=lw)

      ax.plot([0], [0], 'o', color='k')
      ax.axhline(0, color='k', lw=0.8)
      ax.legend(title=wave_label, ncol=1, loc="upper right")
      ax.set(
          xlabel=r"$x / R_0$",
          ylabel=r"$y / R_0$",
          xlim=[-2.5, 1.5],
          ylim=[-0.5, 4.8],
          xticks=[-2, -1, 0, 1],
          yticks=[0, 1, 2, 3],
      )
      ax.set_aspect('equal', adjustable='box')

  sns.despine(bottom=True)
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python compare_xyprime_wave.py wilkinoid
#+END_SRC

#+RESULTS:
[[file:compare_xyprime_wave-wilkinoid.pdf]]

#+BEGIN_SRC sh :results file
python compare_xyprime_wave.py cantoid-beta010000
#+END_SRC

#+RESULTS:
[[file:compare_xyprime_wave-cantoid-beta010000.pdf]]


*** Animate the waves @ inc = 0
:PROPERTIES:
:ID:       CAB16D0A-7B6A-4E49-AAB6-41A0955E55E2
:END:
#+BEGIN_SRC python :eval no :tangle animate_xyprime_wave.py
  import sys
  import scanf
  import numpy as np
  from matplotlib import pyplot as plt
  from matplotlib import animation
  import seaborn as sns
  import bow_projection as bp
  import standing_wave

  try:
      BASE_SHAPE_ID = sys.argv[1]
  except:
      sys.exit(f"Usage: {sys.argv[0]} BASE_SHAPE_ID")


  fileroot = sys.argv[0].replace('.py', f'-{BASE_SHAPE_ID}')

  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"

  sns.set_style('ticks')
  fig, axes = plt.subplots(1, 3, figsize=(8, 4))

  # Different (amplitude, wavenumber) are different panels
  amplitudes = [0.1, 0.05, 0.02]
  wavenumbers = [1.0, 2.0, 5.0]

  # All are for zero inclination
  inclination = 0.0

  th_inf = bp.theta_infinity(base_shape)

  line_artists = {}
  for amplitude, wavenumber, ax in zip(amplitudes, wavenumbers, axes.flat):
      wave_label = fr"$A = {amplitude}$, $N = {wavenumber}$"
      # artist that will get animated for the different phases
      line_artists[(amplitude, wavenumber)], = ax.plot([], [],
                                                       lw=2, alpha=0.7,
                                                       color='r', label='perturbed')
      # plot the base shape
      th = np.linspace(0.0, th_inf, 301)
      xp, yp = bp.xyprime_t(th, inclination, base_shape)
      m = np.isfinite(xp) & np.isfinite(yp)
      xxp = np.concatenate((xp[m][::-1], xp[m]))
      yyp = np.concatenate((-yp[m][::-1], yp[m]))
      ax.plot(xxp, yyp, 'k', lw=1, label='base')
      # 
      ax.plot([0], [0], 'o', color='k')
      ax.axhline(0, color='k', lw=0.8)
      ax.legend(title=wave_label, ncol=1, loc="upper right")
      ax.set(
          xlabel=r"$x / R_0$",
          ylabel=r"$y / R_0$",
          xlim=[-2.5, 1.5],
          ylim=[-0.5, 4.8],
          xticks=[-2, -1, 0, 1],
          yticks=[0, 1, 2, 3],
      )
      ax.set_aspect('equal', adjustable='box')


  def animate_bows(phase):
      for amplitude, wavenumber, ax in zip(amplitudes, wavenumbers, axes.flat):
          shape = standing_wave.StandingWave(base_shape,
                                             amplitude=amplitude,
                                             wavenumber=wavenumber)
          th_inf = bp.theta_infinity(shape)
          shape.phase = phase
          th0, th90 = bp.theta_0_90(inclination, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = bp.xyprime_t(th, inclination, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = bp.characteristic_radii_projected(inclination, shape)
          R0p = radii['R_0 prime']
          R0p = 1.0
          x = xxp/R0p
          y = yyp/R0p
          line_artists[(amplitude, wavenumber)].set_data(x, y)
      return line_artists.values()

  sns.despine(bottom=True)
  fig.tight_layout()

  anim = animation.FuncAnimation(fig, animate_bows,
                                 frames=np.linspace(0, 1.0, 50),
                                 blit=True)
  moviefile = fileroot + '.mp4'
  anim.save(moviefile, writer='ffmpeg', fps=60, dpi=200)
  print(moviefile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python animate_xyprime_wave.py wilkinoid
#+END_SRC

#+RESULTS:
[[file:animate_xyprime_wave-wilkinoid.mp4]]

*** Characteristic radii for standing wave

**** Wilkinoid
#+name: test-wave-diagnostic
#+header: :var phase=0.0 amplitude=0.1 wavenumber=1.0
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic
  import standing_wave

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = standing_wave.StandingWave(
      bp.wilkinoid_R_theta, amplitude=amplitude, wavenumber=wavenumber, phase=phase)
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 19)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-wave-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|      1.1 |      0 |      90 |      180 |          1.5746 |         1.4474 |   0 |
|   1.1019 |    7.2 |    90.3 |      180 |          1.5747 |         1.4475 |   5 |
|   1.1076 |   14.5 |    91.2 |      180 |          1.5751 |         1.4479 |  10 |
|   1.1172 |   21.9 |    92.7 |      180 |          1.5758 |         1.4487 |  15 |
|   1.1311 |   29.3 |    94.8 |      180 |          1.5768 |         1.4497 |  20 |
|   1.1497 |   36.9 |    97.4 |      180 |          1.5781 |         1.4511 |  25 |
|   1.1736 |   44.7 |   100.7 |      180 |          1.5797 |         1.4528 |  30 |
|   1.2036 |   52.7 |   104.5 |      180 |          1.5817 |         1.4549 |  35 |
|    1.241 |     61 |   108.9 |      180 |          1.5841 |         1.4575 |  40 |
|   1.2875 |   69.7 |   113.8 |      180 |           1.587 |         1.4606 |  45 |
|   1.3455 |     79 |   119.3 |      180 |          1.5904 |         1.4644 |  50 |
|    1.419 |   88.8 |   125.4 |      180 |          1.5944 |          1.469 |  55 |
|    1.514 |   99.4 |     132 |      180 |          1.5989 |         1.4747 |  60 |
|   1.6408 |  110.9 |   139.1 |      180 |          1.6036 |         1.4816 |  65 |
|   1.8184 |  123.4 |   146.7 |      180 |          1.6081 |         1.4892 |  70 |
|   2.0864 |  136.6 |   154.6 |      180 |          1.6117 |         1.4963 |  75 |
|   2.5463 |  150.6 |   162.9 |      180 |          1.6133 |         1.5009 |  80 |
|   3.5983 |  165.1 |   171.4 |      180 |          1.6129 |         1.5014 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |


***** Tables for amplitude=0.1 wavenumber=1.0
#+call: test-wave-diagnostic(phase=0.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|      1.1 |      0 |      90 |      180 |          1.5746 |         1.4465 |   0 |
|   1.1019 |    7.2 |    90.3 |      180 |          1.5747 |         1.4458 |   5 |
|   1.1076 |   14.5 |    91.2 |      180 |          1.5751 |         1.4452 |  10 |
|   1.1173 |   21.9 |    92.7 |      180 |          1.5757 |         1.4448 |  15 |
|   1.1312 |   29.3 |    94.8 |      180 |          1.5767 |         1.4448 |  20 |
|   1.1498 |   36.9 |    97.4 |      180 |          1.5779 |         1.4451 |  25 |
|   1.1738 |   44.7 |   100.7 |      180 |          1.5795 |         1.4453 |  30 |
|   1.2038 |   52.7 |   104.5 |      180 |          1.5815 |         1.4468 |  35 |
|   1.2412 |     61 |   108.9 |      180 |          1.5838 |         1.4485 |  40 |
|   1.2877 |   69.7 |   113.8 |      180 |          1.5867 |         1.4504 |  45 |
|   1.3458 |     79 |   119.3 |      180 |          1.5901 |         1.4538 |  50 |
|   1.4194 |   88.8 |   125.4 |      180 |           1.594 |         1.4583 |  55 |
|   1.5143 |   99.4 |     132 |      180 |          1.5986 |         1.4647 |  60 |
|   1.6412 |  110.9 |   139.1 |      180 |          1.6033 |         1.4712 |  65 |
|   1.8187 |  123.4 |   146.7 |      180 |          1.6079 |         1.4796 |  70 |
|   2.0867 |  136.6 |   154.6 |      180 |          1.6114 |         1.4868 |  75 |
|   2.5469 |  150.6 |   162.9 |      180 |           1.613 |         1.4909 |  80 |
|   3.5989 |  165.1 |   171.4 |      180 |          1.6126 |         1.4922 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.5)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|      0.9 |      0 |      90 |      180 |          1.9245 |         2.0427 |   0 |
|   0.9036 |   10.2 |    90.4 |      180 |          1.9225 |          2.034 |   5 |
|   0.9145 |   20.3 |    91.5 |      180 |          1.9168 |         2.0153 |  10 |
|   0.9327 |   30.1 |    93.4 |      180 |          1.9078 |         1.9887 |  15 |
|   0.9585 |   39.6 |    95.9 |      180 |          1.8958 |         1.9577 |  20 |
|   0.9926 |   48.8 |    99.1 |      180 |          1.8811 |         1.9213 |  25 |
|   1.0356 |   57.8 |   102.8 |      180 |          1.8647 |         1.8861 |  30 |
|   1.0888 |   66.7 |     107 |      180 |          1.8463 |         1.8472 |  35 |
|   1.1535 |   75.3 |   111.6 |      180 |          1.8267 |         1.8123 |  40 |
|   1.2326 |     84 |   116.7 |      180 |          1.8057 |         1.7741 |  45 |
|    1.329 |   92.6 |   122.1 |      180 |          1.7839 |         1.7407 |  50 |
|   1.4482 |  101.4 |   127.9 |      180 |           1.761 |         1.7057 |  55 |
|    1.598 |  110.4 |   134.1 |      180 |          1.7371 |         1.6711 |  60 |
|   1.7914 |  119.8 |   140.7 |      180 |          1.7123 |         1.6349 |  65 |
|   2.0512 |  129.7 |   147.7 |      180 |          1.6873 |         1.6017 |  70 |
|   2.4258 |  140.3 |   155.1 |      180 |          1.6621 |         1.5667 |  75 |
|   3.0374 |  152.1 |   163.1 |      180 |          1.6385 |          1.532 |  80 |
|   4.3695 |  165.3 |   171.4 |      180 |          1.6197 |          1.504 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.25)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|        1 |      0 |      90 |      180 |          1.7321 |         1.6667 |   0 |
|   1.0025 |    8.3 |    90.3 |      180 |          1.7317 |         1.6663 |   5 |
|   1.0102 |   16.7 |    91.4 |      180 |          1.7307 |          1.665 |  10 |
|   1.0233 |   25.1 |      93 |      180 |          1.7291 |         1.6629 |  15 |
|   1.0421 |   33.5 |    95.4 |      180 |          1.7267 |           1.66 |  20 |
|   1.0672 |     42 |    98.3 |      180 |          1.7236 |         1.6561 |  25 |
|   1.0994 |   50.6 |   101.8 |      180 |          1.7197 |         1.6513 |  30 |
|   1.1398 |   59.3 |   105.8 |      180 |          1.7151 |         1.6454 |  35 |
|     1.19 |   68.2 |   110.4 |      180 |          1.7095 |         1.6384 |  40 |
|    1.252 |   77.2 |   115.4 |      180 |           1.703 |         1.6302 |  45 |
|    1.329 |   86.5 |   120.9 |      180 |          1.6954 |         1.6205 |  50 |
|   1.4254 |     96 |   126.8 |      180 |          1.6867 |         1.6093 |  55 |
|   1.5485 |  105.9 |   133.2 |      180 |          1.6769 |         1.5964 |  60 |
|   1.7097 |  116.3 |     140 |      180 |          1.6658 |         1.5816 |  65 |
|   1.9302 |  127.2 |   147.2 |      180 |          1.6536 |         1.5647 |  70 |
|   2.2533 |  138.9 |   154.9 |      180 |          1.6407 |         1.5461 |  75 |
|   2.7906 |  151.5 |     163 |      180 |          1.6277 |         1.5264 |  80 |
|   3.9834 |  165.2 |   171.4 |      180 |          1.6168 |         1.5086 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |


***** Tables for wavenumber=2
#+call: test-wave-diagnostic(phase=0.0, wavenumber=2.0, amplitude=0.05)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|     1.05 |      0 |      90 |      180 |          1.5671 |         1.2643 |   0 |
|   1.0511 |    6.3 |    90.3 |      180 |          1.5692 |         1.2658 |   5 |
|   1.0544 |   12.8 |    91.4 |      180 |          1.5755 |         1.2712 |  10 |
|   1.0601 |   19.4 |    93.1 |      180 |          1.5861 |         1.2812 |  15 |
|   1.0687 |   26.2 |    95.5 |      180 |          1.6011 |          1.296 |  20 |
|   1.0808 |   33.5 |    98.6 |      180 |          1.6206 |         1.3173 |  25 |
|   1.0974 |   41.5 |   102.3 |      180 |          1.6442 |         1.3473 |  30 |
|   1.1204 |   50.4 |   106.5 |      180 |          1.6712 |         1.3887 |  35 |
|   1.1523 |   60.6 |   111.4 |      180 |          1.6995 |         1.4456 |  40 |
|   1.1978 |   72.4 |   116.6 |      180 |          1.7253 |         1.5171 |  45 |
|   1.2633 |   85.3 |   122.2 |      180 |          1.7432 |         1.5869 |  50 |
|   1.3566 |   97.8 |   128.2 |      180 |          1.7495 |         1.6327 |  55 |
|   1.4858 |  109.3 |   134.5 |      180 |          1.7441 |         1.6493 |  60 |
|   1.6631 |    120 |     141 |      180 |          1.7289 |         1.6442 |  65 |
|   1.9109 |  130.5 |     148 |      180 |           1.706 |         1.6201 |  70 |
|    2.274 |  141.2 |   155.3 |      180 |          1.6782 |         1.5877 |  75 |
|   2.8696 |  152.6 |   163.1 |      180 |          1.6486 |         1.5476 |  80 |
|   4.1579 |  165.5 |   171.4 |      180 |          1.6229 |         1.5093 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.5, wavenumber=2.0, amplitude=0.05)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|     0.95 |      0 |      90 |      180 |          1.9144 |         2.5635 |   0 |
|   0.9556 |   12.5 |    90.3 |      180 |          1.9076 |         2.5025 |   5 |
|   0.9716 |   23.7 |    91.4 |      180 |          1.8894 |         2.3745 |  10 |
|   0.9966 |   33.5 |      93 |      180 |          1.8637 |         2.2348 |  15 |
|   1.0295 |   42.2 |    95.3 |      180 |          1.8338 |         2.1047 |  20 |
|   1.0698 |   50.2 |    98.1 |      180 |           1.802 |         1.9902 |  25 |
|   1.1175 |   57.8 |   101.4 |      180 |          1.7697 |         1.8899 |  30 |
|   1.1729 |   65.1 |   105.2 |      180 |          1.7382 |         1.8046 |  35 |
|   1.2367 |   72.4 |   109.5 |      180 |           1.708 |         1.7311 |  40 |
|   1.3102 |   79.7 |   114.2 |      180 |            1.68 |         1.6692 |  45 |
|   1.3957 |   87.1 |   119.5 |      180 |          1.6541 |         1.6131 |  50 |
|   1.4962 |     95 |   125.3 |      180 |          1.6316 |         1.5664 |  55 |
|   1.6166 |  103.4 |   131.7 |      180 |          1.6133 |         1.5284 |  60 |
|   1.7665 |  112.7 |   138.7 |      180 |             1.6 |         1.4962 |  65 |
|   1.9627 |  123.3 |   146.3 |      180 |          1.5937 |          1.476 |  70 |
|   2.2445 |  135.7 |   154.4 |      180 |           1.595 |         1.4677 |  75 |
|    2.718 |    150 |   162.8 |      180 |          1.6021 |          1.475 |  80 |
|   3.8111 |    165 |   171.4 |      180 |          1.6092 |         1.4865 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

***** Tables for wavenumber=4
#+call: test-wave-diagnostic(phase=0.0, wavenumber=4, amplitude=0.02)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|   1.0199 |      0 |      90 |      180 |          1.7322 |         1.1054 |   0 |
|   1.0202 |    5.5 |    90.3 |      180 |          1.7358 |         1.1209 |   5 |
|   1.0214 |   11.3 |    91.4 |      180 |           1.746 |         1.1584 |  10 |
|   1.0244 |   17.9 |      93 |      180 |          1.7611 |          1.228 |  15 |
|   1.0306 |   26.1 |    95.2 |      180 |          1.7785 |         1.3769 |  20 |
|   1.0458 |     39 |    97.9 |      180 |          1.7887 |          1.664 |  25 |
|   1.0799 |   54.9 |   101.2 |      180 |          1.7751 |         1.8569 |  30 |
|   1.1318 |   65.5 |   104.9 |      180 |          1.7437 |         1.8506 |  35 |
|   1.1961 |   73.5 |   109.2 |      180 |          1.7072 |         1.7804 |  40 |
|   1.2707 |   80.6 |   114.1 |      180 |          1.6725 |         1.6962 |  45 |
|   1.3557 |   87.4 |   119.7 |      180 |          1.6447 |         1.6183 |  50 |
|   1.4531 |   94.5 |   126.1 |      180 |          1.6272 |         1.5494 |  55 |
|   1.5666 |  102.3 |   133.1 |      180 |          1.6246 |         1.5008 |  60 |
|   1.7061 |    112 |   140.3 |      180 |          1.6381 |         1.4832 |  65 |
|    1.899 |  125.1 |   147.8 |      180 |          1.6593 |         1.5114 |  70 |
|   2.2107 |  139.5 |   155.4 |      180 |          1.6668 |         1.5509 |  75 |
|   2.7705 |  152.5 |   163.2 |      180 |           1.652 |         1.5471 |  80 |
|   4.0259 |  165.5 |   171.4 |      180 |          1.6261 |         1.5139 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |

#+call: test-wave-diagnostic(phase=0.5, wavenumber=4, amplitude=0.02)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime | inc |
|----------+--------+---------+----------+-----------------+----------------+-----|
|   0.9801 |      0 |      90 |      180 |          1.7319 |           3.52 |   0 |
|   0.9889 |   14.9 |    90.3 |      180 |          1.7206 |         2.8721 |   5 |
|   1.0079 |     24 |    91.4 |      180 |          1.7002 |         2.3291 |  10 |
|   1.0322 |     31 |    93.1 |      180 |          1.6807 |         1.9907 |  15 |
|   1.0599 |   37.2 |    95.5 |      180 |          1.6662 |         1.7661 |  20 |
|   1.0896 |     43 |    98.7 |      180 |          1.6603 |         1.6242 |  25 |
|   1.1216 |   48.8 |   102.4 |      180 |          1.6634 |         1.5252 |  30 |
|   1.1563 |   54.9 |   106.8 |      180 |          1.6765 |         1.4631 |  35 |
|    1.195 |   61.9 |   111.5 |      180 |          1.6987 |          1.437 |  40 |
|    1.241 |   70.9 |   116.5 |      180 |          1.7264 |         1.4634 |  45 |
|   1.3036 |   84.2 |   121.8 |      180 |          1.7485 |         1.5771 |  50 |
|   1.4008 |   98.8 |   127.4 |      180 |          1.7457 |         1.6658 |  55 |
|   1.5394 |  109.9 |   133.3 |      180 |          1.7202 |         1.6672 |  60 |
|   1.7231 |  119.3 |   139.7 |      180 |          1.6841 |         1.6283 |  65 |
|   1.9649 |  128.5 |   146.7 |      180 |          1.6462 |         1.5739 |  70 |
|   2.2977 |  138.4 |   154.4 |      180 |          1.6153 |         1.5194 |  75 |
|    2.816 |  150.3 |   162.7 |      180 |          1.6013 |         1.4821 |  80 |
|   3.9439 |  164.9 |   171.3 |      180 |          1.6061 |         1.4816 |  85 |
|      nan |    nan |     nan |      180 |             nan |            nan |  90 |


**** Cantoid
#+name: test-wave-diagnostic-cantoid
#+header: :var beta=0.01 phase=0.0 amplitude=0.1 wavenumber=1.0
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  import bow_projection as bp
  import bow_diagnostic
  import standing_wave

  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  shape = standing_wave.StandingWave(
      bp.cantoid_R_theta,
      amplitude=amplitude, wavenumber=wavenumber, phase=phase,
      beta=beta)
  th_inf = bp.theta_infinity(shape)
  inclinations = np.linspace(0.0, th_inf - np.pi/2, 19)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC


***** Tables for \beta = 0.1, amplitude=0.1 wavenumber=1.0
#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.0)
#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|      1.1 |      0 |      90 |    128.8 |          2.2807 |         1.9953 |    0 |
|   1.1008 |    4.3 |    90.1 |    128.8 |          2.2825 |         1.9965 |  2.2 |
|   1.1031 |    8.6 |    90.5 |    128.8 |          2.2879 |         2.0001 |  4.3 |
|    1.107 |     13 |    91.1 |    128.8 |          2.2971 |         2.0063 |  6.5 |
|   1.1126 |   17.4 |    91.9 |    128.8 |          2.3104 |         2.0153 |  8.6 |
|     1.12 |   21.8 |    92.9 |    128.8 |          2.3282 |         2.0274 | 10.8 |
|   1.1291 |   26.4 |    94.2 |    128.8 |          2.3513 |          2.043 | 12.9 |
|   1.1404 |   31.1 |    95.8 |    128.8 |          2.3806 |         2.0627 | 15.1 |
|   1.1538 |   35.9 |    97.6 |    128.8 |          2.4174 |         2.0877 | 17.2 |
|   1.1698 |   40.9 |    99.6 |    128.8 |          2.4636 |          2.119 | 19.4 |
|   1.1886 |   46.1 |   101.8 |    128.8 |           2.522 |         2.1586 | 21.5 |
|   1.2109 |   51.7 |   104.4 |    128.8 |          2.5967 |         2.2094 | 23.7 |
|   1.2373 |   57.6 |   107.1 |    128.8 |          2.6944 |         2.2764 | 25.9 |
|   1.2689 |   64.1 |   110.1 |    128.8 |          2.8261 |         2.3672 |   28 |
|   1.3075 |   71.2 |   113.4 |    128.8 |          3.0122 |         2.4971 | 30.2 |
|   1.3559 |   79.4 |   116.9 |    128.8 |          3.2956 |         2.6981 | 32.3 |
|     1.42 |   89.2 |   120.6 |    128.8 |           3.788 |         3.0543 | 34.5 |
|   1.5153 |  101.9 |   124.6 |    128.8 |          4.9353 |         3.9022 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.25)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|        1 |      0 |      90 |    128.8 |          2.5088 |         2.4375 |    0 |
|    1.001 |    5.3 |    90.1 |    128.8 |          2.5105 |         2.4389 |  2.2 |
|   1.0041 |   10.5 |    90.5 |    128.8 |          2.5156 |         2.4435 |  4.3 |
|   1.0093 |   15.8 |    91.1 |    128.8 |          2.5244 |         2.4512 |  6.5 |
|   1.0166 |   21.1 |      92 |    128.8 |          2.5372 |         2.4625 |  8.6 |
|   1.0263 |   26.5 |    93.1 |    128.8 |          2.5543 |         2.4776 | 10.8 |
|   1.0384 |   31.9 |    94.5 |    128.8 |          2.5764 |         2.4972 | 12.9 |
|   1.0532 |   37.4 |    96.1 |    128.8 |          2.6045 |          2.522 | 15.1 |
|    1.071 |     43 |    97.9 |    128.8 |          2.6398 |         2.5532 | 17.2 |
|   1.0922 |   48.7 |    99.9 |    128.8 |          2.6841 |         2.5925 | 19.4 |
|   1.1173 |   54.5 |   102.2 |    128.8 |          2.7401 |         2.6422 | 21.5 |
|    1.147 |   60.6 |   104.7 |    128.8 |          2.8119 |         2.7057 | 23.7 |
|   1.1824 |   66.8 |   107.5 |    128.8 |          2.9058 |         2.7885 | 25.9 |
|   1.2249 |   73.4 |   110.4 |    128.8 |          3.0328 |         2.9004 |   28 |
|   1.2768 |   80.4 |   113.6 |    128.8 |          3.2127 |         3.0592 | 30.2 |
|   1.3419 |     88 |     117 |    128.8 |           3.488 |         3.2997 | 32.3 |
|    1.428 |   96.5 |   120.7 |    128.8 |          3.9692 |         3.7177 | 34.5 |
|   1.5546 |  106.9 |   124.6 |    128.8 |          5.1001 |         4.6823 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.5)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|      0.9 |      0 |      90 |    128.8 |          2.7875 |         3.3428 |    0 |
|   0.9015 |    7.2 |    90.1 |    128.8 |          2.7882 |         3.3379 |  2.2 |
|    0.906 |   14.2 |    90.5 |    128.8 |          2.7906 |         3.3247 |  4.3 |
|   0.9134 |   21.1 |    91.2 |    128.8 |          2.7949 |         3.3056 |  6.5 |
|   0.9239 |   27.7 |    92.1 |    128.8 |          2.8016 |          3.284 |  8.6 |
|   0.9375 |   34.1 |    93.3 |    128.8 |          2.8116 |         3.2632 | 10.8 |
|   0.9544 |   40.2 |    94.7 |    128.8 |          2.8255 |         3.2458 | 12.9 |
|   0.9747 |   46.2 |    96.3 |    128.8 |          2.8446 |         3.2341 | 15.1 |
|   0.9987 |     52 |    98.2 |    128.8 |          2.8703 |         3.2302 | 17.2 |
|    1.027 |   57.7 |   100.3 |    128.8 |          2.9046 |         3.2368 | 19.4 |
|     1.06 |   63.4 |   102.6 |    128.8 |          2.9503 |         3.2552 | 21.5 |
|   1.0986 |     69 |   105.1 |    128.8 |          3.0114 |         3.2916 | 23.7 |
|    1.144 |   74.7 |   107.8 |    128.8 |          3.0944 |         3.3502 | 25.9 |
|   1.1979 |   80.6 |   110.7 |    128.8 |            3.21 |         3.4415 |   28 |
|    1.263 |   86.8 |   113.8 |    128.8 |          3.3783 |         3.5826 | 30.2 |
|    1.344 |   93.3 |   117.2 |    128.8 |          3.6415 |         3.8144 | 32.3 |
|   1.4497 |  100.7 |   120.8 |    128.8 |          4.1096 |         4.2377 | 34.5 |
|   1.6036 |  109.6 |   124.6 |    128.8 |          5.2251 |         5.2052 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

***** Tables for \beta = 0.1, amplitude=0.02 wavenumber=4.0
#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.0, amplitude=0.02, wavenumber=4.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|     1.02 |      0 |      90 |    128.8 |          2.5088 |         1.3812 |    0 |
|   1.0203 |      3 |    90.1 |    128.8 |          2.5123 |         1.3856 |  2.2 |
|   1.0211 |      6 |    90.5 |    128.8 |          2.5231 |         1.3991 |  4.3 |
|   1.0226 |    9.2 |    91.1 |    128.8 |          2.5411 |         1.4231 |  6.5 |
|   1.0249 |   12.6 |      92 |    128.8 |          2.5666 |         1.4608 |  8.6 |
|   1.0281 |   16.4 |    93.1 |    128.8 |          2.5995 |         1.5183 | 10.8 |
|   1.0326 |   20.9 |    94.4 |    128.8 |            2.64 |         1.6097 | 12.9 |
|   1.0393 |   26.9 |      96 |    128.8 |          2.6875 |         1.7771 | 15.1 |
|   1.0503 |   38.3 |    97.8 |    128.8 |          2.7379 |         2.2461 | 17.2 |
|   1.0721 |   53.7 |    99.8 |    128.8 |          2.7765 |         2.9468 | 19.4 |
|   1.1037 |   61.8 |     102 |    128.8 |          2.8108 |         3.1394 | 21.5 |
|    1.142 |   67.8 |   104.5 |    128.8 |          2.8538 |         3.1957 | 23.7 |
|   1.1868 |     73 |   107.2 |    128.8 |          2.9155 |         3.2116 | 25.9 |
|   1.2385 |     78 |   110.2 |    128.8 |          3.0086 |         3.2242 |   28 |
|   1.2983 |     83 |   113.4 |    128.8 |           3.155 |         3.2551 | 30.2 |
|   1.3686 |   88.5 |   116.9 |    128.8 |          3.3991 |         3.3399 | 32.3 |
|   1.4543 |   94.9 |   120.6 |    128.8 |          3.8553 |         3.5479 | 34.5 |
|   1.5693 |    104 |   124.6 |    128.8 |          4.9769 |         4.1857 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |

#+call: test-wave-diagnostic-cantoid(beta=0.1, phase=0.5, amplitude=0.02, wavenumber=4.0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|     0.98 |      0 |      90 |    128.8 |          2.5088 |         11.942 |    0 |
|    0.985 |   14.6 |    90.1 |    128.8 |          2.5002 |         6.9256 |  2.2 |
|   0.9949 |     21 |    90.5 |    128.8 |          2.4882 |         5.0329 |  4.3 |
|   1.0072 |   25.8 |    91.1 |    128.8 |          2.4792 |         4.1256 |  6.5 |
|   1.0213 |   29.9 |      92 |    128.8 |          2.4754 |         3.5804 |  8.6 |
|    1.037 |   33.6 |    93.1 |    128.8 |          2.4784 |         3.2153 | 10.8 |
|   1.0541 |     37 |    94.5 |    128.8 |          2.4897 |         2.9526 | 12.9 |
|   1.0725 |   40.4 |    96.2 |    128.8 |           2.511 |         2.7569 | 15.1 |
|   1.0923 |   43.8 |      98 |    128.8 |          2.5443 |         2.6091 | 17.2 |
|   1.1136 |   47.2 |   100.1 |    128.8 |          2.5922 |          2.498 | 19.4 |
|   1.1366 |   50.9 |   102.4 |    128.8 |          2.6584 |         2.4192 | 21.5 |
|   1.1618 |   54.8 |     105 |    128.8 |           2.748 |         2.3718 | 23.7 |
|   1.1897 |   59.4 |   107.7 |    128.8 |          2.8686 |         2.3622 | 25.9 |
|   1.2216 |     65 |   110.7 |    128.8 |          3.0326 |         2.4141 |   28 |
|   1.2605 |   73.3 |   113.8 |    128.8 |          3.2596 |         2.6121 | 30.2 |
|   1.3155 |   86.6 |   117.2 |    128.8 |          3.5805 |          3.197 | 32.3 |
|   1.4033 |   98.7 |   120.8 |    128.8 |          4.0829 |         3.9949 | 34.5 |
|   1.5453 |  109.3 |   124.6 |    128.8 |          5.2074 |           5.15 | 36.6 |
|      nan |    nan |     nan |    128.8 |             nan |            nan | 38.8 |





*** Write files of (R_c, R_90) versus inclination and phase
+ It takes a long time to run a large number of models, so I want to decouple the calculations from the graphing
+ This will allow me to experiment more with the graphs

#+BEGIN_SRC python :eval no :tangle save-wave-data.py
  import sys
  import json
  import numpy as np
  import scanf

  import bow_projection as bp
  import bow_diagnostic
  import dragoid_shape
  import ancantoid_shape
  import standing_wave


  # Parse command line arguments
  try:
      BASE_SHAPE_ID = sys.argv[1]
      AMPLITUDE = float(sys.argv[2])
      WAVENUMBER = float(sys.argv[3])
  except:
      sys.exit(f"Usage: {sys.argv[0]} BASE_SHAPE_ID AMPLITUDE WAVENUMBER")

  # Sensible defaults for the poly fitting to get R_c and R_90
  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01


  # Choose which base shape according to command-line argument and parse
  # out the shape parameters if any
  if BASE_SHAPE_ID == "paraboloid":
      base_shape = bp.paraboloid_R_theta
      shape_label = "Paraboloid"
  elif BASE_SHAPE_ID == "wilkinoid":
      base_shape = bp.wilkinoid_R_theta
      shape_label = "Wilkinoid"
  elif BASE_SHAPE_ID.startswith("cantoid"):
      ibeta, = scanf.scanf("cantoid-beta%d", BASE_SHAPE_ID)
      beta = ibeta / 100000
      base_shape = bp.Spline_R_theta_from_function(
          ngrid=1000, shape_func=bp.cantoid_R_theta, shape_func_pars=(beta,))
      shape_label = rf"Cantoid $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("ancantoid"):
      ixi, ibeta = scanf.scanf("ancantoid-xi%d-beta%d", BASE_SHAPE_ID)
      xi, beta = ixi / 100, ibeta / 100000
      base_shape = ancantoid_shape.Ancantoid(xi=xi, beta=beta, n=301)
      shape_label = rf"Ancantoid $\xi = {xi:.1f}$, $\beta = {beta}$"
  elif BASE_SHAPE_ID.startswith("dragoid"):
      ialpha, = scanf.scanf("dragoid-alpha%d", BASE_SHAPE_ID)
      alpha = ialpha / 100
      base_shape = dragoid_shape.Dragoid(alpha=alpha)
      shape_label = rf"Dragoid $\alpha_\mathrm{{drag}} = {alpha:.2f}$"
      bp.SCALE_NEIGHBORHOOD = 0.2

  # Create perturbed shape
  shape = standing_wave.StandingWave(base_shape,
                                     amplitude=AMPLITUDE,
                                     wavenumber=WAVENUMBER)


  # Create arrays of inclinations and phases
  nphase, ninc = 21, 50
  phases = np.linspace(0.0, 0.5, nphase)
  # Uniform distribution in sin inc
  inclinations = np.arcsin(np.linspace(0.0, 1.0, ninc))
  # Allocate arrays to hold the (R_c, R_90) results
  Rc = np.empty((ninc, nphase))
  R90 = np.empty((ninc, nphase))
  # Loop over inclinations and phases and save the radii
  for i, inclination in enumerate(inclinations):
      for j, phase in enumerate(phases):
          shape.phase = phase
          radii = bp.characteristic_radii_projected(inclination, shape)
          Rc[i, j] = radii['tilde R_c prime']
          R90[i, j] = radii['tilde R_90 prime']


  # Save the results
  shape_id = f"{BASE_SHAPE_ID}-wave-A{int(100*AMPLITUDE):03d}-N{int(10*WAVENUMBER):02d}"

  # Save Rc, R90 arrays in binary format
  # To retrieve:
  #
  # >>> arrays = np.load(FILE.npz)
  # >>> Rc = arrays['Rc']
  #
  # Etcetera
  np.savez(shape_id, Rc=Rc, R90=R90)

  # Save metadata as JSON 
  metadata = {
      'shape_id': shape_id,
      'shape_label': shape_label,
      'wave_label': f"Perturbation $A = {AMPLITUDE}$, $N = {WAVENUMBER}$",
      'ninc': ninc,
      'nphase': nphase,
      'inclinations': list(np.round(np.degrees(inclinations), 1)),
      'phases': list(np.round(phases, 4)),
  }
  jsonfile = shape_id + ".json"
  with open(jsonfile, 'w') as f:
      json.dump(metadata, f, indent=4)

  print(jsonfile, end='')
#+END_SRC


**** Generate the data for different shapes and waves

#+name: run-save-wave
#+header: :var A=0.1 N=1.5
#+BEGIN_SRC sh :results verbatim
  for shape in wilkinoid cantoid-beta002000 ancantoid-xi080-beta000500 dragoid-alpha100; do
      python save-wave-data.py $shape $A $N
      echo
  done
#+END_SRC

#+RESULTS: run-save-wave
: wilkinoid-wave-A010-N15.jsoncantoid-beta002000-wave-A010-N15.jsonancantoid-xi080-beta000500-wave-A010-N15.jsondragoid-alpha100-wave-A010-N15.json

#+call: run-save-wave(A=0.1, N=1)

#+RESULTS:
: wilkinoid-wave-A010-N10.json
: cantoid-beta002000-wave-A010-N10.json
: ancantoid-xi080-beta000500-wave-A010-N10.json
: dragoid-alpha100-wave-A010-N10.json

#+call: run-save-wave(A=0.05, N=2)

#+RESULTS:
: wilkinoid-wave-A005-N20.json
: cantoid-beta002000-wave-A005-N20.json
: ancantoid-xi080-beta000500-wave-A005-N20.json
: dragoid-alpha100-wave-A005-N20.json


#+call: run-save-wave(A=0.01, N=5)

#+RESULTS:
: wilkinoid-wave-A001-N50.json
: cantoid-beta002000-wave-A001-N50.json
: ancantoid-xi080-beta000500-wave-A001-N50.json
: dragoid-alpha100-wave-A001-N50.json

*** Figure of R_c-R_90 for the standing wave
This is something I never got finished for the multi-quadric fits

#+BEGIN_SRC python :eval no :tangle wave-R90-vs-Rc.py
  import sys
  import json
  import numpy as np
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns

  try:
      WAVE_ID = sys.argv[1]
      BASE_SHAPE_IDS = sys.argv[2:]
  except:
      sys.exit(f"Usage: {sys.argv[0]} WAVE_ID SHAPE_ID [SHAPE_ID ...]")

  plotfile = sys.argv[0].replace('.py', f'-{WAVE_ID}.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(5, 5))

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)

  nshapes = len(BASE_SHAPE_IDS)
  colors = sns.color_palette(n_colors=nshapes)
  for base_shape_id, color in zip(BASE_SHAPE_IDS, colors):
      prefix = f"{base_shape_id}-wave-{WAVE_ID}"
      metadata = json.load(open(prefix + '.json'))
      data = np.load(prefix + '.npz')
      Rc, R90 = data['Rc'], data['R90']
      for x, y in zip(Rc, R90):
          ax.plot(x, y, '-', lw=2, c=color, label="_nolabel_", alpha=0.3)
      ax.plot(Rc[0], R90[0], '-', lw=3, c=color,
              label=metadata['shape_label'], alpha=0.8)

  ax.legend(title=metadata['wave_label'])

  ax.set(
      yscale='linear',
      xscale='linear',
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
      xlabel=r"Projected dimensionless radius of curvature: $\widetilde{R}_{c}{}'$",
      ylabel=r"Projected dimensionless perpendicular radius: $\widetilde{R}_{90}{}'$",
  )        

  sns.despine()
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A010-N15 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A010-N15.pdf]]


#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A010-N10 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A010-N10.pdf]]

#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A005-N20 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A005-N20.pdf]]

#+BEGIN_SRC sh :results file
  python wave-R90-vs-Rc.py A001-N50 \
         cantoid-beta002000 \
         ancantoid-xi080-beta000500 \
         dragoid-alpha100 \
         wilkinoid 
#+END_SRC

#+RESULTS:
[[file:wave-R90-vs-Rc-A001-N50.pdf]]


*** Slope of Rc-R90 graph from analytic estimate
|    N | (1 - cos(N\pi/2))/N |
|------+-------------------|
| 0.25 |              0.30 |
|  0.5 |              0.59 |
|  1.0 |              1.00 |
|  1.5 |              1.14 |
|  2.0 |              1.00 |
|  2.5 |              0.68 |
|  3.0 |              0.33 |
#+TBLFM: $2=(1 - cos($1 90))/$1 ; f2


* Copy figures to paper folder
#+BEGIN_SRC sh :results verbatim
FILES="depart-cheby-M17-*.pdf test_xyprime_simulation.pdf m17-planitude-alatude.pdf m17-r0-prime.pdf"
date
cp -v $FILES ../papers/Paper1/figs
#+END_SRC

#+RESULTS:
: Sun Dec  3 20:10:02 CST 2017
: depart-cheby-M17-HD2040.pdf -> ../papers/Paper1/figs/depart-cheby-M17-HD2040.pdf
: depart-cheby-M17-MHD2040-AllB7.pdf -> ../papers/Paper1/figs/depart-cheby-M17-MHD2040-AllB7.pdf
: test_xyprime_simulation.pdf -> ../papers/Paper1/figs/test_xyprime_simulation.pdf
: m17-planitude-alatude.pdf -> ../papers/Paper1/figs/m17-planitude-alatude.pdf
: m17-r0-prime.pdf -> ../papers/Paper1/figs/m17-r0-prime.pdf




* Bow shock shapes from simulations
+ We will analyze some published synthetic observations from simulations
+ Do it exactly the same as for the real observations
  + Trace arc in ds9
  + Fit to find R0, R90 and Rc
  + Determine \Pi and \Lambda
** Get more simulations
+ [X] We have Acreman 2016
  + One model in 3 bands (Ha, 12 \mu{}m, 20 \mu{}m) for 3 angles (0, 30, 60)
+ [X] We have Raga 1997
  + One model in 1 band (H\alpha) for i=0 only
+ [ ] Potentially we have Meyer 2014
  + Many models in 2 bands (H\alpha and generic dust) for i=0 only
+ [X] And there is Meyer 2016
  + 3 models (n = 0.1, 1, 10 for 20 Msun and 70 km/s), two bands (H\alpha and [O III]), five angles (0, 30, 45, 60, 90), where first comes from density map, and 90 is useless obviously.
  + This looks the best bet
    + We can get the full shape from the density maps, which extend out to \theta = 140 or so
    + The fit some conics and do predicted projection and actual projection for 30, 45, 60
  + *But* there is a flaw
    + Their projected maps have only been calculated using that part of the grid with \theta < 90
    + This means that we cannot find \Lambda' because they are forcing that R_90' = R_90 for all i, which means that \Lambda' will appear to fall because R_0' is increasing.
    + Whereas in reality, \Lambda' will come from shell at \theta_90(i), which is > 90 deg
    + Still we could show this as a warning
+ [ ] Finally there is Meyer 2017 with magnetic fields
  + This eliminates the conduction rubbish
  + And also gives a wider variety of shapes
  + Thirdly, they fix the flaw in the 2016 paper of only considering \theta < 90, so we should be able to really compare the \Pi' and \Lambda' from the simulated maps at different inclinations with the predictions from the shape
  + Their Fig 10 compares MHD and HD simulations of the same star with emission maps of dust in various FIR wave bands, for i = 30, 45, 60, 90
    + The Ha and [O III] emission for the same models are given in Fig 7 for i = 0
    + The density structure is given in Fig 3
  + [2/4] So plan is
    1. [X] Trace the CD from the density images, following a contour
       - This gives the R(\theta), which can be plotted as \Delta(\mu)
    2. [-] Extrapolate to give a full shape
       - We can either take an ellipse extrapolation (\Delta \to constant as \mu \to -1) or an "open" extrapolation (\Delta \to 0 as \mu \to -1)
       - Use that to predict \Pi', \Lambda' as function of inclination
    3. [X] Trace the 60 micron images to find \Pi', \Lambda' for the inclinations 30, 45, 60
       - And the H\alpha image for i=0 for completeness
         - [ ] For the HD model we might want to average the BS and the CD curves
    4. [ ] Compare (1) with (3)


** Convert screenshots to FITS
#+BEGIN_SRC sh :results silent
  for file in *-maps.png; do
      python ~/Work/Image2FITS/image2fits.py $file
  done
#+END_SRC

New ones from Meyer (2016)
#+BEGIN_SRC sh :results silent
  for file in Meyer-2016-MS2070*.png; do
      python ~/Work/Image2FITS/image2fits.py $file
  done
#+END_SRC

New ones from Meyer (2017)
#+BEGIN_SRC sh :results silent
  for file in Meyer-2017-*.png; do
      python ~/Work/Image2FITS/image2fits.py $file
  done
#+END_SRC

Meyer (2014)
#+BEGIN_SRC sh :results silent
  for file in Meyer-2014-*.png; do
      python ~/Work/Image2FITS/image2fits.py $file
  done
#+END_SRC
** Measure arcs on FITS images
+ Acreman figure
  + E.g., [[file:A16-20mic-i00-forma.reg]]
** Add a WCS to the FITS files
+ It turns out that =find-xy-shell.py= requires one
  + And it is easier to provide one than to re-write the program
#+BEGIN_SRC python :eval no :tangle add-wcs-to-screenshot.py
  import sys
  from astropy.io import fits
  from astropy.wcs import WCS

  try: 
      prefix = sys.argv[1]
  except:
      sys.exit(f"Usage: {sys.argv[0]} PREFIX")

  channels = ['red', 'green', 'blue']
  for channel in channels:
      hdulist = fits.open(f"{prefix}-{channel}.fits", mode="update")
      w = WCS(naxis=2)
      w.wcs.crpix = [0, 0]
      w.wcs.cdelt = [1.0/3600, 1.0/3600]
      w.wcs.crval = [30, -60]
      w.wcs.ctype = ["RA---AIR", "DEC--AIR"]
      hdulist[0].header = w.to_header()
      hdulist.flush()
      hdulist.close()

#+END_SRC

#+BEGIN_SRC sh :results verbatim
  for file in Meyer-2016-MS2070*.png; do
      python add-wcs-to-screenshot.py ${file%%.png}
  done
#+END_SRC

#+BEGIN_SRC sh :results verbatim
  for file in Meyer-2017-*.png; do
      python add-wcs-to-screenshot.py ${file%%.png}
  done
#+END_SRC

#+RESULTS:

+ [X] Then we have to load each of the =.reg= files back in to ds9 and write them out again in wcs format

** Fit the arcs
+ Do it like in [[id:4BC292AA-F2EB-4031-94AB-E6A36B22FD21][Circle fits to second batch of sources]]

#+BEGIN_SRC sh :results silent
  D=../read-shapes-LL
  for wav in 20mic 12mic Halpha; do
      for inc in i00 i30 i60; do
          python $D/find-xy-shell.py A16-${wav}-${inc} --pa0 0 --window 9
      done
  done
#+END_SRC



#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py --help
#+END_SRC

#+RESULTS:
#+begin_example
usage: find-xy-shell.py [-h] [--debug] [--pa0 PA0] [--window WINDOW] source

Find (X, Y) positions of shell boundaries from a DS9 region file

positional arguments:
  source           Name of source, taken as prefix for region file containing
                   shell and star positions

optional arguments:
  -h, --help       show this help message and exit
  --debug          Print out verbose debugging info about each line in region
                   file
  --pa0 PA0        Optionally over-ride guess at PA of bow shock axis
  --window WINDOW  Number of points to use when searching for min R
#+end_example

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/fit-circle-shell.py --help
#+END_SRC

#+RESULTS:
#+begin_example
usage: fit-circle-shell.py [-h] [--savefig] [--debug] [--thmax THMAX] source

Fit circles to all the arcs and save as ds9 region file

positional arguments:
  source         Name of source

optional arguments:
  -h, --help     show this help message and exit
  --savefig      Save a figure showing the fit
  --debug        Print out verbose debugging info
  --thmax THMAX  Maximum angle from axis for points to include in circle fit
#+end_example


#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for wav in 20mic 12mic Halpha; do
      for inc in i00 i30 i60; do
          python $D/fit-circle-shell.py A16-${wav}-${inc} --thmax 60 --savefig --figscale 150
      done
  done
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 12
    # data points      = 9
    # variables        = 2
    chi-square         = 1.500
    reduced chi-square = 0.214
    Akaike info crit   = -12.125
    Bayesian info crit = -11.731
[[Variables]]
    xc:  -0.86827844 +/- 0.484223 (55.77%) (init=-1.415982)
    yc:  -43.0169955 +/- 3.451873 (8.02%) (init=-40.94287)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.868278445549 -43.0169955505 83.9520885522
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 9
    # variables        = 2
    chi-square         = 0.952
    reduced chi-square = 0.136
    Akaike info crit   = -16.222
    Bayesian info crit = -15.828
[[Variables]]
    xc:   0.26327242 +/- 0.440482 (167.31%) (init= 0.1885513)
    yc:  -56.6615451 +/- 3.378267 (5.96%) (init=-40.43253)
[[Correlations]] (unreported correlations are <  0.100)
outer : 0.263272420544 -56.6615451113 97.2688410428
[[Fit Statistics]]
    # function evals   = 21
    # data points      = 10
    # variables        = 2
    chi-square         = 12.096
    reduced chi-square = 1.512
    Akaike info crit   = 5.903
    Bayesian info crit = 6.508
[[Variables]]
    xc:  -0.94112604 +/- 2.550386 (270.99%) (init= 0.64284)
    yc:  -169.000042 +/- 51.30050 (30.36%) (init=-43.32933)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.941126046004 -169.000042284 214.24326031
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 30
    # variables        = 2
    chi-square         = 3.663
    reduced chi-square = 0.131
    Akaike info crit   = -59.089
    Bayesian info crit = -56.287
[[Variables]]
    xc:  -1.88017148 +/- 0.211841 (11.27%) (init=-1.455069)
    yc:  -70.7512435 +/- 2.054985 (2.90%) (init=-44.26959)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.181 
outer : -1.88017148162 -70.7512435821 114.932519062
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 22
    # variables        = 2
    chi-square         = 9.569
    reduced chi-square = 0.478
    Akaike info crit   = -14.316
    Bayesian info crit = -12.134
[[Variables]]
    xc:  -2.02239761 +/- 0.530814 (26.25%) (init= 0.1877718)
    yc:  -77.6627673 +/- 5.505573 (7.09%) (init=-41.52165)
[[Correlations]] (unreported correlations are <  0.100)
outer : -2.02239761853 -77.6627673223 120.48605475
[[Fit Statistics]]
    # function evals   = 12
    # data points      = 12
    # variables        = 2
    chi-square         = 9.543
    reduced chi-square = 0.954
    Akaike info crit   = 1.251
    Bayesian info crit = 2.221
[[Variables]]
    xc:  -3.19000930 +/- 0.650585 (20.39%) (init=-2.587487)
    yc:  -48.1391239 +/- 6.356706 (13.20%) (init=-53.83477)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.151 
outer : -3.19000930802 -48.1391239766 102.461613882
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 15
    # variables        = 2
    chi-square         = 75.590
    reduced chi-square = 5.815
    Akaike info crit   = 28.259
    Bayesian info crit = 29.675
[[Variables]]
    xc:  -0.90720240 +/- 1.526846 (168.30%) (init=-1.735478)
    yc:  -42.2411966 +/- 9.675294 (22.90%) (init=-52.12203)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.907202408862 -42.241196604 95.2588341179
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 12
    # variables        = 2
    chi-square         = 2.646
    reduced chi-square = 0.265
    Akaike info crit   = -14.140
    Bayesian info crit = -13.170
[[Variables]]
    xc:  -0.49692657 +/- 0.510309 (102.69%) (init=-0.8667289)
    yc:  -77.9597925 +/- 3.784126 (4.85%) (init=-62.6494)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.260 
outer : -0.496926576525 -77.9597925915 141.013742592
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 12
    # variables        = 2
    chi-square         = 19.731
    reduced chi-square = 1.973
    Akaike info crit   = 9.968
    Bayesian info crit = 10.937
[[Variables]]
    xc:   0.03098664 +/- 0.915668 (2955.04%) (init=-1.467732)
    yc:  -29.9301989 +/- 4.449084 (14.86%) (init=-80.68895)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.104 
outer : 0.0309866408166 -29.930198911 110.304078185
#+end_example


#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py R97-Halpha-i00 --pa0 90 --window 9
  python $D/fit-circle-shell.py R97-Halpha-i00 --thmax 60 --savefig --figscale 300
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 7
    # variables        = 2
    chi-square         = 140.998
    reduced chi-square = 28.200
    Akaike info crit   = 25.020
    Bayesian info crit = 24.912
[[Variables]]
    xc:  -47.9081712 +/- 27.37979 (57.15%) (init=-91.68763)
    yc:  -2.14965635 +/- 4.968434 (231.13%) (init=-1.367659)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.267 
outer : -47.9081712238 -2.14965635401 142.082194775
#+end_example

** Fit arcs to Meyer 2017 shapes
#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M17-MHD2040-AllB7 --pa0 0 --window 11
  python $D/fit-circle-shell.py M17-MHD2040-AllB7 --thmax 60 --savefig --figscale 200
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 23
    # variables        = 2
    chi-square         = 17.024
    reduced chi-square = 0.811
    Akaike info crit   = -2.921
    Bayesian info crit = -0.650
[[Variables]]
    xc:   0.87844247 +/- 1.139105 (129.67%) (init= 1.09081)
    yc:  -122.078095 +/- 11.38874 (9.33%) (init=-47.69958)
[[Correlations]] (unreported correlations are <  0.100)
outer : 0.878442476821 -122.078095702 170.417646989
#+end_example

#+BEGIN_SRC sh :results silent
open M17-*-arcfits.pdf
#+END_SRC

#+BEGIN_SRC sh :results file
python shape-conic-plot.py M17-MHD2040-AllB7 
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-M17-MHD2040-AllB7.pdf]]

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M17-HD2040 --pa0 0 --window 11
  python $D/fit-circle-shell.py M17-HD2040 --thmax 60 --savefig --figscale 250
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 30
    # variables        = 2
    chi-square         = 11.414
    reduced chi-square = 0.408
    Akaike info crit   = -24.991
    Bayesian info crit = -22.188
[[Variables]]
    xc:   0.22707331 +/- 0.389464 (171.52%) (init= 0.2886785)
    yc:  -65.0888304 +/- 1.950807 (3.00%) (init=-84.06985)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.160 
outer : 0.227073314289 -65.0888304071 149.803410692
#+end_example

#+BEGIN_SRC sh :results file
python shape-conic-plot.py M17-HD2040 
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-M17-HD2040.pdf]]



*** Reflect the one-sided arcs to make symmetrical
+ The dust emission images show only one side, but we need the make it symmetric so that ~find-xy-shell.py~ will work
+ Easiest to add an argument to [[file:~/Work/Bowshocks/Jorge/bowshock-shape/read-shapes-LL/find-xy-shell.py]]
  
#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for inc in i30 i60 i45; do
      python $D/find-xy-shell.py M17-MHD2040-AllB7-60mic-$inc --mirror --pa0 0 --window 11
      python $D/fit-circle-shell.py M17-MHD2040-AllB7-60mic-$inc --thmax 60 --savefig --figscale 60
  done
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 27
    # data points      = 22
    # variables        = 2
    chi-square         = 0.438
    reduced chi-square = 0.022
    Akaike info crit   = -82.154
    Bayesian info crit = -79.972
[[Variables]]
    xc:  -1.2970e-05 +/- 0.101708 (784188.97%) (init= 0.1209432)
    yc:  -22.7386327 +/- 0.703891 (3.10%) (init=-19.93934)
[[Correlations]] (unreported correlations are <  0.100)
outer : -1.29698792652e-05 -22.7386327356 42.7447694992
[[Fit Statistics]]
    # function evals   = 21
    # data points      = 28
    # variables        = 2
    chi-square         = 0.138
    reduced chi-square = 0.005
    Akaike info crit   = -144.795
    Bayesian info crit = -142.130
[[Variables]]
    xc:   5.8569e-05 +/- 0.032565 (55602.00%) (init= 0.2651148)
    yc:  -14.0758912 +/- 0.165202 (1.17%) (init=-27.47579)
[[Correlations]] (unreported correlations are <  0.100)
outer : 5.85687233641e-05 -14.0758912464 41.5707665446
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 25
    # variables        = 2
    chi-square         = 0.300
    reduced chi-square = 0.013
    Akaike info crit   = -106.545
    Bayesian info crit = -104.107
[[Variables]]
    xc:   0.01421278 +/- 0.061255 (430.99%) (init=-0.2295599)
    yc:  -16.3314669 +/- 0.336181 (2.06%) (init=-23.30099)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.138 
outer : 0.0142127841643 -16.3314669423 39.7077872798
#+end_example

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for inc in i30 i60 i45; do
      python $D/find-xy-shell.py M17-HD2040-60mic-$inc --mirror --pa0 0 --window 11
      python $D/fit-circle-shell.py M17-HD2040-60mic-$inc --thmax 60 --savefig --figscale 120
  done
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 32
    # variables        = 2
    chi-square         = 8.233
    reduced chi-square = 0.274
    Akaike info crit   = -39.442
    Bayesian info crit = -36.510
[[Variables]]
    xc:  -0.00030196 +/- 0.304693 (100906.07%) (init= 0.1526615)
    yc:  -42.8230678 +/- 1.771714 (4.14%) (init=-48.36428)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.000301957199037 -42.8230678902 91.3310510027
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 39
    # variables        = 2
    chi-square         = 6.376
    reduced chi-square = 0.172
    Akaike info crit   = -66.632
    Bayesian info crit = -63.305
[[Variables]]
    xc:   0.04778295 +/- 0.222363 (465.36%) (init=-1.559587)
    yc:  -46.3992588 +/- 1.226260 (2.64%) (init=-70.0189)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.166 
outer : 0.0477829592257 -46.399258795 116.146909206
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 36
    # variables        = 2
    chi-square         = 4.781
    reduced chi-square = 0.141
    Akaike info crit   = -68.677
    Bayesian info crit = -65.510
[[Variables]]
    xc:  -0.00943907 +/- 0.221300 (2344.52%) (init= 6.938018)
    yc:  -49.0033081 +/- 1.117650 (2.28%) (init=-55.76348)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.456 
outer : -0.00943907485149 -49.003308165 104.97190652
#+end_example

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for suff in Halpha-i00 Halpha-i00-BS Halpha-i00-CD; do
      python $D/find-xy-shell.py M17-HD2040-$suff --mirror --pa0 0 --window 11
      python $D/fit-circle-shell.py M17-HD2040-$suff --thmax 60 --savefig --figscale 400
  done
  python $D/find-xy-shell.py  M17-MHD2040-AllB7-Halpha-i00 --mirror --pa0 0 --window 11
  python $D/fit-circle-shell.py M17-MHD2040-AllB7-Halpha-i00 --thmax 60 --savefig --figscale 300
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 62
    # variables        = 2
    chi-square         = 17081.732
    reduced chi-square = 284.696
    Akaike info crit   = 352.355
    Bayesian info crit = 356.609
[[Variables]]
    xc:  -0.01556351 +/- 8.629202 (55445.07%) (init= 3.0005)
    yc:  -196.857894 +/- 67.60542 (34.34%) (init=-140.3129)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.0155635151331 -196.857894165 327.481217162
[[Fit Statistics]]
    # function evals   = 28
    # data points      = 32
    # variables        = 2
    chi-square         = 6.669
    reduced chi-square = 0.222
    Akaike info crit   = -46.186
    Bayesian info crit = -43.255
[[Variables]]
    xc:  -1.0823e-05 +/- 0.222154 (2052709.25%) (init=-0.09922513)
    yc:  -135.559606 +/- 1.612202 (1.19%) (init=-149.0566)
[[Correlations]] (unreported correlations are <  0.100)
outer : -1.08225061165e-05 -135.559606923 284.608999811
[[Fit Statistics]]
    # function evals   = 28
    # data points      = 30
    # variables        = 2
    chi-square         = 91.725
    reduced chi-square = 3.276
    Akaike info crit   = 37.528
    Bayesian info crit = 40.330
[[Variables]]
    xc:  -0.00017924 +/- 0.954511 (532543.21%) (init= 0.2554177)
    yc:  -78.1345117 +/- 5.299026 (6.78%) (init=-116.8363)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.000179236508448 -78.1345117766 196.85770332
[[Fit Statistics]]
    # function evals   = 20
    # data points      = 30
    # variables        = 2
    chi-square         = 42.742
    reduced chi-square = 1.527
    Akaike info crit   = 14.620
    Bayesian info crit = 17.422
[[Variables]]
    xc:  -0.00121367 +/- 1.060160 (87351.16%) (init= 0.0460823)
    yc:  -144.188086 +/- 8.621583 (5.98%) (init=-79.99004)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.001213676045 -144.188086685 225.979440487
#+end_example

** Fit arcs to Meyer 2016 shapes
#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M16-MS2070n00p10-CD --pa0 0 --window 11
  python $D/fit-circle-shell.py M16-MS2070n00p10-CD --thmax 45 --savefig --figscale 400
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 20
    # variables        = 2
    chi-square         = 2.710
    reduced chi-square = 0.151
    Akaike info crit   = -35.975
    Bayesian info crit = -33.983
[[Variables]]
    xc:   0.33132410 +/- 0.328603 (99.18%) (init= 0.3099345)
    yc:  -90.3086796 +/- 2.550881 (2.82%) (init=-129.4369)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.109 
outer : 0.331324102216 -90.308679631 219.628145297
#+end_example


#+BEGIN_SRC sh :results silent
open M16-MS2070n00p10-*-arcfits.pdf
#+END_SRC

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M16-MS2070n00p10-BS --pa0 0 --window 10
  python $D/fit-circle-shell.py M16-MS2070n00p10-BS --thmax 45 --savefig --figscale 400
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 23
    # variables        = 2
    chi-square         = 3.442
    reduced chi-square = 0.164
    Akaike info crit   = -39.685
    Bayesian info crit = -37.414
[[Variables]]
    xc:   0.97394196 +/- 0.352750 (36.22%) (init= 0.4950382)
    yc:  -129.062380 +/- 3.048129 (2.36%) (init=-149.6037)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.100 
outer : 0.973941961957 -129.062380349 278.408680128
#+end_example


#+BEGIN_SRC sh :results file
python shape-conic-plot.py M16-MS2070n00p10
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-M16-MS2070n00p10.pdf]]



** New way of plotting bow shape
+ Plot 1/R against cos \theta
+ That should be a straight line for a confocal conic
+ If we take (1/R) - (1 + cos \theta)/2, then that is even better
  + Parabola is flat at 0, so we have compensated for the main slope
  + And we can see the variations more clearly
+ Big question is, what do we call this function?
  + *Compensated inversion* is a possibility
    + "/Inversion/" because 1/R is the circle inversion of the arc
    + "/Compensated/" because we subtract off a "typical" slope, as in a compensated power spectrum
  + *Departure function* is even better I think
    + It is the "/departure/" from a confocal parabola
    + less "clever"
    + We can call it \(\mathcal{D}\) or maybe \Delta
      \[ \Delta(\cos \theta) = \frac {R_{0}} {R(\theta)} - \frac12 (1 + \cos \theta)\]
#+BEGIN_SRC python :eval no :tangle shape-conic-plot.py
  import sys
  import json
  import numpy as np
  from astropy.coordinates import Longitude
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append("../Dust-wave")
  import bow_projection as bp

  try:
      prefix = sys.argv[1]
  except:
      print(f"Usage: {sys.argv[0]} PREFIX")

  plotfile = sys.argv[0].replace('.py', f'-{prefix}.pdf')

  def compensate(R, theta):
      """Compensated inversion of R(theta)"""
      return 1.0/R - 0.5*(1 + np.cos(theta))

  def load_R_th(arc_prefix):
      jfile = f'{arc_prefix}-arcdata.json'
      data = json.load(open(jfile))
      R0 = np.array(data['outer']['R0'])
      R = np.array(data['outer']['R'])
      th = Longitude(data['outer']['theta'], unit='deg')
      th += Longitude(data['outer']['PA0'], unit='deg')
      return th.rad, R/R0


  sns.set_style('ticks')
  fig, ax = plt.subplots()

  # Plot confocal parabola
  ax.axhline(0.0, ls='-', c='k', lw=0.5)

  # Plot wilkinoid
  mugrid = np.linspace(-1.0, 1.0, 200)
  thgrid = np.arccos(mugrid)
  ax.plot(mugrid, compensate(bp.wilkinoid_R_theta(thgrid), thgrid),
          '-', c='k', lw=1.5)

  # Plot cantoids
  for beta in 0.3, 0.1, 0.03, 0.01, 0.003, 0.001, 0.0003, 0.0001:
      ax.plot(mugrid, compensate(bp.cantoid_R_theta(thgrid, beta), thgrid),
              '-', c='k', lw=0.5)

  # Fill in forbidden zone
  ax.fill_between(mugrid, -0.5*(1.0 + mugrid), -1.0, color='k', alpha=0.4)

  # Plot traced arcs
  try:
      th, R = load_R_th(prefix + '-CD')
      ax.plot(np.cos(th), compensate(R, th), '.', alpha=0.6, label='CD')
      th, R = load_R_th(prefix + '-BS')
      ax.plot(np.cos(th), compensate(R, th), '.', alpha=0.6, label='BS')
  except:
      th, R = load_R_th(prefix)
      ax.plot(np.cos(th), compensate(R, th), '.', alpha=0.6, label=prefix)



  ax.legend(title=prefix)

  ax.set(
      xlim=[-1.02, 1.02],
      ylim=[-0.155, 0.155],
      xlabel=r"$\cos \,\theta$",
      ylabel=r"$(R_{0} / R) - 0.5 (1 + \cos \,\theta) $",
  )
  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python shape-conic-plot.py R97-Halpha-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-R97-Halpha-i00.pdf]]

#+BEGIN_SRC sh :results file
python shape-conic-plot.py A16-Halpha-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-A16-Halpha-i00.pdf]]

#+BEGIN_SRC sh :results file
python shape-conic-plot.py A16-20mic-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-A16-20mic-i00.pdf]]

#+BEGIN_SRC sh :results file
python shape-conic-plot.py A16-12mic-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-A16-12mic-i00.pdf]]



*** Extrapolating into the far wings with the departure function
#+BEGIN_SRC python :eval no :tangle depart-extrapolate.py
  import sys
  import json
  import numpy as np
  from astropy.coordinates import Longitude
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append("../Dust-wave")
  import bow_projection as bp

  try:
      prefix = sys.argv[1]
  except:
      print(f"Usage: {sys.argv[0]} PREFIX")

  try:
      npoly = int(sys.argv[2])
  except:
      npoly = 2

  plotfile = sys.argv[0].replace('.py', f'-{prefix}.pdf')

  def load_R_th(arc_prefix):
      jfile = f'{arc_prefix}-arcdata.json'
      data = json.load(open(jfile))
      R0 = np.array(data['outer']['R0'])
      R = np.array(data['outer']['R'])
      th = Longitude(data['outer']['theta'], unit='deg')
      th += Longitude(data['outer']['PA0'], unit='deg')
      return th.rad, R/R0


  def departure(R, theta):
      """Parabolic departure of R(theta)"""
      return 1.0/R - 0.5*(1 + np.cos(theta))

  def extrapolate(mu, Delta, mu0=-0.5, force_open=False, deg=2):
      def factor(mu):
          if force_open:
              return np.abs(-1.0 - mu)**0.5
          else:
              return 1.0
    
      # Only fit mu < mu0
      mask = mu <= mu0
      p = np.poly1d(np.polyfit(mu[mask], Delta[mask]/factor(mu[mask]), deg=deg))
      mu_x = np.linspace(-1.0, mu0)
      return mu_x, factor(mu_x)*p(mu_x)


  sns.set_style('ticks')
  fig, ax = plt.subplots()

  # Plot confocal parabola
  ax.axhline(0.0, ls='-', c='k', lw=0.5)

  # Plot wilkinoid
  mugrid = np.linspace(-1.0, 1.0, 200)
  thgrid = np.arccos(mugrid)
  ax.plot(mugrid, departure(bp.wilkinoid_R_theta(thgrid), thgrid),
          '-', c='k', lw=1.5)

  # Plot cantoids
  for beta in 0.3, 0.1, 0.03, 0.01, 0.003, 0.001, 0.0003, 0.0001:
      ax.plot(mugrid, departure(bp.cantoid_R_theta(thgrid, beta), thgrid),
              '-', c='k', lw=0.5)

  # Fill in forbidden zone
  ax.fill_between(mugrid, -0.5*(1.0 + mugrid), -1.0, color='k', alpha=0.4)

  # Plot traced arcs
  th, R = load_R_th(prefix)
  Delta = departure(R, th)
  mu = np.cos(th)
  ax.plot(mu, Delta, '.', alpha=0.6, label=prefix)
  mux, Deltax = extrapolate(mu, Delta, deg=npoly, force_open=False)
  ax.plot(mux, Deltax, '-', alpha=0.6, label='_nolabel_')
  mux, Deltax = extrapolate(mu, Delta, deg=npoly, force_open=True)
  ax.plot(mux, Deltax, '-', alpha=0.6, label='_nolabel_')


  ax.legend(title=prefix)

  ax.set(
      xlim=[-1.02, 1.02],
      ylim=[-0.155, 0.155],
      xlabel=r"$\cos \,\theta$",
      ylabel=r"Parabolic departure function, $\Delta(\cos\theta)$",
  )
  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python depart-extrapolate.py M17-MHD2040-AllB7 
#+END_SRC

#+RESULTS:
[[file:depart-extrapolate-M17-MHD2040-AllB7.pdf]]

#+BEGIN_SRC sh :results file
python depart-extrapolate.py M17-HD2040 1
#+END_SRC

#+RESULTS:
[[file:depart-extrapolate-M17-HD2040.pdf]]


*** Fitting Chebyshev to the departure function
+ This is because the spline fits are very noisy
+ We will see if this also does the extrapolation or whether we still need to do that apart

#+BEGIN_SRC python :eval no :tangle depart-cheby.py
  import sys
  import json
  import numpy as np
  from astropy.modeling import models, fitting
  from astropy.coordinates import Longitude
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append("../Dust-wave")
  import bow_projection as bp

  try:
      prefix = sys.argv[1]
  except:
      print(f"Usage: {sys.argv[0]} PREFIX [CHEBY_DEGREE] [EXTRAP_DEGREE]")

  try:
      cheby_degree = int(sys.argv[2])
  except:
      cheby_degree = 10

  try:
      extrap_degree = int(sys.argv[3])
  except:
      extrap_degree = 2

  plotfile = sys.argv[0].replace('.py', f'-{prefix}.pdf')

  def load_R_th(arc_prefix):
      jfile = f'{arc_prefix}-arcdata.json'
      data = json.load(open(jfile))
      R0 = np.array(data['outer']['R0'])
      R = np.array(data['outer']['R'])
      th = Longitude(data['outer']['theta'], unit='deg')
      th += Longitude(data['outer']['PA0'], unit='deg')
      return th.rad, R/R0


  def departure(R, theta):
      """Parabolic departure of R(theta)"""
      return 1.0/R - 0.5*(1 + np.cos(theta))

  def extrapolate(mu, Delta, mu0=-0.5, force_open=False, deg=2):
      def factor(mu):
          if force_open:
              return np.abs(-1.0 - mu)**0.5
          else:
              return 1.0

      # Only fit mu < mu0
      mask = mu <= mu0
      p = np.poly1d(np.polyfit(mu[mask], Delta[mask]/factor(mu[mask]), deg=deg))
      mu_x = np.linspace(-1.0, mu0)
      return mu_x, factor(mu_x)*p(mu_x)


  sns.set_style('ticks')
  sns.set_color_codes('deep')
  fig, ax = plt.subplots(figsize=(4, 4))

  # Plot x=0, y=0 axes
  ax.axhline(0.0, ls=':', c='k', lw=0.5)
  ax.axvline(0.0, ls=':', c='k', lw=0.5)

  # Plot wilkinoid
  mugrid = np.linspace(-1.0, 1.0, 200)
  thgrid = np.arccos(mugrid)
  ax.plot(mugrid, departure(bp.wilkinoid_R_theta(thgrid), thgrid),
          '-', c='k', lw=1.5)

  # Plot cantoids
  for beta in 0.3, 0.1, 0.03, 0.01, 0.003, 0.001, 0.0003, 0.0001:
      ax.plot(mugrid, departure(bp.cantoid_R_theta(thgrid, beta), thgrid),
              '-', c='k', lw=0.5)

  # Fill in forbidden zone
  # ax.fill_between(mugrid, -0.5*(1.0 + mugrid), -1.0, color='k', alpha=0.4)

  # Plot traced arcs
  th, R = load_R_th(prefix)
  Delta = departure(R, th)
  mu = np.cos(th)
  T = models.Chebyshev1D(degree=cheby_degree)
  fitter = fitting.LevMarLSQFitter()
  T = fitter(T, mu, Delta)
  ax.plot(mu, T(mu), '-', alpha=0.5, color='r', lw=4, label='_nolabel_')

  mux, Deltax = extrapolate(mu, Delta, deg=extrap_degree, force_open=False)
  ax.plot(mux, Deltax, '--', color='r', label='_nolabel_')
  mux, Deltax = extrapolate(mu, Delta, deg=extrap_degree, force_open=True)
  ax.plot(mux, Deltax, '-', color='r',  label='_nolabel_')

  ax.plot(mu, Delta, '.', color='b', alpha=0.8, label=prefix)

  title = "MHD simulation" if "MHD" in prefix else "HD simulation"
  ax.text(0.5, 0.1, title, ha='center', va='bottom')

  ax.set(
      xlim=[-1.05, 1.05],
      ylim=[-0.155, 0.155],
      xlabel=r"$\cos \,\theta$",
      ylabel=r"Parabolic departure function, $\Delta(\cos\theta)$",
  )
  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python depart-cheby.py M17-MHD2040-AllB7 10 2
#+END_SRC

#+RESULTS:
[[file:depart-cheby-M17-MHD2040-AllB7.pdf]]

#+BEGIN_SRC sh :results file
python depart-cheby.py M17-HD2040 10 1
#+END_SRC

#+RESULTS:
[[file:depart-cheby-M17-HD2040.pdf]]


** Plot planitude--alatude for Meyers (2017)

*** Harvest shape parameters
#+name: harvest-radii-m17
#+BEGIN_SRC python :return table
  import json

  SOURCES = [
      "M17-MHD2040-AllB7",
      "M17-MHD2040-AllB7-Halpha-i00",
      "M17-MHD2040-AllB7-60mic-i30",
      "M17-MHD2040-AllB7-60mic-i45",
      "M17-MHD2040-AllB7-60mic-i60",
      "M17-HD2040",
      "M17-HD2040-Halpha-i00",
      "M17-HD2040-Halpha-i00-CD",
      "M17-HD2040-Halpha-i00-BS",
      "M17-HD2040-60mic-i30",
      "M17-HD2040-60mic-i45",
      "M17-HD2040-60mic-i60",
  ]

  radii_header = ['R0/pc', 'Rc/R0', 'R90/R0', 'Rm90/R0']
  header = [['Source', *radii_header], None]
  INVALID = -999.00
  body = []


  for source in SOURCES:
      jfile = f'{source}-arcdata.json'
      data = json.load(open(jfile))
      assert source == data['star']['id']
      D = data['star']['D']
      row = [source]
      arc = 'outer'
      # Translate from screenshot pixels to parsec
      if 'Halpha' in source:
          pc = 198.0
      elif '60mic' in source:
          pc = 41.25
      else:
          pc = 127.0

      if arc in data:
          R0 = data[arc]['R0']
          Rc = data[arc]['Rc'] / R0
          if 'R90' in data[arc]:
              Rm90, R90 = data[arc]['R90']
              if Rm90 > 0.0:
                  Rm90 /= R0
              if R90 > 0.0:
                  R90 /= R0
          else:
              Rm90, R90 = INVALID, INVALID
          row += [f'{_:.2f}' for _ in [R0/pc, Rc, Rm90, R90]]
      else:
          row += [f'{_:.2f}' for _ in [INVALID, INVALID, INVALID, INVALID]]
      body.append(row)

  body.append(["M17-MHD2040-AllB7-60mic-i90", 1.05] + [INVALID]*3 )
  body.append(["M17-HD2040-60mic-i90", 3.0] + [INVALID]*3 )
  #body.sort(key=lambda x: x[0])
  table = header + body

#+END_SRC

#+RESULTS: harvest-radii-m17
| Source                       | R0/pc |  Rc/R0 | R90/R0 | Rm90/R0 |
|------------------------------+-------+--------+--------+---------|
| M17-MHD2040-AllB7            |  0.38 |   3.57 |   1.95 |    1.92 |
| M17-MHD2040-AllB7-Halpha-i00 |  0.40 |   2.83 |   1.90 |    1.89 |
| M17-MHD2040-AllB7-60mic-i30  |  0.48 |   2.14 |   1.74 |    1.73 |
| M17-MHD2040-AllB7-60mic-i45  |  0.56 |   1.70 |   1.59 |    1.61 |
| M17-MHD2040-AllB7-60mic-i60  |  0.67 |   1.51 |   1.47 |    1.46 |
| M17-HD2040                   |  0.66 |   1.78 |   1.75 |    1.75 |
| M17-HD2040-Halpha-i00        |  0.71 |   2.33 |   1.83 |    1.85 |
| M17-HD2040-Halpha-i00-CD     |  0.59 |   1.68 |   1.93 |    1.93 |
| M17-HD2040-Halpha-i00-BS     |  0.75 |   1.91 |   1.83 |    1.83 |
| M17-HD2040-60mic-i30         |  1.17 |   1.89 |   1.80 |    1.79 |
| M17-HD2040-60mic-i45         |  1.36 |   1.87 |   1.90 |    1.59 |
| M17-HD2040-60mic-i60         |  1.70 |   1.66 |   1.55 |    1.59 |
| M17-MHD2040-AllB7-60mic-i90  |  1.05 | -999.0 | -999.0 |  -999.0 |
| M17-HD2040-60mic-i90         |   3.0 | -999.0 | -999.0 |  -999.0 |



*** Predict the projected planitude--alatude from the shape
+ [X] Work out how to extrapolate the shape from 150 \to 180 degrees 

#+BEGIN_SRC python :eval no :tangle simulation_shape.py
  import sys
  import json
  import numpy as np
  import statsmodels.api as sm
  from astropy.coordinates import Longitude
  from astropy.modeling import models, fitting
  sys.path.append("../Dust-wave")
  from bow_projection import Spline_R_theta_from_grid


  def departure(R, theta):
      """Parabolic departure of R(theta)"""
      return 1.0/R - 0.5*(1 + np.cos(theta))


  def R_from_Delta(mu, Delta):
      """Get radius back from departure coefficient"""
      return 1.0/(Delta + 0.5*(1.0 + mu))


  JSON_SUFFIX = "-arcdata.json"

  def load_R_th(arc_prefix):
      jfile = arc_prefix + JSON_SUFFIX
      data = json.load(open(jfile))
      R0 = np.array(data['outer']['R0'])
      R = np.array(data['outer']['R'])
      th = np.radians(data['outer']['theta'])
  #    th = Longitude(data['outer']['theta'], unit='deg')
  #    th += Longitude(data['outer']['PA0'], unit='deg')
      return th, R/R0


  class Simulation(object):
      """
      Bow shape from simulation - defined on grid and fit with splines

      Callable as function of theta
      """
      lowess_frac = 0.2

      def extrapolation_factor(self, mu):
          if self.force_open:
              return np.abs(-1.0 - mu)**0.5
          else:
              return 1.0

      def extrapolation(self, mu):
          return self.extrapolation_factor(mu)*self.extrap_polyfit(mu)

      def __init__(self, name, extrap_degree=2, mu0=-0.5,
                   cheby_degree=10, force_open=False, mode="all"):
          self.name = name
          self.force_open = force_open
          self.thgrid, self.Rgrid = load_R_th(name)
          self.thmax = self.thgrid.max()

          # Set up grid of departure function vs mu
          Delta = departure(self.Rgrid, self.thgrid)
          mu = np.cos(self.thgrid)

          # Set up Chebyshev fit to grid data (theta < thmax)
          self.chebyfit = models.Chebyshev1D(degree=cheby_degree)
          fitter = fitting.LevMarLSQFitter()
          self.chebyfit = fitter(self.chebyfit, mu, Delta)

          # Set up extrapolation fit for theta > thmax
          # Only fit mu < mu0
          mask = mu <= mu0
          self.extrap_polyfit = np.poly1d(np.polyfit(
              mu[mask], Delta[mask]/self.extrapolation_factor(mu[mask]),
              deg=extrap_degree))

          # if mode == "all":
          #     # Use all points but take absolute value of theta
          #     self.thgrid = np.abs(self.thgrid)
          #     # And do some lowess smoothing
          #     smooth = sm.nonparametric.lowess(self.Rgrid, self.thgrid,
          #                                      frac=self.lowess_frac)
          #     self.thgrid = smooth[:, 0]
          #     self.Rgrid = smooth[:, 1]
          # elif mode == "positive":
          #     # Use only points with positive theta
          #     m = self.thgrid > 0.0
          #     self.thgrid = self.thgrid[m]
          #     self.Rgrid = self.Rgrid[m]
          # elif mode == "negative":
          #     # Use only points with negative theta
          #     m = self.thgrid < 0.0
          #     self.thgrid = -self.thgrid[m]
          #     self.Rgrid = self.Rgrid[m]

          # # Make sure arrays are sorted 
          # sort_order = self.thgrid.argsort()
          # self.thgrid = self.thgrid[sort_order]
          # self.Rgrid = self.Rgrid[sort_order]

          # th_x = np.arccos(mu_x)
          # R_x = R_from_Delta(mu_x, Delta_x)

          # # Add on the extrapolated points
          # self.thgrid = np.concatenate((self.thgrid, th_x))
          # self.Rgrid = np.concatenate((self.Rgrid, R_x))
          # # And sort again just in case
          # sort_order = self.thgrid.argsort()
          # self.thgrid = self.thgrid[sort_order]
          # self.Rgrid = self.Rgrid[sort_order]

          # # Finally do the spline fit
          # self.splinefit = Spline_R_theta_from_grid(
          #     theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the fitted result
          mu = np.cos(theta)
          # Use Chebyshev for the range of the grid data
          # and use extrapolation for larger angles
          mask = np.cos(theta) >= np.cos(self.thmax)
          Delta = np.empty_like(mu)
          Delta[mask] = self.chebyfit(mu[mask])
          Delta[~mask] = self.extrapolation(mu[~mask])
          return R_from_Delta(mu, Delta)



#+END_SRC


**** Test R(\theta) spline fit for Meyer (2017) shapes
#+BEGIN_SRC python :eval no :tangle test_simulation_shape.py
  import sys
  import numpy as np
  from simulation_shape import Simulation
  from matplotlib import pyplot as plt
  import seaborn as sns

  figfile = sys.argv[0].replace('.py', '.pdf')


  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)

  for label, shape in [
          ["MHD open",
           Simulation(name="M17-MHD2040-AllB7",
                      force_open=True, extrap_degree=2)],
          ["MHD closed",
           Simulation(name="M17-MHD2040-AllB7",
                      force_open=False, extrap_degree=2)],
          ["HD open",
           Simulation(name="M17-HD2040",
                      force_open=True, extrap_degree=1)],
          ["HD closed",
           Simulation(name="M17-HD2040",
                      force_open=False, extrap_degree=1)],
  ]:
      ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
              color='b', alpha=0.2, lw=2, label='_nolabel_')
      ax.plot(th_dg, shape(th), lw=0.8, label=label)

  ax.legend(title=r"Simulation shapes")
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$R$",
      xlim=[-180, 180],
      yscale='log',
      ylim=[0.9, 30.0],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_simulation_shape.py
#+END_SRC

#+RESULTS:
[[file:test_simulation_shape.pdf]]


**** Test \omega from simulation
This looks a bit ropey
#+BEGIN_SRC python :eval no :tangle test_simulation_omega.py
  import sys
  import numpy as np
  from simulation_shape import Simulation
  sys.path.append("../Dust-wave")
  from bow_projection import omega
  from matplotlib import pyplot as plt
  import seaborn as sns

  figfile = sys.argv[0].replace('.py', '.pdf')


  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)

  for label, shape in [
           ["MHD open",
            Simulation(name="M17-MHD2040-AllB7",
                       force_open=True, cheby_degree=12)],
           ["MHD closed",
            Simulation(name="M17-MHD2040-AllB7",
                       force_open=False, cheby_degree=12)],
           ["HD open",
            Simulation(name="M17-HD2040",
                       force_open=True, cheby_degree=12, extrap_degree=1)],
           ["HD closed",
            Simulation(name="M17-HD2040",
                       force_open=False, cheby_degree=12, extrap_degree=1)],
   ]:
      ax.plot(th_dg, omega(th, shape), label=label)

  ax.legend(title=r"Simulation shapes")
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
  ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
  ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
      xlim=[0, 180],
      ylim=[-0.5, 10.1],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_simulation_omega.py
#+END_SRC

#+RESULTS:
[[file:test_simulation_omega.pdf]]


**** Test (x_t’, y_t’) for simulations
#+BEGIN_SRC python :eval no :tangle test_xyprime_simulation.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append("../Dust-wave")
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from simulation_shape import Simulation

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  # For some reason, exactly 30.0 had problems with R0p
  inclinations = [0.0, 15.0, 30.01, 45.0, 60.0, 75.01]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  sims = ["M17-MHD2040-AllB7", "M17-HD2040", "M17-MHD2040-AllB7", "M17-HD2040"]

  labels = ["MHD open", "MHD closed", "HD open", "HD closed"]
  mode = "negative"
  shapes = [
      Simulation(name="M17-MHD2040-AllB7", force_open=True, cheby_degree=12),
      Simulation(name="M17-MHD2040-AllB7", force_open=False, cheby_degree=12),
      Simulation(name="M17-HD2040", force_open=True, cheby_degree=12, extrap_degree=1),
      Simulation(name="M17-HD2040", force_open=False, cheby_degree=12, extrap_degree=1)]

  for label, shape, ax in zip(labels, shapes, axes.flat):
      th_inf = theta_infinity(shape)
      th_inf = max(th_inf, np.pi)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          if not np.isfinite(th0):
              th0 = 0.0
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          # if m.sum() == 0:
          #     # Case of no tangent line at all at this inclination
          #     continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)        
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:.0f}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      if "open" in label:
          ax.legend(fontsize='small',
                    handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                    ncol=2, loc="center left")
      ax.text(0, 4, label, ha='right', va='top')
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )

  sns.despine()
  for ax in axes.flat:
      ax.label_outer()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_simulation.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_simulation.pdf]]



*** Test diagnostic diagram for the Meyer (2017) sims

#+name: test-simulation-diagnostic
#+header: :var name="M17-MHD2040-AllB7" forceopen=1
#+BEGIN_SRC python :eval yes :return result
  import sys
  import numpy as np
  sys.path.append("../Dust-wave")
  import bow_projection as bp
  import bow_diagnostic
  from simulation_shape import Simulation

  bp.N_NEIGHBORHOOD = 200
  bp.DEGREE_POLY_NEIGHBORHOOD = 1
  bp.SCALE_NEIGHBORHOOD = (60./180.) # => +/-60 deg at i=0
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01
  shape = Simulation(name=name, force_open=forceopen==1, cheby_degree=12)
  th_inf = bp.theta_infinity(shape)
  sini = np.linspace(0.0, 1.0, endpoint=False)
  inclinations = np.arcsin(sini)
  tab = bow_diagnostic.parameter_table(inclinations, shape)

  result = [tab.colnames, None] + list(tab.as_array())

#+END_SRC

#+RESULTS: test-simulation-diagnostic
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|    1.014 |      0 |      90 |      180 |          1.9055 |         5.8527 |    0 |
|   1.0125 |    1.3 |      90 |      180 |          1.9085 |         5.9455 |  1.1 |
|   1.0128 |    2.7 |    90.1 |      180 |          1.9083 |         5.9187 |  2.3 |
|   1.0306 |    4.4 |    90.1 |      180 |          1.8762 |         4.4094 |  3.4 |
|   1.0695 |   30.5 |    90.2 |      180 |           1.809 |         2.8777 |  4.6 |
|   1.0732 |   31.3 |    90.4 |      180 |          1.8042 |         2.8343 |  5.7 |
|   1.0786 |   31.9 |    90.5 |      180 |          1.7968 |         2.7647 |  6.9 |
|    1.084 |   32.6 |    90.7 |      180 |            1.79 |         2.7074 |    8 |
|   1.0895 |   33.3 |      91 |      180 |          1.7833 |         2.6552 |  9.2 |
|   1.0957 |   33.9 |    91.2 |      180 |          1.7757 |         2.5986 | 10.4 |
|   1.1024 |   34.6 |    91.5 |      180 |          1.7678 |         2.5431 | 11.5 |
|   1.1093 |   35.3 |    91.8 |      180 |            1.76 |         2.4914 | 12.7 |
|   1.1167 |     36 |    92.1 |      180 |          1.7519 |         2.4413 | 13.9 |
|   1.1245 |   36.7 |    92.5 |      180 |          1.7435 |         2.3913 | 15.1 |
|   1.1327 |   37.4 |    92.9 |      180 |           1.735 |         2.3432 | 16.3 |
|   1.1413 |   38.2 |    93.4 |      180 |          1.7263 |          2.297 | 17.5 |
|   1.1504 |   39.1 |    93.8 |      180 |          1.7173 |         2.2502 | 18.7 |
|   1.1601 |     40 |    94.3 |      180 |          1.7079 |         2.2029 | 19.9 |
|   1.1703 |   41.2 |    94.8 |      180 |          1.6983 |         2.1566 | 21.1 |
|   1.1811 |   42.5 |    95.4 |      180 |          1.6884 |         2.1103 | 22.3 |
|   1.1925 |   44.4 |      96 |      180 |          1.6781 |         2.0636 | 23.6 |
|   1.2048 |   47.6 |    96.6 |      180 |          1.6672 |         2.0152 | 24.8 |
|   1.2183 |   51.7 |    97.3 |      180 |          1.6554 |         1.9653 | 26.1 |
|   1.2319 |   54.2 |      98 |      180 |          1.6442 |         1.9214 | 27.4 |
|   1.2453 |   56.1 |    98.8 |      180 |          1.6338 |         1.8834 | 28.7 |
|   1.2588 |   57.6 |    99.6 |      180 |          1.6242 |         1.8502 |   30 |
|   1.2722 |   58.9 |   100.5 |      180 |          1.6154 |         1.8214 | 31.3 |
|   1.2857 |   60.1 |   101.4 |      180 |          1.6073 |         1.7966 | 32.7 |
|   1.2995 |   61.2 |   102.4 |      180 |          1.5998 |         1.7745 | 34.1 |
|   1.3133 |   62.4 |   103.5 |      180 |          1.5932 |          1.757 | 35.5 |
|   1.3276 |   63.5 |   104.6 |      180 |           1.587 |         1.7411 | 36.9 |
|   1.3426 |   64.6 |   105.7 |      180 |          1.5809 |         1.7267 | 38.3 |
|   1.3587 |   65.8 |   106.9 |      180 |          1.5745 |         1.7111 | 39.8 |
|   1.3757 |   67.1 |   108.1 |      180 |          1.5681 |         1.6963 | 41.3 |
|   1.3942 |   68.5 |   109.3 |      180 |          1.5611 |         1.6799 | 42.8 |
|   1.4141 |   70.2 |   110.5 |      180 |          1.5534 |         1.6625 | 44.4 |
|   1.4363 |   72.3 |   111.6 |      180 |          1.5443 |         1.6408 | 46.1 |
|   1.4601 |   75.1 |   112.8 |      180 |          1.5344 |         1.6193 | 47.7 |
|   1.4855 |     79 |     114 |      180 |          1.5239 |          1.599 | 49.5 |
|   1.5134 |   82.6 |   115.2 |      180 |          1.5119 |         1.5765 | 51.3 |
|   1.5439 |   85.4 |   116.4 |      180 |          1.4983 |         1.5531 | 53.1 |
|    1.577 |     88 |   117.6 |      180 |          1.4836 |         1.5318 | 55.1 |
|   1.6136 |   90.5 |     119 |      180 |           1.467 |         1.5127 | 57.1 |
|   1.6546 |   93.3 |   120.5 |      180 |          1.4482 |         1.4981 | 59.3 |
|   1.7031 |   96.8 |   122.4 |      180 |          1.4252 |         1.4815 | 61.6 |
|   1.7626 |  102.2 |   124.8 |      180 |          1.3965 |         1.4524 | 64.2 |
|   1.8374 |  107.9 |   128.1 |      180 |          1.3616 |         1.4006 | 66.9 |
|   1.9298 |  111.9 |   131.8 |      180 |          1.3222 |         1.3361 | 70.1 |
|   2.0448 |  115.7 |   134.6 |      180 |          1.2767 |         1.2679 | 73.7 |
|   2.2036 |  120.9 |     137 |      180 |          1.2146 |         1.1974 | 78.5 |

#+call: test-simulation-diagnostic(forceopen=0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|    1.014 |      0 |      90 |      180 |          1.9055 |         5.8527 |    0 |
|   1.0125 |    1.3 |      90 |      180 |          1.9083 |         5.9336 |  1.1 |
|   1.0128 |    2.7 |    90.1 |      180 |          1.9083 |         5.9187 |  2.3 |
|   1.0306 |    4.4 |    90.1 |      180 |          1.8762 |         4.4094 |  3.4 |
|   1.0695 |   30.5 |    90.2 |      180 |           1.809 |         2.8777 |  4.6 |
|   1.0732 |   31.3 |    90.4 |      180 |          1.8042 |         2.8343 |  5.7 |
|   1.0786 |   31.9 |    90.5 |      180 |          1.7968 |         2.7647 |  6.9 |
|   1.0836 |   32.6 |    90.7 |      180 |          1.7906 |         2.7136 |    8 |
|   1.0895 |   33.3 |      91 |      180 |          1.7833 |         2.6552 |  9.2 |
|   1.0957 |   33.9 |    91.2 |      180 |          1.7757 |         2.5986 | 10.4 |
|   1.1024 |   34.6 |    91.5 |      180 |          1.7678 |         2.5431 | 11.5 |
|   1.1093 |   35.3 |    91.8 |      180 |            1.76 |         2.4914 | 12.7 |
|   1.1167 |     36 |    92.1 |      180 |          1.7518 |         2.4407 | 13.9 |
|   1.1245 |   36.7 |    92.5 |      180 |          1.7435 |         2.3913 | 15.1 |
|   1.1326 |   37.4 |    92.9 |      180 |          1.7351 |         2.3443 | 16.3 |
|   1.1413 |   38.2 |    93.4 |      180 |          1.7263 |          2.297 | 17.5 |
|   1.1504 |   39.1 |    93.8 |      180 |          1.7173 |         2.2502 | 18.7 |
|     1.16 |     40 |    94.3 |      180 |           1.708 |         2.2037 | 19.9 |
|   1.1703 |   41.2 |    94.8 |      180 |          1.6983 |         2.1566 | 21.1 |
|   1.1811 |   42.5 |    95.4 |      180 |          1.6884 |         2.1103 | 22.3 |
|   1.1925 |   44.4 |      96 |      180 |          1.6781 |         2.0636 | 23.6 |
|   1.2049 |   47.6 |    96.6 |      180 |          1.6671 |         2.0149 | 24.8 |
|   1.2183 |   51.7 |    97.3 |      180 |          1.6554 |         1.9653 | 26.1 |
|   1.2319 |   54.2 |      98 |      180 |          1.6442 |         1.9214 | 27.4 |
|   1.2453 |   56.1 |    98.8 |      180 |          1.6339 |         1.8837 | 28.7 |
|   1.2588 |   57.6 |    99.6 |      180 |          1.6242 |         1.8502 |   30 |
|   1.2722 |   58.9 |   100.5 |      180 |          1.6154 |         1.8214 | 31.3 |
|   1.2857 |   60.1 |   101.4 |      180 |          1.6073 |         1.7966 | 32.7 |
|   1.2995 |   61.2 |   102.4 |      180 |          1.5998 |         1.7745 | 34.1 |
|   1.3135 |   62.4 |   103.5 |      180 |           1.593 |         1.7559 | 35.5 |
|   1.3279 |   63.5 |   104.6 |      180 |          1.5867 |         1.7398 | 36.9 |
|   1.3428 |   64.6 |   105.7 |      180 |          1.5806 |         1.7252 | 38.3 |
|   1.3587 |   65.8 |   106.9 |      180 |          1.5745 |         1.7111 | 39.8 |
|   1.3754 |   67.1 |   108.1 |      180 |          1.5685 |         1.6978 | 41.3 |
|   1.3942 |   68.5 |   109.3 |      180 |          1.5611 |         1.6799 | 42.8 |
|   1.4141 |   70.2 |   110.5 |      180 |          1.5534 |         1.6625 | 44.4 |
|   1.4361 |   72.3 |   111.6 |      180 |          1.5444 |         1.6416 | 46.1 |
|     1.46 |   75.1 |   112.8 |      180 |          1.5345 |         1.6198 | 47.7 |
|   1.4855 |     79 |     114 |      180 |          1.5239 |          1.599 | 49.5 |
|   1.5133 |   82.6 |   115.2 |      180 |           1.512 |          1.577 | 51.3 |
|   1.5438 |   85.4 |   116.4 |      180 |          1.4985 |         1.5537 | 53.1 |
|    1.577 |     88 |   117.6 |      180 |          1.4836 |         1.5318 | 55.1 |
|   1.6134 |   90.5 |     119 |      180 |          1.4672 |         1.5135 | 57.1 |
|   1.6544 |   93.3 |   120.5 |      180 |          1.4484 |         1.4988 | 59.3 |
|   1.7029 |   96.8 |   122.4 |      180 |          1.4253 |          1.482 | 61.6 |
|   1.7626 |  102.2 |   124.8 |      180 |          1.3965 |         1.4524 | 64.2 |
|   1.8374 |  107.9 |   128.1 |      180 |          1.3616 |         1.4005 | 66.9 |
|   1.9299 |  111.9 |   131.8 |      180 |          1.3222 |          1.336 | 70.1 |
|   2.0449 |  115.7 |   134.6 |      180 |          1.2767 |         1.2679 | 73.7 |
|   2.2036 |  120.9 |     137 |      180 |          1.2146 |         1.1974 | 78.5 |

#+call: test-simulation-diagnostic(name="M17-HD2040", forceopen=1)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0089 |      0 |      90 |      180 |          1.7271 |         1.8193 |    0 |
|   1.0101 |   11.5 |      90 |      180 |          1.7253 |         1.8437 |  1.1 |
|   1.0101 |   12.8 |    90.1 |      180 |          1.7259 |         1.8521 |  2.3 |
|   1.0103 |   13.9 |    90.2 |      180 |          1.7265 |         1.8601 |  3.4 |
|   1.0108 |   14.9 |    90.3 |      180 |          1.7272 |         1.8678 |  4.6 |
|   1.0116 |   15.8 |    90.4 |      180 |          1.7276 |         1.8743 |  5.7 |
|   1.0125 |   16.7 |    90.6 |      180 |          1.7282 |         1.8818 |  6.9 |
|   1.0135 |   17.6 |    90.9 |      180 |          1.7292 |         1.8921 |    8 |
|   1.0148 |   18.5 |    91.1 |      180 |            1.73 |         1.9015 |  9.2 |
|   1.0164 |   19.4 |    91.4 |      180 |          1.7309 |         1.9119 | 10.4 |
|   1.0184 |   20.3 |    91.8 |      180 |          1.7314 |         1.9204 | 11.5 |
|   1.0201 |   21.2 |    92.1 |      180 |           1.733 |         1.9365 | 12.7 |
|   1.0227 |   22.2 |    92.6 |      180 |          1.7336 |         1.9473 | 13.9 |
|   1.0252 |   23.2 |      93 |      180 |          1.7348 |         1.9632 | 15.1 |
|   1.0281 |   24.3 |    93.5 |      180 |          1.7359 |         1.9809 | 16.3 |
|   1.0313 |   25.4 |      94 |      180 |          1.7371 |         2.0004 | 17.5 |
|   1.0345 |   26.8 |    94.6 |      180 |          1.7386 |         2.0254 | 18.7 |
|   1.0386 |   28.4 |    95.2 |      180 |          1.7394 |         2.0484 | 19.9 |
|   1.0433 |   30.3 |    95.8 |      180 |          1.7397 |           2.07 | 21.1 |
|   1.0482 |   32.6 |    96.5 |      180 |          1.7402 |         2.0963 | 22.3 |
|   1.0535 |   35.5 |    97.2 |      180 |          1.7404 |         2.1227 | 23.6 |
|   1.0603 |   38.6 |    97.9 |      180 |          1.7389 |          2.134 | 24.8 |
|   1.0688 |   41.6 |    98.6 |      180 |           1.735 |         2.1253 | 26.1 |
|   1.0787 |   44.6 |    99.3 |      180 |          1.7296 |         2.1042 | 27.4 |
|   1.0902 |   47.9 |   100.1 |      180 |          1.7221 |         2.0691 | 28.7 |
|   1.1027 |   52.4 |   100.9 |      180 |          1.7137 |         2.0296 |   30 |
|   1.1161 |   58.2 |   101.7 |      180 |          1.7046 |         1.9895 | 31.3 |
|   1.1306 |   61.7 |   102.5 |      180 |          1.6946 |         1.9468 | 32.7 |
|   1.1457 |     64 |   103.4 |      180 |          1.6845 |         1.9057 | 34.1 |
|   1.1612 |   65.8 |   104.3 |      180 |          1.6744 |         1.8672 | 35.5 |
|   1.1769 |   67.4 |   105.2 |      180 |          1.6648 |         1.8333 | 36.9 |
|   1.1928 |   68.8 |   106.3 |      180 |          1.6561 |         1.8055 | 38.3 |
|   1.2087 |   70.1 |   107.4 |      180 |          1.6482 |         1.7839 | 39.8 |
|   1.2246 |   71.4 |   108.7 |      180 |          1.6415 |         1.7713 | 41.3 |
|   1.2404 |   72.7 |   110.1 |      180 |          1.6364 |         1.7709 | 42.8 |
|   1.2563 |     74 |   111.7 |      180 |          1.6328 |          1.784 | 44.4 |
|   1.2742 |   75.5 |   113.5 |      180 |          1.6289 |         1.8012 | 46.1 |
|   1.2949 |   77.1 |   115.4 |      180 |          1.6238 |         1.8161 | 47.7 |
|   1.3216 |   79.1 |     117 |      180 |          1.6137 |         1.8046 | 49.5 |
|   1.3538 |   82.1 |   118.5 |      180 |          1.5992 |         1.7709 | 51.3 |
|    1.387 |   90.7 |   119.9 |      180 |          1.5855 |         1.7463 | 53.1 |
|   1.4262 |   95.1 |   121.1 |      180 |          1.5668 |         1.6982 | 55.1 |
|    1.471 |   97.8 |   122.2 |      180 |          1.5437 |          1.641 | 57.1 |
|   1.5203 |  100.2 |   123.4 |      180 |          1.5178 |         1.5863 | 59.3 |
|   1.5741 |  102.5 |   124.7 |      180 |            1.49 |         1.5425 | 61.6 |
|   1.6274 |  105.2 |   130.2 |      180 |          1.4708 |         1.5638 | 64.2 |
|   1.7088 |    110 |   132.3 |      180 |          1.4341 |         1.5079 | 66.9 |
|   1.8115 |  117.8 |   136.3 |      180 |          1.3906 |         1.4153 | 70.1 |
|   1.9289 |  121.2 |     142 |      180 |          1.3539 |         1.3614 | 73.7 |
|   2.1132 |  130.2 |   151.3 |      180 |          1.3094 |         1.2932 | 78.5 |

#+call: test-simulation-diagnostic(name="M17-HD2040", forceopen=0)

#+RESULTS:
| R_0 prime | theta_0 | theta_90 | theta_inf | tilde R_90 prime | tilde R_c prime |  inc |
|----------+--------+---------+----------+-----------------+----------------+------|
|   1.0089 |      0 |      90 |      180 |          1.7271 |         1.8193 |    0 |
|   1.0101 |   11.5 |      90 |      180 |          1.7253 |         1.8437 |  1.1 |
|   1.0101 |   12.8 |    90.1 |      180 |           1.726 |         1.8525 |  2.3 |
|   1.0103 |   13.9 |    90.2 |      180 |          1.7266 |         1.8602 |  3.4 |
|   1.0108 |   14.9 |    90.3 |      180 |          1.7271 |         1.8672 |  4.6 |
|   1.0115 |   15.8 |    90.4 |      180 |          1.7278 |         1.8755 |  5.7 |
|   1.0125 |   16.7 |    90.6 |      180 |          1.7282 |         1.8818 |  6.9 |
|   1.0135 |   17.6 |    90.9 |      180 |          1.7292 |         1.8921 |    8 |
|    1.015 |   18.5 |    91.1 |      180 |          1.7296 |          1.899 |  9.2 |
|   1.0166 |   19.4 |    91.4 |      180 |          1.7305 |         1.9091 | 10.4 |
|   1.0184 |   20.3 |    91.8 |      180 |          1.7314 |         1.9204 | 11.5 |
|   1.0201 |   21.2 |    92.1 |      180 |           1.733 |         1.9365 | 12.7 |
|   1.0227 |   22.2 |    92.6 |      180 |          1.7336 |         1.9473 | 13.9 |
|   1.0252 |   23.2 |      93 |      180 |          1.7348 |         1.9632 | 15.1 |
|   1.0278 |   24.3 |    93.5 |      180 |          1.7365 |         1.9846 | 16.3 |
|    1.031 |   25.4 |      94 |      180 |          1.7376 |         2.0041 | 17.5 |
|   1.0348 |   26.8 |    94.6 |      180 |          1.7381 |         2.0217 | 18.7 |
|   1.0388 |   28.4 |    95.2 |      180 |           1.739 |          2.045 | 19.9 |
|   1.0433 |   30.3 |    95.8 |      180 |          1.7397 |           2.07 | 21.1 |
|   1.0479 |   32.6 |    96.5 |      180 |          1.7405 |         2.0993 | 22.3 |
|   1.0537 |   35.5 |    97.2 |      180 |          1.7401 |         2.1199 | 23.6 |
|   1.0604 |   38.6 |    97.9 |      180 |          1.7386 |         2.1316 | 24.8 |
|   1.0686 |   41.6 |    98.6 |      180 |          1.7353 |         2.1272 | 26.1 |
|   1.0787 |   44.6 |    99.3 |      180 |          1.7296 |         2.1042 | 27.4 |
|   1.0902 |   47.9 |   100.1 |      180 |          1.7221 |         2.0691 | 28.7 |
|   1.1027 |   52.4 |   100.9 |      180 |          1.7138 |           2.03 |   30 |
|   1.1161 |   58.2 |   101.7 |      180 |          1.7046 |         1.9895 | 31.3 |
|   1.1306 |   61.7 |   102.5 |      180 |          1.6946 |         1.9468 | 32.7 |
|   1.1457 |     64 |   103.4 |      180 |          1.6845 |         1.9057 | 34.1 |
|   1.1612 |   65.8 |   104.3 |      180 |          1.6744 |         1.8672 | 35.5 |
|   1.1769 |   67.4 |   105.2 |      180 |          1.6648 |         1.8333 | 36.9 |
|   1.1929 |   68.8 |   106.3 |      180 |          1.6559 |         1.8045 | 38.3 |
|   1.2087 |   70.1 |   107.4 |      180 |          1.6482 |         1.7839 | 39.8 |
|    1.225 |   71.4 |   108.7 |      180 |           1.641 |         1.7693 | 41.3 |
|   1.2408 |   72.7 |   110.1 |      180 |          1.6358 |         1.7682 | 42.8 |
|   1.2568 |     74 |   111.7 |      180 |          1.6322 |         1.7808 | 44.4 |
|   1.2742 |   75.5 |   113.5 |      180 |          1.6289 |         1.8012 | 46.1 |
|   1.2953 |   77.1 |   115.4 |      180 |          1.6233 |         1.8133 | 47.7 |
|   1.3216 |   79.1 |     117 |      180 |          1.6137 |         1.8046 | 49.5 |
|   1.3539 |   82.1 |   118.5 |      180 |          1.5991 |         1.7702 | 51.3 |
|    1.387 |   90.7 |   119.9 |      180 |          1.5855 |         1.7463 | 53.1 |
|   1.4262 |   95.1 |   121.1 |      180 |          1.5668 |         1.6982 | 55.1 |
|   1.4711 |   97.8 |   122.2 |      180 |          1.5435 |         1.6404 | 57.1 |
|   1.5203 |  100.2 |   123.4 |      180 |          1.5178 |         1.5863 | 59.3 |
|   1.5738 |  102.5 |   124.7 |      180 |          1.4902 |         1.5434 | 61.6 |
|   1.6274 |  105.2 |   130.2 |      180 |          1.4707 |         1.5638 | 64.2 |
|   1.7089 |    110 |   131.5 |      180 |          1.4329 |         1.5066 | 66.9 |
|   1.8151 |  117.8 |   134.2 |      180 |          1.3829 |         1.4129 | 70.1 |
|   1.9333 |  121.2 |   137.1 |      180 |          1.3345 |         1.3466 | 73.7 |
|   2.1227 |  124.6 |   140.2 |      180 |          1.2532 |         1.2605 | 78.5 |

*** Make the plot of planitude-alatude plane for Meyer (2017) sims
#+header: :var T=harvest-radii-m17 :colnames no
#+BEGIN_SRC python :eval no :tangle m17-planitude-alatude.py
  import sys
  import numpy as np
  from scipy.interpolate import interp1d
  import statsmodels.api as sm
  from astropy.table import Table
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  from simulation_shape import Simulation
  sys.path.append("../Dust-wave")
  import bow_projection as bp
  import bow_diagnostic


  plotfile = sys.argv[0].replace('.py', '.pdf')

  table = Table(rows=T[1:], names=T[0], dtype=[str] + [float]*4)

  # Take average +/- std of the +ve and -ve R90
  R90stack = np.stack([table['R90/R0'], table['Rm90/R0']])
  table['R90'] = np.nanmean(R90stack, axis=0)
  table['dR90'] = np.nanstd(R90stack, axis=0)
  table.remove_columns(['R90/R0', 'Rm90/R0'])


  def select_marker_style(s):
      if 'Halpha' in s:
          return '^'
      elif '60mic' in s:
          return 's'
      else:
          return 'o'

  def select_marker_size(s):
      if 'i00' in s:
          return 5
      elif 'i30' in s:
          return 6
      elif 'i45' in s:
          return 5
      elif 'i60' in s:
          return 4
      else:
          return 5

  table['marker style'] = [select_marker_style(s) for s in table['Source']]
  table['marker size'] = [select_marker_size(s) for s in table['Source']]

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  Rc_grid = np.linspace(0.9, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, 0.5, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axhline(2.0, ls=':', lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(2.0, ls=':', lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.9, 10.0], [0.9, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = (0.5 + np.arange(20))/20
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")



  bp.N_NEIGHBORHOOD = 200
  bp.DEGREE_POLY_NEIGHBORHOOD = 1
  bp.SCALE_NEIGHBORHOOD = (60./180.) # => +/-60 deg at i=0
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  models = ["M17-HD2040", "M17-MHD2040-AllB7"][::-1]
  labels = ["HD", "MHD"][::-1]

  colors = sns.color_palette(n_colors=len(models))[::-1]
  for model, label, color in zip(models, labels, colors):
      # First do the "theoretical" tracks
      shape = Simulation(name=model, force_open=True, cheby_degree=12)
      th_inf = bp.theta_infinity(shape)
      inc = np.linspace(0.0, th_inf - np.pi/2, 50)
      tab = bow_diagnostic.parameter_table(inc, shape)
      Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
      ax.plot(Rc, R90, '-', c=color, label=label, lw=2.5, alpha=0.5)
      # Put a dot at the i=0 case
      ax.plot(Rc[0:1], R90[0:1], 'o', mec='none', c=color, label="_nolabel_", alpha=0.5)

      # Repeat for the closed shape, but with a thin line
      shape = Simulation(name=model, force_open=False, cheby_degree=12)
      th_inf = bp.theta_infinity(shape)
      inc = np.linspace(0.0, th_inf - np.pi/2, 50)
      tab = bow_diagnostic.parameter_table(inc, shape)
      Rcc, R90c = tab['tilde R_c prime'], tab['tilde R_90 prime']
      ax.plot(Rcc, R90c, '-', c=color, label="_nolabel_", lw=0.5, alpha=1.0)


      sini = (0.5 + np.arange(20))/20
      inc_e = np.arcsin(sini)
      inc_e = inc_e[inc_e < th_inf - np.pi/2]
      # Interpolate to get the even probability points
      Rc_e = interp1d(inc, Rc)(inc_e)
      R90_e = interp1d(inc, R90)(inc_e)

      ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
                 linewidths=0.1, edgecolors='none',
                 c=color, alpha=0.5, label="_nolabel_")

      # Label i=0, 30, 45, 60 along the MHD track
      interp_Rc = interp1d(inc, Rc, bounds_error=False, fill_value="extrapolate")
      interp_R90 = interp1d(inc, R90, bounds_error=False, fill_value="extrapolate")
      if "MHD" in model:
          annotate_data = [
              [0, (-20, -25)], [30, (15, -20)],
              [45, (5, -25)], [60, (-10, -30)]]
      else:
          annotate_data = [
              [0, (-20, 25)], [30, (15, 15)],
              [60, (-20, 25)]]

      for inclination, xytext in annotate_data:
          Rc_i = interp_Rc(np.radians(inclination))
          R90_i = interp_R90(np.radians(inclination))
          ax.annotate(fr"$i = {inclination}^\circ$",
                      (Rc_i, R90_i),
                      xytext=xytext, textcoords='offset points',
                      arrowprops=dict(arrowstyle="->", color=color,
                                      connectionstyle="arc3,rad=.2"),       
                      color=color, fontsize="x-small")


      mask = [s.startswith(model) and '60mic' in s for s in table['Source']]
      data = table[mask]

      for row in data:
          ax.scatter(row['Rc/R0'], row['R90'],
                     marker=row['marker style'],
                     s=1.3*row['marker size']**2, zorder=100,
                     c=color, alpha=0.9, edgecolors='none')
          ax.scatter(row['Rc/R0'], row['R90'],
                     marker=row['marker style'],
                     s=(row['marker size'] - 1.1)**2, zorder=100,
                     c='w', alpha=1.0, edgecolors='none')


  ax.legend(ncol=1, fontsize='small',
            title='Simulation\ncontact discontinuity\n(Meyer et al. 2017)',
            frameon=True, loc="upper left").get_title().set_size('small')
  ax.set(
      xlim=[0.93, 6.1],
      ylim=[0.93, 6.1],
      yscale='log',
      xscale='log',
      #yticks=range(6),
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        
  ax.xaxis.set_minor_formatter(matplotlib.ticker.FormatStrFormatter('%d'))
  ax.yaxis.set_minor_formatter(matplotlib.ticker.FormatStrFormatter('%d'))
  ax.xaxis.set_major_formatter(matplotlib.ticker.FormatStrFormatter('%d'))
  ax.yaxis.set_major_formatter(matplotlib.ticker.FormatStrFormatter('%d'))
  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')


#+END_SRC

#+BEGIN_SRC sh :results file
python m17-planitude-alatude.py
#+END_SRC

#+RESULTS:
[[file:m17-planitude-alatude.pdf]]


*** Make a plot of projected R_0' versus inclination for Meyer (2017) 
+ To incorporate the dust and Ha image measurements in this plot, we need to calibrate the spatial scales between the different maps
+ Measure how many pixels is 1 pc on each map
  + H alpha :: 198 pix
  + Density :: 127 pix
  + Dust :: 41.25 pix
+ Size in pixels of the CD from density images
  + MHD :: 48 pix = 0.378 pc
  + HD :: 84 pix = 0.661 pc
+ Problem with the HD models
  + All the evidence points to R_0 \approx 0.7 for the MS2040 HD model:
    + Meyer 2014 :: Fig 7, Fig 15, Table 2 gives 0.69 pc explicitly
    + Meyer 2016 :: Fig 7 gives R_0^3 as about 10^-0.5 => R_0 \approx 0.68
    + Meyer 2017 :: Fig 1, Fig 3, Fig 4, etc
  + So that is conclusive: R_0 \approx 0.7 pc for HD model
  + *BUT* there is inconsistency with the IR maps, which suggest a bigger R_0
    + We can get a handle on this by looking at the true apex, which is visible on the 25 micron maps
    + The true apex should be projected as ~cos i~
    + Measure y0, y1 as pixel positions of star and true apex at the different inclinations
      |  i |     y0 |     y1 | R_0'' (pc) | R_0 (pc) | Correction |
      |----+--------+--------+-----------+---------+------------|
      | 30 | 1329.6 | 1367.9 |     0.928 |    1.07 |       0.65 |
      | 45 |  809.5 |  841.0 |     0.764 |    1.08 |       0.65 |
      | 60 | 288.85 | 311.45 |     0.548 |    1.10 |       0.63 |
      #+TBLFM: $4=($3 - $2)/41.25;f3::$5=$4/cos($1);f2::$6=0.698/$-1;f2
    + Note that we use 0.698 pc for the true R_0 of the dust emission peak, see next item
    + This gives a correction factor of 0.65
  + In order to do the previous, we need the R_0 of the IR emission peak.  We don't have that exactly, but we do have the R_0 of the dust column density peak from Fig 17 of Meyer (2014)
    | x(0.0 pc) | x(peak) | x(1.0 pc) |    R0 |
    |-----------+---------+-----------+-------|
    |   130.792 | 563.611 |   751.034 | 0.698 |
    #+TBLFM: $4=($2 - $1)/($3 - $1);f3

#+header: :var T=harvest-radii-m17 :colnames no
#+BEGIN_SRC python  :eval no :tangle m17-r0-prime.py
  import sys
  import numpy as np
  from scipy.interpolate import interp1d
  import statsmodels.api as sm
  from astropy.table import Table
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  from simulation_shape import Simulation
  sys.path.append("../Dust-wave")
  import bow_projection as bp
  import bow_diagnostic

  plotfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))


  table = Table(rows=T[1:], names=T[0], dtype=[str] + [float]*4)

  # Take average +/- std of the +ve and -ve R90
  R90stack = np.stack([table['R90/R0'], table['Rm90/R0']])
  table['R90'] = np.nanmean(R90stack, axis=0)
  table['dR90'] = np.nanstd(R90stack, axis=0)
  table.remove_columns(['R90/R0', 'Rm90/R0'])


  def select_marker_style(s):
      if 'Halpha' in s:
          return '^'
      elif '60mic' in s:
          return 's'
      else:
          return 'o'

  def select_marker_size(s):
      if 'i00' in s:
          return 5
      elif 'i30' in s:
          return 6
      elif 'i45' in s:
          return 5
      elif 'i60' in s:
          return 4
      elif 'i90' in s:
          return 3
      else:
          return 5

  def select_inclination(s):
      if 'i00' in s:
          return 0.0
      elif 'i30' in s:
          return 30.0
      elif 'i45' in s:
          return 45.0
      elif 'i60' in s:
          return 60.0
      elif 'i90' in s:
          return 90.0
      else:
          return 0.0


  table['marker style'] = [select_marker_style(s) for s in table['Source']]
  table['marker size'] = [select_marker_size(s) for s in table['Source']]
  table['inclination'] = [select_inclination(s) for s in table['Source']]

  bp.N_NEIGHBORHOOD = 200
  bp.DEGREE_POLY_NEIGHBORHOOD = 1
  bp.SCALE_NEIGHBORHOOD = (60./180.) # => +/-60 deg at i=0
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01

  models = ["M17-HD2040", "M17-MHD2040-AllB7"][::-1]
  labels = ["HD", "MHD"][::-1]

  colors = sns.color_palette(n_colors=len(models))[::-1]
  for model, label, color in zip(models, labels, colors):
      R0 = 0.378 if 'MHD' in model else 0.661
      ax.axhline(R0, ls=':', lw=0.5, color=color)

      inc = np.linspace(0.0, np.pi/2, 100)

      # First do the "theoretical" tracks
      shape = Simulation(name=model, force_open=True, cheby_degree=12)
      tab = bow_diagnostic.parameter_table(inc, shape)
      R0p = tab['R_0 prime']
      ax.plot(np.degrees(inc), R0*R0p, c=color, label=label, lw=2.5, alpha=0.5)

      # Repeat for the closed shape, but with a thin line
      shape = Simulation(name=model, force_open=False, cheby_degree=12)
      tab = bow_diagnostic.parameter_table(inc, shape)
      R0pp = tab['R_0 prime']
      ax.plot(np.degrees(inc), R0*R0pp, '-', c=color, label="_nolabel_", lw=0.5, alpha=1.0)

      mask = [s.startswith(model) and not (s.endswith('BS') or s.endswith('CD')) 
              for s in table['Source']]
      data = table[mask]

      for row in data:
          FIX = 0.63 if label == "HD" and "60mic" in row["Source"] else 1.0
          ax.scatter(row['inclination'], row['R0/pc']*FIX,
                     marker=row['marker style'],
                     s=1.3*row['marker size']**2, zorder=100,
                     c=color, alpha=0.9, edgecolors='none')
          ax.scatter(row['inclination'], row['R0/pc']*FIX,
                     marker=row['marker style'],
                     s=(row['marker size'] - 1.2)**2, zorder=100,
                     c='w', alpha=1.0, edgecolors='none')

  ax.legend(ncol=1, fontsize='small',
            title='Simulation\ncontact discontinuity\n(Meyer et al. 2017)',
            frameon=True, loc="upper left").get_title().set_size('small')
  ax.set(
      xlim=[-5, 95],
      xticks=[0, 15, 30, 45, 60, 75, 90],
      ylim=[0., None],
      xlabel=r"Inclination, $|i|$",
      ylabel=r"Projected apex distance: $R_{0}'$, parsec",
  )        
  sns.despine(trim=True)
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')

#+END_SRC

#+BEGIN_SRC sh :results file
python m17-r0-prime.py
#+END_SRC

#+RESULTS:
[[file:m17-r0-prime.pdf]]


** Meyer 2017 magnetic parameters
+ Magnetic pressure : B^2 / 8 \pi
  + B = 7 \mu G
  + P = 1.95e-12
+ Ram pressure : \rho V^2
  + \rho = 0.57 m /cm^3
  + m = 1.3 m_p => \rho = 1.24e-24 g/cm^3
  + V = 40 km/s = 4e6 cm/s
  + P = 1.984e-11
+ So magnetic pressure is about 0.1 times ram pressure
+ Thermal pressure : 2 n k T
  + T = 1e4 K
  + P = 1.573941342e-12
+ So the plasma beta is about unity
  + This is rather high for an H II region
** Original version --- Plot the planitude--alatude

*** Harvest the shape parameters from the JSON files
+ Do it like in [[id:A3F62646-04B8-448B-91FF-8E1DC04A9C41][The red supergiants and AGB stars]]

#+BEGIN_SRC sh :results verbatim
ls *.json |cut -d'-' -f1-3
#+END_SRC

#+RESULTS:
#+begin_example
A16-12mic-i00
A16-12mic-i30
A16-12mic-i60
A16-20mic-i00
A16-20mic-i30
A16-20mic-i60
A16-Halpha-i00
A16-Halpha-i30
A16-Halpha-i60
M16-MS2070n00p10-BS
M16-MS2070n00p10-CD
M17-HD2040-60mic
M17-HD2040-60mic
M17-HD2040-60mic
M17-HD2040-Halpha
M17-HD2040-Halpha
M17-HD2040-Halpha
M17-HD2040-arcdata.json
M17-MHD2040-AllB7
M17-MHD2040-AllB7
M17-MHD2040-AllB7
M17-MHD2040-AllB7
M17-MHD2040-AllB7
R97-Halpha-i00
#+end_example

#+name: harvest-radii-sims
#+BEGIN_SRC python :return table
  import json

  SOURCES = [
      "A16-12mic-i00", 
      "A16-12mic-i30", 
      "A16-12mic-i60", 
      "A16-20mic-i00", 
      "A16-20mic-i30", 
      "A16-20mic-i60", 
      "A16-Halpha-i00", 
      "A16-Halpha-i30", 
      "A16-Halpha-i60", 
      "R97-Halpha-i00", 
  ]

  radii_header = ['R0/100', 'Rc/R0', 'R90/R0', 'Rm90/R0']
  header = [['Source', *radii_header], None]
  INVALID = -999.00
  body = []
  for source in SOURCES:
      jfile = f'{source}-arcdata.json'
      data = json.load(open(jfile))
      assert source == data['star']['id']
      D = data['star']['D']
      row = [source]
      arc = 'outer'
      if arc in data:
          R0 = data[arc]['R0']
          Rc = data[arc]['Rc'] / R0
          if 'R90' in data[arc]:
              Rm90, R90 = data[arc]['R90']
              if Rm90 > 0.0:
                  Rm90 /= R0
              if R90 > 0.0:
                  R90 /= R0
          else:
              Rm90, R90 = INVALID, INVALID
          row += [f'{_:.2f}' for _ in [R0/100.0, Rc, Rm90, R90]]
      else:
          row += [f'{_:.2f}' for _ in [INVALID, INVALID, INVALID, INVALID]]
      body.append(row)

  #body.sort(key=lambda x: x[0])
  table = header + body

#+END_SRC

#+RESULTS: harvest-radii-sims
| Source         | R0/100 | Rc/R0 | R90/R0 | Rm90/R0 |
|----------------+--------+-------+--------+---------|
| A16-12mic-i00  |   0.44 |  2.59 |   1.69 |    1.69 |
| A16-12mic-i30  |   0.42 |  2.90 |   1.97 |    1.88 |
| A16-12mic-i60  |   0.54 |  1.90 |   1.45 |    1.42 |
| A16-20mic-i00  |   0.41 |  2.05 |   1.75 |    1.87 |
| A16-20mic-i30  |   0.40 |  2.41 |   1.96 |    1.97 |
| A16-20mic-i60  |   0.43 |  4.94 |   1.78 |    1.82 |
| A16-Halpha-i00 |   0.52 |  1.83 |   1.57 |    1.79 |
| A16-Halpha-i30 |   0.63 |  2.25 |   1.53 |    1.54 |
| A16-Halpha-i60 |   0.81 |  1.37 |   1.38 |    1.38 |
| R97-Halpha-i00 |   0.92 |  1.55 |   2.16 |    2.09 |

*** Make the plot
#+header: :var T=harvest-radii-sims :colnames no
#+BEGIN_SRC python :eval no :tangle sims-planitude-alatude.py
  import sys
  import numpy as np
  from scipy.interpolate import interp1d
  import statsmodels.api as sm
  from astropy.table import Table
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  sys.path.append("../Dust-wave")
  import bow_projection as bp
  import bow_diagnostic


  plotfile = sys.argv[0].replace('.py', '.pdf')

  table = Table(rows=T[1:], names=T[0], dtype=[str] + [float]*4)

  # Take average +/- std of the +ve and -ve R90
  R90stack = np.stack([table['R90/R0'], table['Rm90/R0']])
  table['R90'] = np.nanmean(R90stack, axis=0)
  table['dR90'] = np.nanstd(R90stack, axis=0)
  table.remove_columns(['R90/R0', 'Rm90/R0'])

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = (0.5 + np.arange(20))/20
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")


  models = ["A16-12mic", "A16-20mic", "A16-Halpha", "R97-Halpha"]

  colors = sns.color_palette(n_colors=len(models))
  for model, color in zip(models, colors):
      mask = [s.startswith(model) for s in table['Source']]
      data = table[mask]
      ax.plot(data['Rc/R0'], data['R90'], '-', c=color, label=model, lw=1.5, alpha=0.9)
      # Put a dot at the i=0 case
      ax.plot(data['Rc/R0'][0:1], data['R90'][0:1], 'o', mec='none', c=color, label="_nolabel_", alpha=0.7)



  ax.legend(ncol=1, fontsize='small', title='Simulations',
            frameon=True, loc="lower right")
  ax.set(
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
      yticks=range(6),
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')


#+END_SRC

#+BEGIN_SRC sh :results file
python sims-planitude-alatude.py
#+END_SRC

#+RESULTS:
[[file:sims-planitude-alatude.pdf]]

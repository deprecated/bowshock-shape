* Copy figures to paper folder
#+BEGIN_SRC sh :results verbatim
date
cp -v shape-conic-plot-M16-MS2070n00p10.pdf ../papers/Paper1/figs
#+END_SRC

#+RESULTS:
: Sun Nov 26 22:16:04 CST 2017
: shape-conic-plot-M16-MS2070n00p10.pdf -> ../papers/Paper1/figs/shape-conic-plot-M16-MS2070n00p10.pdf




* Bow shock shapes from simulations
+ We will analyze some published synthetic observations from simulations
+ Do it exactly the same as for the real observations
  + Trace arc in ds9
  + Fit to find R0, R90 and Rc
  + Determine \Pi and \Lambda
** Get more simulations
+ [X] We have Acreman 2016
  + One model in 3 bands (Ha, 12 \mu{}m, 20 \mu{}m) for 3 angles (0, 30, 60)
+ [X] We have Raga 1997
  + One model in 1 band (H\alpha) for i=0 only
+ [ ] Potentially we have Meyer 2014
  + Many models in 2 bands (H\alpha and generic dust) for i=0 only
+ [X] And there is Meyer 2016
  + 3 models (n = 0.1, 1, 10 for 20 Msun and 70 km/s), two bands (H\alpha and [O III]), five angles (0, 30, 45, 60, 90), where first comes from density map, and 90 is useless obviously.
  + This looks the best bet
    + We can get the full shape from the density maps, which extend out to \theta = 140 or so
    + The fit some conics and do predicted projection and actual projection for 30, 45, 60
  + *But* there is a flaw
    + Their projected maps have only been calculated using that part of the grid with \theta < 90
    + This means that we cannot find \Lambda' because they are forcing that R_90' = R_90 for all i, which means that \Lambda' will appear to fall because R_0' is increasing.
    + Whereas in reality, \Lambda' will come from shell at \theta_90(i), which is > 90 deg
    + Still we could show this as a warning
+ [ ] Finally there is Meyer 2017 with magnetic fields
  + This eliminates the conduction rubbish
  + And also gives a wider variety of shapes
  + Thirdly, they fix the flaw in the 2016 paper of only considering \theta < 90, so we should be able to really compare the \Pi' and \Lambda' from the simulated maps at different inclinations with the predictions from the shape
  + Their Fig 10 compares MHD and HD simulations of the same star with emission maps of dust in various FIR wave bands, for i = 30, 45, 60, 90
    + The Ha and [O III] emission for the same models are given in Fig 7 for i = 0
    + The density structure is given in Fig 3
  + [2/4] So plan is
    1. [X] Trace the CD from the density images, following a contour
       - This gives the R(\theta), which can be plotted as \Delta(\mu)
    2. [-] Extrapolate to give a full shape
       - We can either take an ellipse extrapolation (\Delta \to constant as \mu \to -1) or an "open" extrapolation (\Delta \to 0 as \mu \to -1)
       - Use that to predict \Pi', \Lambda' as function of inclination
    3. [X] Trace the 60 micron images to find \Pi', \Lambda' for the inclinations 30, 45, 60
       - And the H\alpha image for i=0 for completeness
         - [ ] For the HD model we might want to average the BS and the CD curves
    4. [ ] Compare (1) with (3)


** Convert screenshots to FITS
#+BEGIN_SRC sh :results silent
  for file in *-maps.png; do
      python ~/Work/Image2FITS/image2fits.py $file
  done
#+END_SRC

New ones from Meyer (2016)
#+BEGIN_SRC sh :results silent
  for file in Meyer-2016-MS2070*.png; do
      python ~/Work/Image2FITS/image2fits.py $file
  done
#+END_SRC

New ones from Meyer (2017)
#+BEGIN_SRC sh :results silent
  for file in Meyer-2017-*.png; do
      python ~/Work/Image2FITS/image2fits.py $file
  done
#+END_SRC

** Measure arcs on FITS images
+ Acreman figure
  + E.g., [[file:A16-20mic-i00-forma.reg]]
** Add a WCS to the FITS files
+ It turns out that =find-xy-shell.py= requires one
  + And it is easier to provide one than to re-write the program
#+BEGIN_SRC python :eval no :tangle add-wcs-to-screenshot.py
  import sys
  from astropy.io import fits
  from astropy.wcs import WCS

  try: 
      prefix = sys.argv[1]
  except:
      sys.exit(f"Usage: {sys.argv[0]} PREFIX")

  channels = ['red', 'green', 'blue']
  for channel in channels:
      hdulist = fits.open(f"{prefix}-{channel}.fits", mode="update")
      w = WCS(naxis=2)
      w.wcs.crpix = [0, 0]
      w.wcs.cdelt = [1.0/3600, 1.0/3600]
      w.wcs.crval = [30, -60]
      w.wcs.ctype = ["RA---AIR", "DEC--AIR"]
      hdulist[0].header = w.to_header()
      hdulist.flush()
      hdulist.close()

#+END_SRC

#+BEGIN_SRC sh :results verbatim
  for file in Meyer-2016-MS2070*.png; do
      python add-wcs-to-screenshot.py ${file%%.png}
  done
#+END_SRC

#+BEGIN_SRC sh :results verbatim
  for file in Meyer-2017-*.png; do
      python add-wcs-to-screenshot.py ${file%%.png}
  done
#+END_SRC

#+RESULTS:

+ [X] Then we have to load each of the =.reg= files back in to ds9 and write them out again in wcs format

** Fit the arcs
+ Do it like in [[id:4BC292AA-F2EB-4031-94AB-E6A36B22FD21][Circle fits to second batch of sources]]

#+BEGIN_SRC sh :results silent
  D=../read-shapes-LL
  for wav in 20mic 12mic Halpha; do
      for inc in i00 i30 i60; do
          python $D/find-xy-shell.py A16-${wav}-${inc} --pa0 0 --window 9
      done
  done
#+END_SRC



#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py --help
#+END_SRC

#+RESULTS:
#+begin_example
usage: find-xy-shell.py [-h] [--debug] [--pa0 PA0] [--window WINDOW] source

Find (X, Y) positions of shell boundaries from a DS9 region file

positional arguments:
  source           Name of source, taken as prefix for region file containing
                   shell and star positions

optional arguments:
  -h, --help       show this help message and exit
  --debug          Print out verbose debugging info about each line in region
                   file
  --pa0 PA0        Optionally over-ride guess at PA of bow shock axis
  --window WINDOW  Number of points to use when searching for min R
#+end_example

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/fit-circle-shell.py --help
#+END_SRC

#+RESULTS:
#+begin_example
usage: fit-circle-shell.py [-h] [--savefig] [--debug] [--thmax THMAX] source

Fit circles to all the arcs and save as ds9 region file

positional arguments:
  source         Name of source

optional arguments:
  -h, --help     show this help message and exit
  --savefig      Save a figure showing the fit
  --debug        Print out verbose debugging info
  --thmax THMAX  Maximum angle from axis for points to include in circle fit
#+end_example


#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for wav in 20mic 12mic Halpha; do
      for inc in i00 i30 i60; do
          python $D/fit-circle-shell.py A16-${wav}-${inc} --thmax 60 --savefig --figscale 150
      done
  done
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 12
    # data points      = 9
    # variables        = 2
    chi-square         = 1.500
    reduced chi-square = 0.214
    Akaike info crit   = -12.125
    Bayesian info crit = -11.731
[[Variables]]
    xc:  -0.86827844 +/- 0.484223 (55.77%) (init=-1.415982)
    yc:  -43.0169955 +/- 3.451873 (8.02%) (init=-40.94287)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.868278445549 -43.0169955505 83.9520885522
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 9
    # variables        = 2
    chi-square         = 0.952
    reduced chi-square = 0.136
    Akaike info crit   = -16.222
    Bayesian info crit = -15.828
[[Variables]]
    xc:   0.26327242 +/- 0.440482 (167.31%) (init= 0.1885513)
    yc:  -56.6615451 +/- 3.378267 (5.96%) (init=-40.43253)
[[Correlations]] (unreported correlations are <  0.100)
outer : 0.263272420544 -56.6615451113 97.2688410428
[[Fit Statistics]]
    # function evals   = 21
    # data points      = 10
    # variables        = 2
    chi-square         = 12.096
    reduced chi-square = 1.512
    Akaike info crit   = 5.903
    Bayesian info crit = 6.508
[[Variables]]
    xc:  -0.94112604 +/- 2.550386 (270.99%) (init= 0.64284)
    yc:  -169.000042 +/- 51.30050 (30.36%) (init=-43.32933)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.941126046004 -169.000042284 214.24326031
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 30
    # variables        = 2
    chi-square         = 3.663
    reduced chi-square = 0.131
    Akaike info crit   = -59.089
    Bayesian info crit = -56.287
[[Variables]]
    xc:  -1.88017148 +/- 0.211841 (11.27%) (init=-1.455069)
    yc:  -70.7512435 +/- 2.054985 (2.90%) (init=-44.26959)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.181 
outer : -1.88017148162 -70.7512435821 114.932519062
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 22
    # variables        = 2
    chi-square         = 9.569
    reduced chi-square = 0.478
    Akaike info crit   = -14.316
    Bayesian info crit = -12.134
[[Variables]]
    xc:  -2.02239761 +/- 0.530814 (26.25%) (init= 0.1877718)
    yc:  -77.6627673 +/- 5.505573 (7.09%) (init=-41.52165)
[[Correlations]] (unreported correlations are <  0.100)
outer : -2.02239761853 -77.6627673223 120.48605475
[[Fit Statistics]]
    # function evals   = 12
    # data points      = 12
    # variables        = 2
    chi-square         = 9.543
    reduced chi-square = 0.954
    Akaike info crit   = 1.251
    Bayesian info crit = 2.221
[[Variables]]
    xc:  -3.19000930 +/- 0.650585 (20.39%) (init=-2.587487)
    yc:  -48.1391239 +/- 6.356706 (13.20%) (init=-53.83477)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.151 
outer : -3.19000930802 -48.1391239766 102.461613882
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 15
    # variables        = 2
    chi-square         = 75.590
    reduced chi-square = 5.815
    Akaike info crit   = 28.259
    Bayesian info crit = 29.675
[[Variables]]
    xc:  -0.90720240 +/- 1.526846 (168.30%) (init=-1.735478)
    yc:  -42.2411966 +/- 9.675294 (22.90%) (init=-52.12203)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.907202408862 -42.241196604 95.2588341179
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 12
    # variables        = 2
    chi-square         = 2.646
    reduced chi-square = 0.265
    Akaike info crit   = -14.140
    Bayesian info crit = -13.170
[[Variables]]
    xc:  -0.49692657 +/- 0.510309 (102.69%) (init=-0.8667289)
    yc:  -77.9597925 +/- 3.784126 (4.85%) (init=-62.6494)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.260 
outer : -0.496926576525 -77.9597925915 141.013742592
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 12
    # variables        = 2
    chi-square         = 19.731
    reduced chi-square = 1.973
    Akaike info crit   = 9.968
    Bayesian info crit = 10.937
[[Variables]]
    xc:   0.03098664 +/- 0.915668 (2955.04%) (init=-1.467732)
    yc:  -29.9301989 +/- 4.449084 (14.86%) (init=-80.68895)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.104 
outer : 0.0309866408166 -29.930198911 110.304078185
#+end_example


#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py R97-Halpha-i00 --pa0 90 --window 9
  python $D/fit-circle-shell.py R97-Halpha-i00 --thmax 60 --savefig --figscale 300
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 7
    # variables        = 2
    chi-square         = 140.998
    reduced chi-square = 28.200
    Akaike info crit   = 25.020
    Bayesian info crit = 24.912
[[Variables]]
    xc:  -47.9081712 +/- 27.37979 (57.15%) (init=-91.68763)
    yc:  -2.14965635 +/- 4.968434 (231.13%) (init=-1.367659)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.267 
outer : -47.9081712238 -2.14965635401 142.082194775
#+end_example

** Fit arcs to Meyer 2017 shapes
#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M17-MHD2040-AllB7 --pa0 0 --window 11
  python $D/fit-circle-shell.py M17-MHD2040-AllB7 --thmax 60 --savefig --figscale 200
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 18
    # data points      = 23
    # variables        = 2
    chi-square         = 17.024
    reduced chi-square = 0.811
    Akaike info crit   = -2.921
    Bayesian info crit = -0.650
[[Variables]]
    xc:   0.87844247 +/- 1.139105 (129.67%) (init= 1.09081)
    yc:  -122.078095 +/- 11.38874 (9.33%) (init=-47.69958)
[[Correlations]] (unreported correlations are <  0.100)
outer : 0.878442476821 -122.078095702 170.417646989
#+end_example

#+BEGIN_SRC sh :results silent
open M17-*-arcfits.pdf
#+END_SRC

#+BEGIN_SRC sh :results file
python shape-conic-plot.py M17-MHD2040-AllB7 
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-M17-MHD2040-AllB7.pdf]]

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M17-HD2040 --pa0 0 --window 11
  python $D/fit-circle-shell.py M17-HD2040 --thmax 60 --savefig --figscale 250
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 30
    # variables        = 2
    chi-square         = 11.414
    reduced chi-square = 0.408
    Akaike info crit   = -24.991
    Bayesian info crit = -22.188
[[Variables]]
    xc:   0.22707331 +/- 0.389464 (171.52%) (init= 0.2886785)
    yc:  -65.0888304 +/- 1.950807 (3.00%) (init=-84.06985)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.160 
outer : 0.227073314289 -65.0888304071 149.803410692
#+end_example

#+BEGIN_SRC sh :results file
python shape-conic-plot.py M17-HD2040 
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-M17-HD2040.pdf]]



*** Reflect the one-sided arcs to make symmetrical
+ The dust emission images show only one side, but we need the make it symmetric so that ~find-xy-shell.py~ will work
+ Easiest to add an argument to [[file:~/Work/Bowshocks/Jorge/bowshock-shape/read-shapes-LL/find-xy-shell.py]]
  
#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for inc in i30 i60 i45; do
      python $D/find-xy-shell.py M17-MHD2040-AllB7-60mic-$inc --mirror --pa0 0 --window 11
      python $D/fit-circle-shell.py M17-MHD2040-AllB7-60mic-$inc --thmax 60 --savefig --figscale 60
  done
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 27
    # data points      = 22
    # variables        = 2
    chi-square         = 0.438
    reduced chi-square = 0.022
    Akaike info crit   = -82.154
    Bayesian info crit = -79.972
[[Variables]]
    xc:  -1.2970e-05 +/- 0.101708 (784188.97%) (init= 0.1209432)
    yc:  -22.7386327 +/- 0.703891 (3.10%) (init=-19.93934)
[[Correlations]] (unreported correlations are <  0.100)
outer : -1.29698792652e-05 -22.7386327356 42.7447694992
[[Fit Statistics]]
    # function evals   = 21
    # data points      = 28
    # variables        = 2
    chi-square         = 0.138
    reduced chi-square = 0.005
    Akaike info crit   = -144.795
    Bayesian info crit = -142.130
[[Variables]]
    xc:   5.8569e-05 +/- 0.032565 (55602.00%) (init= 0.2651148)
    yc:  -14.0758912 +/- 0.165202 (1.17%) (init=-27.47579)
[[Correlations]] (unreported correlations are <  0.100)
outer : 5.85687233641e-05 -14.0758912464 41.5707665446
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 25
    # variables        = 2
    chi-square         = 0.300
    reduced chi-square = 0.013
    Akaike info crit   = -106.545
    Bayesian info crit = -104.107
[[Variables]]
    xc:   0.01421278 +/- 0.061255 (430.99%) (init=-0.2295599)
    yc:  -16.3314669 +/- 0.336181 (2.06%) (init=-23.30099)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.138 
outer : 0.0142127841643 -16.3314669423 39.7077872798
#+end_example

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for inc in i30 i60 i45; do
      python $D/find-xy-shell.py M17-HD2040-60mic-$inc --mirror --pa0 0 --window 11
      python $D/fit-circle-shell.py M17-HD2040-60mic-$inc --thmax 60 --savefig --figscale 120
  done
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 32
    # variables        = 2
    chi-square         = 8.233
    reduced chi-square = 0.274
    Akaike info crit   = -39.442
    Bayesian info crit = -36.510
[[Variables]]
    xc:  -0.00030196 +/- 0.304693 (100906.07%) (init= 0.1526615)
    yc:  -42.8230678 +/- 1.771714 (4.14%) (init=-48.36428)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.000301957199037 -42.8230678902 91.3310510027
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 39
    # variables        = 2
    chi-square         = 6.376
    reduced chi-square = 0.172
    Akaike info crit   = -66.632
    Bayesian info crit = -63.305
[[Variables]]
    xc:   0.04778295 +/- 0.222363 (465.36%) (init=-1.559587)
    yc:  -46.3992588 +/- 1.226260 (2.64%) (init=-70.0189)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.166 
outer : 0.0477829592257 -46.399258795 116.146909206
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 36
    # variables        = 2
    chi-square         = 4.781
    reduced chi-square = 0.141
    Akaike info crit   = -68.677
    Bayesian info crit = -65.510
[[Variables]]
    xc:  -0.00943907 +/- 0.221300 (2344.52%) (init= 6.938018)
    yc:  -49.0033081 +/- 1.117650 (2.28%) (init=-55.76348)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    = -0.456 
outer : -0.00943907485149 -49.003308165 104.97190652
#+end_example

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  for suff in Halpha-i00 Halpha-i00-BS Halpha-i00-CD; do
      python $D/find-xy-shell.py M17-HD2040-$suff --mirror --pa0 0 --window 11
      python $D/fit-circle-shell.py M17-HD2040-$suff --thmax 60 --savefig --figscale 400
  done
  python $D/find-xy-shell.py  M17-MHD2040-AllB7-Halpha-i00 --mirror --pa0 0 --window 11
  python $D/fit-circle-shell.py M17-MHD2040-AllB7-Halpha-i00 --thmax 60 --savefig --figscale 300
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 21
    # data points      = 58
    # variables        = 2
    chi-square         = 15408.678
    reduced chi-square = 275.155
    Akaike info crit   = 327.770
    Bayesian info crit = 331.891
[[Variables]]
    xc:   0.00586830 +/- 10.45830 (178216.68%) (init= 3.196789)
    yc:  -249.522490 +/- 99.82762 (40.01%) (init=-123.2418)
[[Correlations]] (unreported correlations are <  0.100)
outer : 0.00586830732259 -249.522490891 362.179923057
[[Fit Statistics]]
    # function evals   = 23
    # data points      = 30
    # variables        = 2
    chi-square         = 6.015
    reduced chi-square = 0.215
    Akaike info crit   = -44.211
    Bayesian info crit = -41.408
[[Variables]]
    xc:  -0.00011207 +/- 0.280072 (249901.49%) (init=-0.08722588)
    yc:  -150.816486 +/- 1.915869 (1.27%) (init=-131.3879)
[[Correlations]] (unreported correlations are <  0.100)
outer : -0.000112072966344 -150.816486465 282.263586833
[[Fit Statistics]]
    # function evals   = 21
    # data points      = 28
    # variables        = 2
    chi-square         = 89.901
    reduced chi-square = 3.458
    Akaike info crit   = 36.662
    Bayesian info crit = 39.327
[[Variables]]
    xc:   8.2207e-07 +/- 1.023625 (124517821.61%) (init= 0.1989897)
    yc:  -92.7969269 +/- 6.603755 (7.12%) (init=-99.17076)
[[Correlations]] (unreported correlations are <  0.100)
outer : 8.22071275621e-07 -92.7969269403 193.944678758
[[Fit Statistics]]
    # function evals   = 33
    # data points      = 26
    # variables        = 2
    chi-square         = 20.523
    reduced chi-square = 0.855
    Akaike info crit   = -2.150
    Bayesian info crit = 0.366
[[Variables]]
    xc:  -3.5984e-05 +/- 1.326028 (3685052.33%) (init=-0.005741513)
    yc:  -234.403509 +/- 21.90155 (9.34%) (init=-62.3199)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.131 
outer : -3.59839760123e-05 -234.403509502 297.923251224
#+end_example

** Fit arcs to Meyer 2016 shapes
#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M16-MS2070n00p10-CD --pa0 0 --window 11
  python $D/fit-circle-shell.py M16-MS2070n00p10-CD --thmax 45 --savefig --figscale 400
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 20
    # variables        = 2
    chi-square         = 2.710
    reduced chi-square = 0.151
    Akaike info crit   = -35.975
    Bayesian info crit = -33.983
[[Variables]]
    xc:   0.33132410 +/- 0.328603 (99.18%) (init= 0.3099345)
    yc:  -90.3086796 +/- 2.550881 (2.82%) (init=-129.4369)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.109 
outer : 0.331324102216 -90.308679631 219.628145297
#+end_example


#+BEGIN_SRC sh :results silent
open M16-MS2070n00p10-*-arcfits.pdf
#+END_SRC

#+BEGIN_SRC sh :results verbatim
  D=../read-shapes-LL
  python $D/find-xy-shell.py M16-MS2070n00p10-BS --pa0 0 --window 10
  python $D/fit-circle-shell.py M16-MS2070n00p10-BS --thmax 45 --savefig --figscale 400
#+END_SRC

#+RESULTS:
#+begin_example
[[Fit Statistics]]
    # function evals   = 15
    # data points      = 23
    # variables        = 2
    chi-square         = 3.442
    reduced chi-square = 0.164
    Akaike info crit   = -39.685
    Bayesian info crit = -37.414
[[Variables]]
    xc:   0.97394196 +/- 0.352750 (36.22%) (init= 0.4950382)
    yc:  -129.062380 +/- 3.048129 (2.36%) (init=-149.6037)
[[Correlations]] (unreported correlations are <  0.100)
    C(xc, yc)                    =  0.100 
outer : 0.973941961957 -129.062380349 278.408680128
#+end_example


#+BEGIN_SRC sh :results file
python shape-conic-plot.py M16-MS2070n00p10
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-M16-MS2070n00p10.pdf]]



** New way of plotting bow shape
+ Plot 1/R against cos \theta
+ That should be a straight line for a confocal conic
+ If we take (1/R) - (1 + cos \theta)/2, then that is even better
  + Parabola is flat at 0, so we have compensated for the main slope
  + And we can see the variations more clearly
+ Big question is, what do we call this function?
  + *Compensated inversion* is a possibility
    + "/Inversion/" because 1/R is the circle inversion of the arc
    + "/Compensated/" because we subtract off a "typical" slope, as in a compensated power spectrum
  + *Departure function* is even better I think
    + It is the "/departure/" from a confocal parabola
    + less "clever"
    + We can call it \(\mathcal{D}\) or maybe \Delta
      \[ \Delta(\cos \theta) = \frac {R_{0}} {R(\theta)} - \frac12 (1 + \cos \theta)\]
#+BEGIN_SRC python :eval no :tangle shape-conic-plot.py
  import sys
  import json
  import numpy as np
  from astropy.coordinates import Longitude
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append("../Dust-wave")
  import bow_projection as bp

  try:
      prefix = sys.argv[1]
  except:
      print(f"Usage: {sys.argv[0]} PREFIX")

  plotfile = sys.argv[0].replace('.py', f'-{prefix}.pdf')

  def compensate(R, theta):
      """Compensated inversion of R(theta)"""
      return 1.0/R - 0.5*(1 + np.cos(theta))

  def load_R_th(arc_prefix):
      jfile = f'{arc_prefix}-arcdata.json'
      data = json.load(open(jfile))
      R0 = np.array(data['outer']['R0'])
      R = np.array(data['outer']['R'])
      th = Longitude(data['outer']['theta'], unit='deg')
      th += Longitude(data['outer']['PA0'], unit='deg')
      return th.rad, R/R0


  sns.set_style('ticks')
  fig, ax = plt.subplots()

  # Plot confocal parabola
  ax.axhline(0.0, ls='-', c='k', lw=0.5)

  # Plot wilkinoid
  mugrid = np.linspace(-1.0, 1.0, 200)
  thgrid = np.arccos(mugrid)
  ax.plot(mugrid, compensate(bp.wilkinoid_R_theta(thgrid), thgrid),
          '-', c='k', lw=1.5)

  # Plot cantoids
  for beta in 0.3, 0.1, 0.03, 0.01, 0.003, 0.001, 0.0003, 0.0001:
      ax.plot(mugrid, compensate(bp.cantoid_R_theta(thgrid, beta), thgrid),
              '-', c='k', lw=0.5)

  # Fill in forbidden zone
  ax.fill_between(mugrid, -0.5*(1.0 + mugrid), -1.0, color='k', alpha=0.4)

  # Plot traced arcs
  try:
      th, R = load_R_th(prefix + '-CD')
      ax.plot(np.cos(th), compensate(R, th), '.', alpha=0.6, label='CD')
      th, R = load_R_th(prefix + '-BS')
      ax.plot(np.cos(th), compensate(R, th), '.', alpha=0.6, label='BS')
  except:
      th, R = load_R_th(prefix)
      ax.plot(np.cos(th), compensate(R, th), '.', alpha=0.6, label=prefix)



  ax.legend(title=prefix)

  ax.set(
      xlim=[-1.02, 1.02],
      ylim=[-0.155, 0.155],
      xlabel=r"$\cos \,\theta$",
      ylabel=r"$(R_{0} / R) - 0.5 (1 + \cos \,\theta) $",
  )
  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python shape-conic-plot.py R97-Halpha-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-R97-Halpha-i00.pdf]]

#+BEGIN_SRC sh :results file
python shape-conic-plot.py A16-Halpha-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-A16-Halpha-i00.pdf]]

#+BEGIN_SRC sh :results file
python shape-conic-plot.py A16-20mic-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-A16-20mic-i00.pdf]]

#+BEGIN_SRC sh :results file
python shape-conic-plot.py A16-12mic-i00
#+END_SRC

#+RESULTS:
[[file:shape-conic-plot-A16-12mic-i00.pdf]]



*** Extrapolating into the far wings with the departure function
#+BEGIN_SRC python :eval no :tangle depart-extrapolate.py
  import sys
  import json
  import numpy as np
  from astropy.coordinates import Longitude
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append("../Dust-wave")
  import bow_projection as bp

  try:
      prefix = sys.argv[1]
  except:
      print(f"Usage: {sys.argv[0]} PREFIX")

  try:
      npoly = int(sys.argv[2])
  except:
      npoly = 2

  plotfile = sys.argv[0].replace('.py', f'-{prefix}.pdf')

  def load_R_th(arc_prefix):
      jfile = f'{arc_prefix}-arcdata.json'
      data = json.load(open(jfile))
      R0 = np.array(data['outer']['R0'])
      R = np.array(data['outer']['R'])
      th = Longitude(data['outer']['theta'], unit='deg')
      th += Longitude(data['outer']['PA0'], unit='deg')
      return th.rad, R/R0


  def departure(R, theta):
      """Parabolic departure of R(theta)"""
      return 1.0/R - 0.5*(1 + np.cos(theta))

  def extrapolate(mu, Delta, mu0=-0.5, force_open=False, deg=2):
      def factor(mu):
          if force_open:
              return np.abs(-1.0 - mu)**0.5
          else:
              return 1.0
    
      # Only fit mu < mu0
      mask = mu <= mu0
      p = np.poly1d(np.polyfit(mu[mask], Delta[mask]/factor(mu[mask]), deg=deg))
      mu_x = np.linspace(-1.0, mu0)
      return mu_x, factor(mu_x)*p(mu_x)


  sns.set_style('ticks')
  fig, ax = plt.subplots()

  # Plot confocal parabola
  ax.axhline(0.0, ls='-', c='k', lw=0.5)

  # Plot wilkinoid
  mugrid = np.linspace(-1.0, 1.0, 200)
  thgrid = np.arccos(mugrid)
  ax.plot(mugrid, departure(bp.wilkinoid_R_theta(thgrid), thgrid),
          '-', c='k', lw=1.5)

  # Plot cantoids
  for beta in 0.3, 0.1, 0.03, 0.01, 0.003, 0.001, 0.0003, 0.0001:
      ax.plot(mugrid, departure(bp.cantoid_R_theta(thgrid, beta), thgrid),
              '-', c='k', lw=0.5)

  # Fill in forbidden zone
  ax.fill_between(mugrid, -0.5*(1.0 + mugrid), -1.0, color='k', alpha=0.4)

  # Plot traced arcs
  th, R = load_R_th(prefix)
  Delta = departure(R, th)
  mu = np.cos(th)
  ax.plot(mu, Delta, '.', alpha=0.6, label=prefix)
  mux, Deltax = extrapolate(mu, Delta, deg=npoly, force_open=False)
  ax.plot(mux, Deltax, '-', alpha=0.6, label='_nolabel_')
  mux, Deltax = extrapolate(mu, Delta, deg=npoly, force_open=True)
  ax.plot(mux, Deltax, '-', alpha=0.6, label='_nolabel_')


  ax.legend(title=prefix)

  ax.set(
      xlim=[-1.02, 1.02],
      ylim=[-0.155, 0.155],
      xlabel=r"$\cos \,\theta$",
      ylabel=r"Parabolic departure function, $\Delta(\cos\theta)$",
  )
  sns.despine(trim=True)
  fig.tight_layout()
  fig.savefig(plotfile)
  print(plotfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python depart-extrapolate.py M17-MHD2040-AllB7 
#+END_SRC

#+RESULTS:
[[file:depart-extrapolate-M17-MHD2040-AllB7.pdf]]

#+BEGIN_SRC sh :results file
python depart-extrapolate.py M17-HD2040 1
#+END_SRC

#+RESULTS:
[[file:depart-extrapolate-M17-HD2040.pdf]]


** Plot planitude--alatude for Meyers (2017)

*** Harvest shape parameters
#+name: harvest-radii-m17
#+BEGIN_SRC python :return table
  import json

  SOURCES = [
      "M17-MHD2040-AllB7",
      "M17-MHD2040-AllB7-Halpha-i00",
      "M17-MHD2040-AllB7-60mic-i30",
      "M17-MHD2040-AllB7-60mic-i45",
      "M17-MHD2040-AllB7-60mic-i60",
      "M17-HD2040",
      "M17-HD2040-Halpha-i00-CD",
      "M17-HD2040-60mic-i30",
      "M17-HD2040-60mic-i45",
      "M17-HD2040-60mic-i60",
  ]

  radii_header = ['R0/100', 'Rc/R0', 'R90/R0', 'Rm90/R0']
  header = [['Source', *radii_header], None]
  INVALID = -999.00
  body = []
  for source in SOURCES:
      jfile = f'{source}-arcdata.json'
      data = json.load(open(jfile))
      assert source == data['star']['id']
      D = data['star']['D']
      row = [source]
      arc = 'outer'
      if arc in data:
          R0 = data[arc]['R0']
          Rc = data[arc]['Rc'] / R0
          if 'R90' in data[arc]:
              Rm90, R90 = data[arc]['R90']
              if Rm90 > 0.0:
                  Rm90 /= R0
              if R90 > 0.0:
                  R90 /= R0
          else:
              Rm90, R90 = INVALID, INVALID
          row += [f'{_:.2f}' for _ in [R0/100.0, Rc, Rm90, R90]]
      else:
          row += [f'{_:.2f}' for _ in [INVALID, INVALID, INVALID, INVALID]]
      body.append(row)

  #body.sort(key=lambda x: x[0])
  table = header + body

#+END_SRC

#+RESULTS: harvest-radii-m17
| Source                       | R0/100 | Rc/R0 | R90/R0 | Rm90/R0 |
|------------------------------+--------+-------+--------+---------|
| M17-MHD2040-AllB7            |   0.48 |  3.57 |   1.95 |    1.92 |
| M17-MHD2040-AllB7-Halpha-i00 |   0.62 |  4.78 |   2.21 |    2.21 |
| M17-MHD2040-AllB7-60mic-i30  |   0.20 |  2.14 |   1.74 |    1.73 |
| M17-MHD2040-AllB7-60mic-i45  |   0.23 |  1.70 |   1.59 |    1.61 |
| M17-MHD2040-AllB7-60mic-i60  |   0.27 |  1.51 |   1.47 |    1.46 |
| M17-HD2040                   |   0.84 |  1.78 |   1.75 |    1.75 |
| M17-HD2040-Halpha-i00-CD     |   0.99 |  1.96 |   2.09 |    2.08 |
| M17-HD2040-60mic-i30         |   0.48 |  1.89 |   1.80 |    1.79 |
| M17-HD2040-60mic-i45         |   0.56 |  1.87 |   1.90 |    1.59 |
| M17-HD2040-60mic-i60         |   0.70 |  1.66 |   1.55 |    1.59 |



*** Predict the projected planitude--alatude from the shape
+ [ ] Work out how to extrapolate the shape from 150 \to 180 degrees 

#+BEGIN_SRC python :eval no :tangle simulation_shape.py
  import sys
  import json
  import numpy as np
  import statsmodels.api as sm
  sys.path.append("../Dust-wave")
  from bow_projection import Spline_R_theta_from_grid


  def departure(R, theta):
      """Parabolic departure of R(theta)"""
      return 1.0/R - 0.5*(1 + np.cos(theta))

  def extrapolate(mu, Delta, mu0=-0.5, force_open=False, deg=2):
      def factor(mu):
          if force_open:
              return np.abs(-1.0 - mu)**0.5
          else:
              return 1.0

      # Only fit mu < mu0
      mask = mu <= mu0
      p = np.poly1d(np.polyfit(mu[mask], Delta[mask]/factor(mu[mask]), deg=deg))
      mu_x = np.linspace(-1.0, mu0)
      return mu_x, factor(mu_x)*p(mu_x)

  def R_from_Delta(mu, Delta):
      """Get radius back from departure coefficient"""
      return 1.0/(Delta + 0.5*(1.0 + mu))

  class Simulation(object):
      """
      Bow shape from simulation - defined on grid and fit with splines

      Callable as function of theta
      """
      json_suffix = "-arcdata.json"
      lowess_frac = 0.2

      def __init__(self, name, npoly=2, force_open=False, mode="all"):
          self.name = name
          with open(self.name + self.json_suffix) as f:
              data = json.load(f)
          # self.thgrid = np.abs(np.radians(data['outer']['theta']))
          self.thgrid = np.radians(data['outer']['theta'])
          self.Rgrid = np.array(data['outer']['R']) / data['outer']['R0']

          if mode == "all":
              # Use all points but take absolute value of theta
              self.thgrid = np.abs(self.thgrid)
              # And do some lowess smoothing
              smooth = sm.nonparametric.lowess(self.Rgrid, self.thgrid,
                                               frac=self.lowess_frac)
              self.thgrid = smooth[:, 0]
              self.Rgrid = smooth[:, 1]
          elif mode == "positive":
              # Use only points with positive theta
              m = self.thgrid > 0.0
              self.thgrid = self.thgrid[m]
              self.Rgrid = self.Rgrid[m]
          elif mode == "negative":
              # Use only points with negative theta
              m = self.thgrid < 0.0
              self.thgrid = -self.thgrid[m]
              self.Rgrid = self.Rgrid[m]

          # Make sure arrays are sorted 
          sort_order = self.thgrid.argsort()
          self.thgrid = self.thgrid[sort_order]
          self.Rgrid = self.Rgrid[sort_order]

          # Extrapolate to theta = pi
          mu = np.cos(self.thgrid)
          Delta = departure(self.Rgrid, self.thgrid)
          mu_x, Delta_x = extrapolate(mu, Delta, deg=npoly, force_open=force_open)
          th_x = np.arccos(mu_x)
          R_x = R_from_Delta(mu_x, Delta_x)

          # Add on the extrapolated points
          self.thgrid = np.concatenate((self.thgrid, th_x))
          self.Rgrid = np.concatenate((self.Rgrid, R_x))
          # And sort again just in case
          sort_order = self.thgrid.argsort()
          self.thgrid = self.thgrid[sort_order]
          self.Rgrid = self.Rgrid[sort_order]

          # Finally do the spline fit
          self.splinefit = Spline_R_theta_from_grid(
              theta_grid=self.thgrid, R_grid=self.Rgrid)

      def __call__(self, theta):
          # When called as a function, give the spline fitted result
          return self.splinefit(theta)



#+END_SRC


**** Test R(\theta) spline fit for Meyer (2017) shapes
#+BEGIN_SRC python :eval no :tangle test_simulation_shape.py
  import sys
  import numpy as np
  from simulation_shape import Simulation
  from matplotlib import pyplot as plt
  import seaborn as sns

  figfile = sys.argv[0].replace('.py', '.pdf')


  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)

  Simulation.lowess_frac = 0.1
  mode = "negative"
  for label, shape in [
          ["MHD open",
           Simulation(name="M17-MHD2040-AllB7", force_open=True, mode=mode)],
          ["MHD closed",
           Simulation(name="M17-MHD2040-AllB7", force_open=False, mode=mode)],
          ["HD open",
           Simulation(name="M17-HD2040", force_open=True, mode=mode)],
          ["HD closed",
           Simulation(name="M17-HD2040", force_open=False, mode=mode)],
  ]:
      ax.plot(np.degrees(shape.thgrid), shape.Rgrid,
              color='b', alpha=0.2, lw=2, label='_nolabel_')
      ax.plot(th_dg, shape(th), lw=0.8, label=label)

  ax.legend(title=r"Simulation shapes")
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$R$",
      xlim=[0, 180],
      yscale='log',
      ylim=[0.9, 30.0],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_simulation_shape.py
#+END_SRC

#+RESULTS:
[[file:test_simulation_shape.pdf]]


**** Test \omega from simulation
This looks a bit ropey
#+BEGIN_SRC python :eval no :tangle test_simulation_omega.py
  import sys
  import numpy as np
  from simulation_shape import Simulation
  sys.path.append("../Dust-wave")
  from bow_projection import omega
  from matplotlib import pyplot as plt
  import seaborn as sns

  figfile = sys.argv[0].replace('.py', '.pdf')


  sns.set_style('ticks')
  fig, ax = plt.subplots()

  th = np.linspace(-np.pi, np.pi, 1001)
  th_dg = np.degrees(th)

  for sim in ["M17-MHD2040-AllB7", "M17-HD2040"]:
      shape = Simulation(name=sim)
      ax.plot(th_dg, omega(th, shape), label=sim)

  ax.legend(title=r"Simulation shapes")
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='white', lw=4, zorder=100)
  ax.axhline(1.0, xmin=0.35, xmax=0.65, color='k', lw=1, ls=':', zorder=101)
  ax.axhspan(0.0, 1.0, color='k', alpha=0.05, ec='none')
  ax.set_yscale('symlog', linthreshy=1.0, linscaley=0.5)
  ax.set(
      xlabel=r"Polar angle: $\theta$, degrees",
      ylabel=r"$\omega \equiv R^{-1} d R / d \theta$",
      xlim=[0, 180],
      ylim=[0.0, 2e2],
      xticks=[0, 30, 60, 90, 120, 150, 180],
  )
  sns.despine()
  fig.tight_layout()
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_simulation_omega.py
#+END_SRC

#+RESULTS:
[[file:test_simulation_omega.pdf]]


**** Test (x_t’, y_t’) for simulations
#+BEGIN_SRC python :eval no :tangle test_xyprime_simulation.py
  import sys
  import numpy as np
  from matplotlib import pyplot as plt
  import seaborn as sns
  sys.path.append("../Dust-wave")
  from bow_projection import (xyprime_t, theta_infinity, theta_0_90,
                              characteristic_radii_projected)
  from simulation_shape import Simulation

  figfile = sys.argv[0].replace('.py', '.pdf')

  sns.set_style('ticks')
  fig, axes = plt.subplots(2, 2, figsize=(6, 6), sharex=True, sharey=True)

  # For some reason, exactly 30.0 had problems with R0p
  inclinations = [0.0, 15.0, 30.01, 45.0, 60.0, 75.01]
  linewidths = [2.4, 2.0, 1.6, 1.2, 0.8, 0.4]
  colors = sns.color_palette('magma_r', n_colors=len(inclinations))

  sims = ["M17-MHD2040-AllB7", "M17-HD2040", "M17-MHD2040-AllB7", "M17-HD2040"]

  for sim, ax in zip(sims, axes.flat):
      shape = Simulation(name=sim)
      th_inf = theta_infinity(shape)
      for inc_dg, color, lw in zip(inclinations, colors, linewidths):
          inc = np.radians(inc_dg)
          th0, th90 = theta_0_90(inc, shape)
          th = np.linspace(th0, th_inf, 301)
          xp, yp = xyprime_t(th, inc, shape)
          m = np.isfinite(xp) & np.isfinite(yp)
          if m.sum() == 0:
              # Case of no tangent line at all at this inclination
              continue
          xxp = np.concatenate((xp[m][::-1], xp[m]))
          yyp = np.concatenate((-yp[m][::-1], yp[m]))
          radii = characteristic_radii_projected(inc, shape)        
          R0p = radii['R_0 prime']
          ax.plot(xxp/R0p, yyp/R0p,
                  label=fr"$i = {inc_dg:.0f}^\circ$",
                  color=color, lw=1.5*lw)

      ax.plot([0], [0], 'o', color='k')

      ax.legend(title=sim,
                fontsize='small',
                handlelength=1.0, handletextpad=0.5, columnspacing=0.3,
                ncol=2, loc="center left")
      ax.set_aspect('equal', adjustable='box-forced')

  axes[-1,0].set(
      xlabel=r"$x' / R_0'$",
      ylabel=r"$y' / R_0'$",
      xlim=[-7, 3],
      ylim=[-5, 5],
  )

  sns.despine()
  fig.tight_layout(pad=0.3, h_pad=0.1, w_pad=0.1)
  fig.savefig(figfile)
  print(figfile, end='')
#+END_SRC

#+BEGIN_SRC sh :results file
python test_xyprime_simulation.py
#+END_SRC

#+RESULTS:
[[file:test_xyprime_simulation.pdf]]


** Original version --- Plot the planitude--alatude

*** Harvest the shape parameters from the JSON files
+ Do it like in [[id:A3F62646-04B8-448B-91FF-8E1DC04A9C41][The red supergiants and AGB stars]]

#+BEGIN_SRC sh :results verbatim
ls *.json |cut -d'-' -f1-3
#+END_SRC

#+RESULTS:
#+begin_example
A16-12mic-i00
A16-12mic-i30
A16-12mic-i60
A16-20mic-i00
A16-20mic-i30
A16-20mic-i60
A16-Halpha-i00
A16-Halpha-i30
A16-Halpha-i60
R97-Halpha-i00
#+end_example

#+name: harvest-radii-sims
#+BEGIN_SRC python :return table
  import json

  SOURCES = [
      "A16-12mic-i00", 
      "A16-12mic-i30", 
      "A16-12mic-i60", 
      "A16-20mic-i00", 
      "A16-20mic-i30", 
      "A16-20mic-i60", 
      "A16-Halpha-i00", 
      "A16-Halpha-i30", 
      "A16-Halpha-i60", 
      "R97-Halpha-i00", 
  ]

  radii_header = ['R0/100', 'Rc/R0', 'R90/R0', 'Rm90/R0']
  header = [['Source', *radii_header], None]
  INVALID = -999.00
  body = []
  for source in SOURCES:
      jfile = f'{source}-arcdata.json'
      data = json.load(open(jfile))
      assert source == data['star']['id']
      D = data['star']['D']
      row = [source]
      arc = 'outer'
      if arc in data:
          R0 = data[arc]['R0']
          Rc = data[arc]['Rc'] / R0
          if 'R90' in data[arc]:
              Rm90, R90 = data[arc]['R90']
              if Rm90 > 0.0:
                  Rm90 /= R0
              if R90 > 0.0:
                  R90 /= R0
          else:
              Rm90, R90 = INVALID, INVALID
          row += [f'{_:.2f}' for _ in [R0/100.0, Rc, Rm90, R90]]
      else:
          row += [f'{_:.2f}' for _ in [INVALID, INVALID, INVALID, INVALID]]
      body.append(row)

  #body.sort(key=lambda x: x[0])
  table = header + body

#+END_SRC

#+RESULTS: harvest-radii-sims
| Source         | R0/100 | Rc/R0 | R90/R0 | Rm90/R0 |
|----------------+--------+-------+--------+---------|
| A16-12mic-i00  |   0.44 |  2.59 |   1.69 |    1.69 |
| A16-12mic-i30  |   0.42 |  2.90 |   1.97 |    1.88 |
| A16-12mic-i60  |   0.54 |  1.90 |   1.45 |    1.42 |
| A16-20mic-i00  |   0.41 |  2.05 |   1.75 |    1.87 |
| A16-20mic-i30  |   0.40 |  2.41 |   1.96 |    1.97 |
| A16-20mic-i60  |   0.43 |  4.94 |   1.78 |    1.82 |
| A16-Halpha-i00 |   0.52 |  1.83 |   1.57 |    1.79 |
| A16-Halpha-i30 |   0.63 |  2.25 |   1.53 |    1.54 |
| A16-Halpha-i60 |   0.81 |  1.37 |   1.38 |    1.38 |
| R97-Halpha-i00 |   0.92 |  1.55 |   2.16 |    2.09 |

*** Make the plot
#+header: :var T=harvest-radii-sims :colnames no
#+BEGIN_SRC python :eval no :tangle sims-planitude-alatude.py
  import sys
  import numpy as np
  from scipy.interpolate import interp1d
  import statsmodels.api as sm
  from astropy.table import Table
  from matplotlib import pyplot as plt
  import matplotlib.ticker
  import seaborn as sns
  sys.path.append("../Dust-wave")
  import bow_projection as bp
  import bow_diagnostic


  plotfile = sys.argv[0].replace('.py', '.pdf')

  table = Table(rows=T[1:], names=T[0], dtype=[str] + [float]*4)

  # Take average +/- std of the +ve and -ve R90
  R90stack = np.stack([table['R90/R0'], table['Rm90/R0']])
  table['R90'] = np.nanmean(R90stack, axis=0)
  table['dR90'] = np.nanstd(R90stack, axis=0)
  table.remove_columns(['R90/R0', 'Rm90/R0'])

  sns.set_style('ticks')
  fig, ax = plt.subplots(figsize=(4, 4))

  Rc_grid = np.linspace(0.0, 10.0, 2000)
  R90_T0_grid = np.sqrt(2*Rc_grid)
  R90_T1_grid = np.sqrt(2*Rc_grid - 1.0)
  R90_T1_grid[~np.isfinite(R90_T1_grid)] = 0.0 

  ax.fill_between(Rc_grid, R90_T1_grid, R90_T0_grid, color='k', alpha=0.2)
  ax.fill_between(Rc_grid, R90_T0_grid, color='k', alpha=0.1)
  ax.plot(Rc_grid, R90_T0_grid, c='k', lw=0.5)
  ax.axhline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.axvline(1.0, lw=0.5, alpha=0.5, color='k', zorder=-1)
  ax.plot([0.0, 10.0], [0.0, 10.0], lw=0.5, alpha=0.5, color='k', zorder=-1)

  # Put a cross at the Wilkinoid coordinates: [5/3, sqrt(3)]
  ax.plot([5./3.], [np.sqrt(3.0)], '+', c='w', ms=10, alpha=1.0)
  # And plot the projected wilkinoids 
  bp.N_NEIGHBORHOOD = 50
  bp.DEGREE_POLY_NEIGHBORHOOD = 2
  bp.SCALE_NEIGHBORHOOD = 0.03
  bp.DEGREE_POLY_NEIGHBORHOOD_90 = 2
  bp.SCALE_NEIGHBORHOOD_90 = 0.01
  shape = bp.wilkinoid_R_theta
  th_inf = bp.theta_infinity(shape)
  inc = np.linspace(0.0, th_inf - np.pi/2, 50)
  tab = bow_diagnostic.parameter_table(inc, shape)
  Rc, R90 = tab['tilde R_c prime'], tab['tilde R_90 prime']
  ax.plot(Rc, R90, '-', c='w', label="_nolabel_", lw=0.6, alpha=0.9)
  sini = (0.5 + np.arange(20))/20
  inc_e = np.arcsin(sini)
  tab_e = bow_diagnostic.parameter_table(inc_e, shape)
  Rc_e, R90_e = tab_e['tilde R_c prime'], tab_e['tilde R_90 prime']
  ax.scatter(Rc_e, R90_e, marker='|', s=3**2,
             linewidths=0.1, edgecolors='none',
             c='w', alpha=0.5, label="_nolabel_")


  models = ["A16-12mic", "A16-20mic", "A16-Halpha", "R97-Halpha"]

  colors = sns.color_palette(n_colors=len(models))
  for model, color in zip(models, colors):
      mask = [s.startswith(model) for s in table['Source']]
      data = table[mask]
      ax.plot(data['Rc/R0'], data['R90'], '-', c=color, label=model, lw=1.5, alpha=0.9)
      # Put a dot at the i=0 case
      ax.plot(data['Rc/R0'][0:1], data['R90'][0:1], 'o', mec='none', c=color, label="_nolabel_", alpha=0.7)



  ax.legend(ncol=1, fontsize='small', title='Simulations',
            frameon=True, loc="lower right")
  ax.set(
      xlim=[0.0, 5.1],
      ylim=[0.0, 5.1],
      yticks=range(6),
  #    ylim=[-3.0, 1.1],
      xlabel=r"Projected planitude: $\Pi'$",
      ylabel=r"Projected alatude: $\Lambda'$",
  )        

  sns.despine()
  fig.tight_layout(pad=0.5)
  fig.savefig(plotfile)
  print(plotfile, end='')


#+END_SRC

#+BEGIN_SRC sh :results file
python sims-planitude-alatude.py
#+END_SRC

#+RESULTS:
[[file:sims-planitude-alatude.pdf]]
